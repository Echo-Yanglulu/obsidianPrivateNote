# 源码解析
## react源码的组织方式
1. 动态注入。在源码中，react只是进行*声明*，具体*实现*是在react-dom中实现的[^1]。
	1. 为何使用这种方式？为了要抽取公共部分，可认为react-dom是一个render器，native是另一个
2. 嵌套循环。react-dom在渲染html节点时采用这种方式。
	1. 为何使用这种方式？因为html的dom结构本身就是一种嵌套。

看vscode
# virtual dom
1. v-dom是什么
	1. 官方定义：一个编程理念，被保存在内存中的*对UI的映射*，并通过某些库（如[[ReactDOM]]）将该映射同步渲染为真实DOM。
	2. 基于浏览器API，由第三方库实现
2. 特性
	1. 抽象性【它对UI的抽象。使跨平台使用成为可能，一处学习，随处使用】
		1. V-dom提供了对HTML DOM的抽象，所以在web开发中通常不用调用[[DOM]] api
		2. 也是因为它提供了DOM的抽象，也可用于开发Native
3. 过程
	1. 在web开发中，v-dom如何渲染为html元素。
		1. 在class组件中可看到，react通过render方法生成v-dom，从而绘制出真实的dom
4. 如何进行diff
	1. 过程
		1. 修改state，调用render方法调用产生一个v-dom
		2. 通过对比新旧v-dom确定需要更新的内容
		3. 通过库修改需要更新的内容
	2. 层次
		1. 组件级别进行比较
			1. 当一个组件改变时，并不会去检查它们的子组件是否有更新。实际中很大概率是更新的，所以不再牺牲时间进行子组件的比较。直接整个替换
		2. 元素级别比较
			1. 子节点新增、删除：react-dom对元素进行简单的增删
			2. 子节点移动：react-dom会进行比较复杂的比较过程。
				1. 如果开发者把最后一个子节点移动到第一个，r-d会将前面的节点依次向后移动（如果代码中有这种操作，源码的实现是比较低效的）【日常开发中要避免这种操作】

## dom更新过程
1. 调用dom api更新
	1. 
2. 通过v-dom更新
	1. 每次render生成一个新的v-dom
	2. diff新旧v-dom，确定变更
	3. 调用dom api更新

表面上看起来好像v-dom更新dom的过程多了几步。
频繁操作dom会引起页面重绘

# Shadow DOM
定义：是一种浏览器技术，可用于限制web components中的变量和CSS。

# 协调
定义：将[[react原理#virtual dom|virtual dom]]同步渲染为真实[[DOM]]的过程。是react中最重要、最核心的部分。
有两种协调方式
## Stack协调
v15使用的协调方式
## Fiber协调
v16的[[react]]使用的协调方式
	1. 是一次重大的创新，解决了Stack协调中遇到的一些问题。
		1. 渲染过程不可阻断
		2. 更新过程如果耗时较长，会难以响应用户行为【造成卡顿】
		3. 没有区分任务的优先级。不会重点关注一些用户希望及时反应的行为
			1. 多次输入后，像PPT一样瞬间展示已输入内容
		4. 更清晰的错误处理
		5. 适时重启渲染
		6. 父子组件间切换时布局更新
### Fiber的数据结构
![[Pasted image 20230530115739.png]] 
15的版本中v-dom是*对象*，16中是使用**Fiber节点**对html的dom结构进行映射【v-dom是Fiber节点，本质是*链表*】
### 协调过程
1. render阶段
	1. 执行组件的返回UI[^2]，确定需要更新的内容。此过程可阻断【在v15中此阶段不可阻断】
2. commit阶段
	1. 提交更新并调用对应渲染模块（ReactDOM）渲染为真实DOM。为防止页面抖动，此阶段为同步且不可阻断[^3]。
### 时间分片
解决v15中任务没有优先级的问题，使用时间分片进行*任务拆分*。
![[Pasted image 20230530121223.png]] 
理解时间分片 ![[Pasted image 20230530121401.png]] 
![[Pasted image 20230530121713.png]] 




[^1]: 如setState
[^2]: class组件是render，函数组件是return
[^3]: 此阶段用户可感知到