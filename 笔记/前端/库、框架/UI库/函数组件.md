# 概述
是一个纯函数，（react只需从上到下执行它），接收参数（组件的属性），返回值（返回的内容将作为该组件的UI）

理解
	1. 如果不理解[[Function]]、[[纯函数]]、[[非纯函数]]、[[副作用]]，就无法理解react处理函数组件的方式。
		1. 我们创建的组件可能是纯函数，也会是非纯函数。关键在于要知道自己正在创建什么副作用。
## 使用条件
在**函数组件内**的**最顶层**[[作用域]]。
	1. 顶层能保证Hook每次渲染都按顺序被调用。在条件语句中会导致顺序改变，react无法正确关联内部state与对应的hook
# 机制


# useState
本质：将本地的状态封装在函数组件中。
形式与内容：const [state, setState] = useState(initialValue)
	1. state：保存状态的变量
	2. setState
		1. 内容：state的期望值
		2. 形式
			1. [[Function]]：去获取当前组件中维护的最新的状态值
			2. [[值]]：当前读取到的（可能是旧值）
	3. initialValue
		1. 内容：该state的初始值
		2. 形式
			1. [[Function]]：初始化时调用，设置返回值为初始值
			2. [[值]] 
## 原理
1. 从react中导入，但不是在这个包中实现的，而是在react-reconciler。
	1. 在try/catch中，使用了mountState（initialValue）方法
	2. 关键是mountState的实现 ![[Pasted image 20230601130853.png]] 
2. 多个调用，如何保证按顺序执行？
	1. 初始化时
		1. 每次调用：都会返回一个hook对象、生成一对state/setter映射。
		2. 每次渲染：都会按照初始化的序列遍历*由多个映射组成的数组*。
	2. 初始化state时，不能在条件语句中，因为每次执行都是按照初始化的顺序执行。存在条件语句则数组顺序可能不同。

# useEffect
多个[[副作用]] 
	1. 把依赖一组state变化的副作用放在一起

特性
	1. 如果依赖列表中没有监听某个state，则effect中读取该state会存在【相当于useEffect不会把没有监听的state值传入：还是旧值】
# useRef
保存一个与页面渲染无关的数据。一般是DOM。在组件存在时一直存在。
# useMemo

# useLayout

# useReducer
另一种useState。与它有什么区别？？？
# useCallback

# 案例
```js
import React, { useState, useEffect, useRef } from "react";

export default function CountDown() {
  const maxTime = 60;
  const [countDownText, setCountDownText] = useState("获取验证码");
  const [timerNum, setTimerNum] = useState(maxTime);
  const [boolCountDown, setBoolCountDown] = useState(false);
  const refCountDown = useRef(null);
  const handleClick = () => {
    if (!boolCountDown) {
      setBoolCountDown(true);
    }
  };

  refCountDown.current = () => {
  // 为什么在这里读取的就是更新后的值
    if (timerNum > 0) {
      setTimerNum(timerNum - 1);
    } else {
      setTimerNum(maxTime);
      setBoolCountDown(false);
      setCountDownText("重新获取");
    }
  };
  // 为什么在这里读取的就一直是最新值？

  // const otherCountDown = () => {
  // 为什么在这里读取的就一直是初始值
  // 因为定时器是异步的。第一次执行effect时这里读取到timerNum是60，
  //   console.log(timerNum, "timerNum");
  //   setTimerNum((timerNum) => timerNum - 1);
  // };

  useEffect(() => {
    if (boolCountDown) {
      const timer = setInterval(() => {
        // otherCountDown();
        refCountDown.current();
      }, 1000);
      return () => clearInterval(timer);
    }
  }, [boolCountDown]);

  return (
    <div>
      <button type="button" onClick={handleClick}>
        {boolCountDown ? `${timerNum}s` : countDownText}
      </button>
    </div>
  );
}

```

1. [blissful-colden-5vmuw - CodeSandbox](https://codesandbox.io/s/blissful-colden-5vmuw)：用函数组件实现一个定时器。