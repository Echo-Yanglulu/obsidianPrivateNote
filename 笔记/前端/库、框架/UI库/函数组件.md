# 概述
是一个纯函数，（react只需从上到下执行它），接收参数（组件的属性），返回值（返回的内容将作为该组件的UI）

目的：为了在函数组件中使用[[状态]]与[[副作用]]（函数组件曾被区别称为“无状态组件”）。

意义
	1. 发明hooks的动机：在无状态组件需要状态时，不需要完全重构为类，可直接使用状态管理、副作用
	2. 它如何改变了react
		1. 既然一个副作用有它自己的设置和清除阶段，就把它放在同一个hook中
		2. context的抽象也好，HOC与render props的抽象也好，都增加了组件的*嵌套地狱*。
			1. 形成了可读性很差的组件树，因为所有的抽象逻辑都用组件实现，实际用于展示的组件却很难追踪
			2. 将这些并非用于展示的组件（逻辑组件）使用副作用封装。就打平了组件树的结构
	3. 

前提
	1. 如果不理解[[Function]]、[[纯函数]]、[[非纯函数]]、[[副作用]]，就无法理解react处理函数组件的方式。
		1. 我们创建的组件可能是纯函数，也会是非纯函数。关键在于要知道自己正在创建什么副作用。
## 使用条件
在**函数组件内**的**最顶层**[[作用域]]。
	1. 顶层能保证Hook每次渲染都按顺序被调用。在条件语句中会导致顺序改变，react无法正确关联内部state与对应的hook
# 原理
## 执行
1. 挂载【组件挂载到DOM结构中】
	1. 执行非渲染代码
		1. useState：*初始值*作为最新常量返回，生成*只属于此次渲染*的（state+props+eventHandler）
		2. useEffect
			1. 捕获所有依赖变量
			2. 添加需要被执行和清除的副作用[^1] 
	2. 执行渲染代码
		1. 执行return，读取此次执行时使用props, state, eventHandler所生成的**快照**，并依据该快照生成UI的快照。
	3. 渲染完毕
	4. 执行useEffect中添加的[[副作用]] 
		1. useEffect使用全新的props，state绑定副作用
2. 更新【组件更新】
	1. 执行非渲染代码
		1. useState：*setState传入值*作为最新常量返回，生成*只属于此次渲染*的（state+props+eventHandler）
		2. useEffect【如果**依赖没有更新**，则**不执行**】
	2. 执行渲染代码
	3. 渲染完毕
	4. 检查队列
		1. 如果有
			1. 执行渲染前添加的清除副作用【因为大多数effect的执行并不会阻塞DOM更新，所以先清除】
			2. 执行渲染前添加的副作用【如果被跳过，则不执行】
3. 卸载
	1. 清除副作用

每次state更新，都会重新生成组件UI、逻辑的快照。
根据某个state更新，决定是否更新副作用。
# useState
本质：将本地的[[状态]]封装在函数[[组件]]中。
形式：const [state, setState] = useState(initialValue)
	1. state：保存*状态*的变量
		1. 每次渲染时都会调用。挂载时返回InitialValue，更新时返回最新set的值
	2. setState：保存*修改状态的函数*的变量
		1. [[Function]]：去获取当前组件中维护的最新的状态值（并不是此次渲染的值）
			1. setCount(count => count + 1)
			2. **读取react中维护的值，而不是此次渲染中的值**。即使当前渲染的state并没有更新，是在定时器中修改的，也可读取。
			3. **state的更新依赖于旧值**【此时[[函数组件#useReducer|userReducer]]可能是更好的选择】
		2. [[值]]：当前读取到的（可能是旧值）
	3. initialValue：状态的初始值
		1. [[Function]]：初始化时调用，设置返回值为初始值
		2. [[值]] 
执行机制
	1. 每次渲染时，将初始值（挂载）或通过setState传入的值（更新）声明为当前组件内的**常量**。
## 原理
1. 从react中导入，但不是在这个包中实现的，而是在react-reconciler。
	1. 在try/catch中，使用了mountState（initialValue）方法
	2. 关键是mountState的实现 ![[Pasted image 20230601130853.png]] 
2. 多个调用，如何保证按顺序执行？
	1. 初始化时
		1. 每次调用：都会返回一个hook对象、生成一对state/setter映射。
		2. 每次渲染：都会按照*初始化的序列*遍历*由多个映射组成的数组*。
	2. 初始化state时，不能在条件语句中，因为每次执行都是按照初始化的顺序执行。存在条件语句则数组顺序可能不同。
# useEffect
## 功能
执行时：捕获变量，副作用的添加逻辑在*此次渲染后*执行，副作用的清除逻辑在*下次渲染后、副作用添加逻辑执行前*执行
	1. 挂载，仅执行添加
	2. 更新，先执行清除，再执行添加
	3. 卸载，仅执行清除
## 原理
1. **捕获**定义它的那次渲染中的props与state
	1. 【在副作用设置函数里，拿到的是初始的props与state。如果想拿到最新值】
		1. 添加到依赖队列【仅当副作用需要依赖该state时】
		2. 使用useRef。从外界获取最新state
		3. 在副作用的setState中传入函数。
	2. 清除副作用时保存的值会在下次渲染时被调用。
		1. 此次渲染时执行的清除逻辑中，保存的都是上次渲染的状态
	3. 监听值没有改变，所以该次更新跳过了该effect，没有重新进行捕获。
形式：useEffect(() => {}, [])
	1. []：该副作用不使用[[react]]*数据流中的值*。只在组件*挂载时*调用一次。
	2. [a]：组件*挂载时、a改变*时【仅在某些状态改变时执行的副作用】
	3. useEffect(()=>{})：每次状态改变时【没有意义，跟直接写在外面相同】
特性
	1. 如果依赖列表中没有监听某个state，则不会重新捕获，导致每次调用副作用时使用的都是旧state。
		1. `setCount(count => count + 1)`。存在问题：如果有两个互相依赖的状态，则不能做到。
		2. 与该方法相似的是[[#useReducer]]可做到
## 常见问题
1. 你以为没有使用数据流中的值，但其实使用了。你要使用策略（主要是useReducer 和 useCallback）来移除这些effect依赖。
## 应用
### 仅当组件更新时执行副作用
```js
const Toggler = ({ toggle, onToggle }) => {
// 添加“已挂载”的标识
  const didMount = React.useRef(false);
// 在任意一个副作用中读取ref值，如果是false就取反，如果是true就执行副作用
  React.useEffect(() => {
    if (didMount.current) {
      console.log('I run only if toggle changes.');
    } else {
      didMount.current = true;
    }
  }, [toggle]);

  return (
    <div>
      <button type="button" onClick={onToggle}>
        Toggle
      </button>

      {toggle && <div>Hello React</div>}
    </div>
  );
};
```
### 仅当依赖改变时执行一次副作用
```js
const Toggler = ({ toggle, onToggle }) => {
  // 添加已“执行一次”的标识
  const calledOnce = React.useRef(false);

  React.useEffect(() => {
    if (calledOnce.current) {
      return;
    }

    if (toggle === false) {
      console.log('I run only once if toggle is false.');

      calledOnce.current = true;
    }
  }, [toggle]);

  return (
    <div>
      <button type="button" onClick={onToggle}>
        Toggle
      </button>

      {toggle && <div>Hello React</div>}
    </div>
  );
};
```
## 相关
[useEffect 完整指南 — Overreacted](https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/) 
## 总结
1. 挂载与更新【无数组或[a]】
2. 仅当挂载【[]】
3. 仅更新【ref】
# useRef
本质：保存一个会突变的ref对象，在组件的执行周期中始终存在。
作用：保存一个与页面渲染无关的数据。一般是DOM。
## 应用
1. 使副作用仅在更新时执行
2. 定时器
# useMemo
传参：同[[函数组件#useEffect]]。
原因：当一个组件更新时，即使子组件接收的props没有更新也会重新渲染。为避免没有变化的重渲染。

问题：如果传递的属性是引用类型数据，从内容上看确实没变，但父组件重新执行就是声明了一个*新变量*，所以子组件仍会更新
	将传递的引用类型数据使用useMemo，保留引用值。
```js
import React, { memo, useState } from 'react';

// 子组件
const ChildComp = (props:{info:{name, age}}) => {
  console.log('ChildComp...',name,age);
  return (<div>ChildComp...</div>);

};

const MemoChildComp = memo(ChildComp);

// 父组件
const Parent = () => {
  const [count, setCount] = useState(0);
  const [name] = useState('jack');
  const [age] = useState(11);
  // 更新前：会一直重新渲染
  const info = { name, age };
  // 更新后：引用类型不会再导致重新渲染
  const info = useMemo(() => ({ name, age }), [name, age]);
  return (
    <div className="App">
      <div>hello world {count}</div>
      <button onClick={() => { setCount(count => count + 1); }}>点击增加</button>
      <MemoChildComp info={info}/>
    </div>
  );
};

export default Parent;

```


## 应用
1. 如果组件的props变化不频繁，可使用该hook包裹组件
2. 组件的渲染开销较大时，使用memo包裹组件
3. 当子组件的属性为函数时，，使用useCallback（减少渲染次数）
# useCallback
背景：当一个组件更新时，所有子组件也会全部更新。
问题：
	1. 虽然为该组件使用了React.memo。但props传入函数时它还是重新渲染了。
		1. 原因：父组件内重新渲染时，重新声明了一个不同的函数。所以**子组件认为props改变了**。
			1. 这么说的话，函数组件的子组件无效渲染问题可能存在。
		2. 方案：将需要下传的回调使用useCallback包裹【仅处理下传的函数】
传参：同[[函数组件#useEffect]]。
功能：返回回调的缓存版本。当依赖列表内的值改变时，更新传入的函数，返回一个新函数
	1. props判断相等时，认为收到了一个新函数

## 应用
1. 
# useLayout

# useReducer
另一种useState。与它有什么区别？？？
	1. 相似
		1. 修改状态
		2. 返回一个数组：state、修改该state的方法
	2. 不同
		1. 将state改变时相关逻辑封装在修改方法内
		2. 需求：相对useState，较为**复杂的状态**。
			1. 一个state的新值依赖于旧值
			2. 一个state的新值依赖于另一个state
			3. 包含多个子值
			4. 能给触发了深更新的组件进行性能优化【？不懂】
形式
	1. 定义：`const [state, dispatch] = useReducer( reducer, initialValue )` 
	2. 调用：
# useContext

# 自定义hook
```js
import React from 'react';
// 定义检测在线状态的hook
function useOffline() {
  const [isOffline, setIsOffline] = React.useState(false);

  function onOffline() {
    setIsOffline(true);
  }

  function onOnline() {
    setIsOffline(false);
  }

  React.useEffect(() => {
    window.addEventListener('offline', onOffline);
    window.addEventListener('online', onOnline);

    return () => {
      window.removeEventListener('offline', onOffline);
      window.removeEventListener('online', onOnline);
    };
  }, []);
// 返回在线状态
  return isOffline;
}
// 在整个应用层级调用
function App() {
  const isOffline = useOffline();

  if (isOffline) {
    return <div>Sorry, you are offline ...</div>;
  }

  return <div>You are online!</div>;
}

export default App;
```
#  其他API
React.memo：用于缓存函数组件，对两次渲染的props进行浅层比较，如果相同则不作更新。
# 案例
1. 倒计时
```js
import React, { useState, useEffect, useRef } from "react";

export default function CountDown() {
  const maxTime = 60;
  const [countDownText, setCountDownText] = useState("获取验证码");
  const [timerNum, setTimerNum] = useState(maxTime);
  const [boolCountDown, setBoolCountDown] = useState(false);
  const refCountDown = useRef(null);
  const handleClick = () => {
    if (!boolCountDown) {
      setBoolCountDown(true);
    }
  };

  refCountDown.current = () => {
  // 为什么在这里读取的就是更新后的值
  // 因为这里每次重新声明了一个函数，内部捕获到了最新的state
    if (timerNum > 0) {
      setTimerNum(timerNum - 1);
    } else {
      setTimerNum(maxTime);
      setBoolCountDown(false);
      setCountDownText("重新获取");
    }
  };

  // const otherCountDown = () => {
  // 为什么在这里读取的就一直是初始值
  // 因为定时器是异步的。第一次执行effect时这里读取到timerNum是60，
  //   console.log(timerNum, "timerNum");
  //   setTimerNum((timerNum) => timerNum - 1);
  // };

  useEffect(() => {
    if (boolCountDown) {
      const timer = setInterval(() => {
        // otherCountDown();
        refCountDown.current();
      }, 1000);
      return () => clearInterval(timer);
    }
  }, [boolCountDown]);

  return (
    <div>
      <button type="button" onClick={handleClick}>
        {boolCountDown ? `${timerNum}s` : countDownText}
      </button>
    </div>
  );
  
// 分析需求：点击时：切换展示倒计时或文案
每次倒计时减1s后，判断倒计时是否是0。如果是0，重置点击布尔、当前时间。如果不是0，减1
```
1. [blissful-colden-5vmuw - CodeSandbox](https://codesandbox.io/s/blissful-colden-5vmuw)：用函数组件实现一个定时器。
# 总结
1. useMemo：保存**传入函数的返回值**，避免重新生成
	1. 用于组件。被React.memo的组件可避免*属性未改变*时重新渲染
		1. 如果属性传递的引用类型，子组件仍会更新。
			1. 使用useMemo保存该引用类型值：`const info = useMemo(() => ({ name, age }), [name, age]);`[^2] 
	2. 用于值。需要大量计算过程，或很少改变的值。
	3. 如果函数的返回值是另一个函数，则类似useCallback
2. useCallback：保存**传入函数**，避免重新生成
	1. 避免每次因为父组件更新而生成新的函数
		1. 向已memo的子组件传递回调
3. useCallback是useMemo的子集，因为函数也是值。当useMemo中回调的返回值是函数时，简洁写法是使用useCallback。
# 组件
## 定义
1. 导出组件前使用React.memo包裹组件【仅对比原始类型数据比较好用，引用类型】

## 调用
1. 使用useCallback包裹需要下传的回调
2. 使用useMemo包裹需要下传的非函数的值

[^1]: 被保存在react中，等待下次更新过程中调用
[^2]: 仅当目标值改变时再生成一个全新的引用值