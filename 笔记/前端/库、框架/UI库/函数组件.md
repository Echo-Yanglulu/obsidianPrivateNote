# 概述
是一个纯函数，（react只需从上到下执行它），接收参数（组件的属性），返回值（返回的内容将作为该组件的UI）

理解
	1. 如果不理解[[Function]]、[[纯函数]]、[[非纯函数]]、[[副作用]]，就无法理解react处理函数组件的方式。
		1. 我们创建的组件可能是纯函数，也会是非纯函数。关键在于要知道自己正在创建什么副作用。
## 使用条件
在**函数组件内**的**最顶层**[[作用域]]。
	1. 顶层能保证Hook每次渲染都按顺序被调用。在条件语句中会导致顺序改变，react无法正确关联内部state与对应的hook
# 机制


# useState
本质：将本地的状态封装在函数组件中。
形式与内容：const [state, setState] = useState(initialValue)
	1. state：保存状态的变量
	2. setState
		1. 内容：state的期望值
		2. 形式
			1. [[Function]]：去获取当前组件中维护的最新的状态值
			2. [[值]]：当前读取到的（可能是旧值）
	3. initialValue
		1. 内容：该state的初始值
		2. 形式
			1. [[Function]]：初始化时调用，设置返回值为初始值
			2. [[值]] 
## 原理
1. 从react中导入，但不是在这个包中实现的，而是在react-reconciler。
	1. 在try/catch中，使用了mountState（initialValue）方法
	2. 关键是mountState的实现 ![[Pasted image 20230601130853.png]] 
2. 多个调用，如何保证按顺序执行？
	1. 初始化时
		1. 每次调用：都会返回一个hook对象、生成一对state/setter映射。
		2. 每次渲染：都会按照初始化的序列遍历*由多个映射组成的数组*。
	2. 初始化state时，不能在条件语句中，因为每次执行都是按照初始化的顺序执行。存在条件语句则数组顺序可能不同。

# useEffect
## 原理
1. 会**捕获**props与state
	1. 所以在回调函数里，拿到的是初始的props与state。如果想拿到最新值，可使用useRef，但通常有其他更简单的实现方式。
2. 机制：实现状态同步，而不是生命周期。

形式：useEffect(() => {}, [])
	1. []：该副作用不使用[[react]]*数据流中的值*。因此只被调用一次。
	2. 
多个
	1. 把依赖一组state变化的副作用放在一起

特性
	1. 如果依赖列表中没有监听某个state，则effect中读取该state会存在【相当于useEffect不会把没有监听的state值传入：还是旧值】
## 常见问题
1. 你以为没有使用数据流中的值，但其实使用了。你要使用策略（主要是useReducer 和 useCallback）来移除这些effect依赖，而不是忽视。
## 应用
1. 如何使用它获取数据？

## 相关
[useEffect 完整指南 — Overreacted](https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/) 
# useRef
本质：保存一个会突变的ref对象，在组件的执行周期中始终存在。
作用：保存一个与页面渲染无关的数据。一般是DOM。
# useMemo

# useLayout

# useReducer
另一种useState。与它有什么区别？？？
	1. 提前定义好了state的修改逻辑
	2. 多个state存在依赖关系时，不覆盖？
# useCallback

# 案例
```js
import React, { useState, useEffect, useRef } from "react";

export default function CountDown() {
  const maxTime = 60;
  const [countDownText, setCountDownText] = useState("获取验证码");
  const [timerNum, setTimerNum] = useState(maxTime);
  const [boolCountDown, setBoolCountDown] = useState(false);
  const refCountDown = useRef(null);
  const handleClick = () => {
    if (!boolCountDown) {
      setBoolCountDown(true);
    }
  };

  refCountDown.current = () => {
  // 为什么在这里读取的就是更新后的值
  // 因为副作用是定时器，定时器执行过程中state是不断变化的，扎心放到ref中
    if (timerNum > 0) {
      setTimerNum(timerNum - 1);
    } else {
      setTimerNum(maxTime);
      setBoolCountDown(false);
      setCountDownText("重新获取");
    }
  };
  // 为什么在这里读取的就一直是最新值？

  // const otherCountDown = () => {
  // 为什么在这里读取的就一直是初始值
  // 因为定时器是异步的。第一次执行effect时这里读取到timerNum是60，
  //   console.log(timerNum, "timerNum");
  //   setTimerNum((timerNum) => timerNum - 1);
  // };

  useEffect(() => {
    if (boolCountDown) {
      const timer = setInterval(() => {
        // otherCountDown();
        refCountDown.current();
      }, 1000);
      return () => clearInterval(timer);
    }
  }, [boolCountDown]);

  return (
    <div>
      <button type="button" onClick={handleClick}>
        {boolCountDown ? `${timerNum}s` : countDownText}
      </button>
    </div>
  );
}
// 分析需求：
点击时：切换展示倒计时或文案
每次倒计时减1s后，判断倒计时是否是0。如果是0，重置点击布尔、当前时间。如果不是0，减1
```

1. [blissful-colden-5vmuw - CodeSandbox](https://codesandbox.io/s/blissful-colden-5vmuw)：用函数组件实现一个定时器。