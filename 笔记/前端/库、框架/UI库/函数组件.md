# 概述
是一个纯函数，（react只需从上到下执行），接收参数（组件的属性），返回值（返回的内容将作为该组件的UI）
## 使用条件
在**函数组件内**的**最顶层**[[作用域]]。
	1. 顶层能保证Hook每次渲染都按顺序被调用。在条件语句中会导致顺序改变，react无法正确关联内部state与对应的hook
# 机制


# useState
参数
	1. 内容：该state的初始值
	2. 形式
		1. [[Function]] 
		2. 

多个调用，如何保证按顺序执行？

# useEffect
多个[[副作用]] 
	1. 把依赖一组state变化的副作用放在一起

特性
	1. 如果依赖列表中没有监听某个state，则effect中读取该state会存在【相当于useEffect不会把没有监听的state值传入：还是旧值】
# useRef
保存一个与页面渲染无关的数据。一般是DOM。在组件存在时一直存在。
# useMemo

# useLayout

# useReducer
另一种useState。与它有什么区别？？？
# useCallback

# 案例
```js
import React, { useState, useEffect, useRef } from "react";

export default function CountDown() {
  const maxTime = 60;
  const [countDownText, setCountDownText] = useState("获取验证码");
  const [timerNum, setTimerNum] = useState(maxTime);
  const [boolCountDown, setBoolCountDown] = useState(false);
  const refCountDown = useRef(null);
  const handleClick = () => {
    if (!boolCountDown) {
      setBoolCountDown(true);
    }
  };

  refCountDown.current = () => {
  // 为什么在这里读取的就是更新后的值
    if (timerNum > 0) {
      setTimerNum(timerNum - 1);
    } else {
      setTimerNum(maxTime);
      setBoolCountDown(false);
      setCountDownText("重新获取");
    }
  };

  // const otherCountDown = () => {
  // 为什么在这里读取的就一直是初始值
  //   console.log(timerNum, "timerNum");
  //   setTimerNum((timerNum) => timerNum - 1);
  // };

  useEffect(() => {
    if (boolCountDown) {
      const timer = setInterval(() => {
        // otherCountDown();
        refCountDown.current();
      }, 1000);
      return () => clearInterval(timer);
    }
  }, [boolCountDown]);

  return (
    <div>
      <button type="button" onClick={handleClick}>
        {boolCountDown ? `${timerNum}s` : countDownText}
      </button>
    </div>
  );
}

```

1. [blissful-colden-5vmuw - CodeSandbox](https://codesandbox.io/s/blissful-colden-5vmuw)：用函数组件实现一个定时器。