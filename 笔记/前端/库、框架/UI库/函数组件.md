# 概述
期望是一个纯函数，（react只需从上到下执行它），接收相同参数（props、state 和 context），返回相同的JSX
目的：为了在函数组件中使用[[状态]]与[[副作用]]（函数组件曾被区别称为“无状态组件”）。
意义
	1. 发明hooks的动机：在无状态组件需要状态时，不需要完全重构为类，可直接使用状态管理、副作用
	2. 它如何改变了react
		1. 既然一个副作用有它自己的设置和清除阶段，就把它放在同一个hook中
		2. context的抽象也好，HOC与render props的抽象也好，都增加了组件的*嵌套地狱*。
			1. 形成了可读性很差的组件树，因为所有的抽象逻辑都用组件实现，实际用于展示的组件却很难追踪
			2. 将这些并非用于展示的组件（逻辑组件）使用副作用封装。就打平了组件树的结构
前提
	1. 如果不理解[[Function]]、[[纯函数]]、[[非纯函数]]、[[副作用]]，就无法理解react处理函数组件的方式。
		1. 我们创建的组件可能是纯函数，也会是非纯函数。关键在于要知道自己正在创建什么副作用。
## 使用条件
在**函数组件内**的**最顶层**[[作用域]]。
	1. 顶层能保证Hook每次渲染都按顺序被调用。在条件语句中会导致顺序改变，react无法正确关联内部state与对应的hook
# 原理
## 定义
接收两个属性：props, ref
1. props：【向内传递】
2. ref
	1. 聚焦文字输入框
	2. 滚动图片到视图
	3. 播放和暂停视频 
	4. 父组件级别得到*自定义组件*[^3]内的DOM元素
		1. 将该参数作为某个组件的ref属性值
		2. 使用react.forwardRef函数包裹，将其暴露给父组件
## 执行
1. 挂载【组件挂载到DOM结构中】
	1. 执行非渲染代码
		1. useState：*初始值*作为最新常量返回，生成*只属于此次渲染*的（state+props+eventHandler）
		2. useEffect
			1. 捕获所有依赖变量
			2. 添加需要被执行和清除的副作用[^1] 
	2. 执行渲染代码
		1. 执行return，读取此次执行时使用props, state, eventHandler所生成的**快照**，并依据该快照生成UI的快照。
	3. 渲染完毕
	4. 执行useEffect中添加的[[副作用]] 
		1. useEffect使用全新的props，state绑定副作用
2. 更新【组件更新】
	1. 执行非渲染代码
		1. useState：*setState传入值*作为最新常量返回，生成*只属于此次渲染*的（state+props+eventHandler）
		2. useEffect【如果**依赖没有更新**，则**不执行**】
	2. 执行渲染代码
	3. 渲染完毕
	4. 检查队列
		1. 如果有
			1. 执行渲染前添加的清除副作用【因为大多数effect的执行并不会阻塞DOM更新，所以先清除】
			2. 执行渲染前添加的副作用【如果被跳过，则不执行】
3. 卸载
	1. 清除副作用

每次state更新，都会重新生成组件UI、逻辑的快照。
根据某个state更新，决定是否更新副作用。
# useState：状态
本质：将本地的[[状态]]封装在函数[[组件]]中。
形式：const [state, setState] = useState(initialValue)
	1. state：保存*状态*的变量
		1. 每次渲染时都会调用。挂载时返回InitialValue，更新时返回最新set的值
	2. setState：保存*修改状态的函数*的变量
		1. [[Function]]：去获取当前组件中维护的最新的状态值（并不是此次渲染的值）
			1. setCount(count => count + 1)
			2. 读取react中维护的**最新值**，而不是此次渲染中的值。即使当前渲染的state并没有更新，是在定时器中修改的，也可读取。
			3. **state的更新依赖于旧值**【此时[[函数组件#useReducer|userReducer]]可能是更好的选择】
		2. [[值]]：当前读取到的（可能是旧值）
	3. initialValue：状态的初始值
		1. [[Function]]：初始化时调用，设置返回值为初始值
		2. [[值]] 
执行机制
	1. 每次渲染时，将初始值（挂载）或通过setState传入的值（更新）声明为当前组件内的**常量**。
> [!note] 原理
> 

1. 从react中导入，但不是在这个包中实现的，而是在react-reconciler。
	1. 在try/catch中，使用了mountState（initialValue）方法
	2. 关键是mountState的实现 ![[Pasted image 20230601130853.png]] 
2. 多个调用，如何保证按顺序执行？
	1. 初始化时
		1. 每次调用：都会返回一个hook对象、生成一对state/setter映射。
		2. 每次渲染：都会按照*初始化的序列*遍历*由多个映射组成的数组*。
	2. 初始化state时，不能在条件语句中，因为每次执行都是按照初始化的顺序执行。存在条件语句则数组顺序可能不同。
# useReducer：状态
另一种useState。与它有什么区别？？？
	1. 相似
		1. 修改状态
		2. 返回一个数组：state、修改该state的方法
	2. 不同
		1. 将state改变时相关逻辑封装在修改方法内
		2. 需求：相对useState，较为**复杂的状态**。
			1. 状态的新值依赖于旧值
			2. 状态依赖于另一个state
			3. 包含多个子值
			4. 能给触发了深更新的组件进行性能优化【？不懂】
形式
	1. 定义：`const [state, dispatch] = useReducer( reducer, initialValue )` 
	2. 调用：
# useDeferredValue：UI更新间隔
目的：延迟UI更新
	1. 组件展示依赖大量数据。组件新快照生成之前使用旧值【而不是*展示空白*】
规律
	1. 挂载时，会使用传入的值渲染
	2. 先使用旧值重渲染，在后台使用新值重渲染
	3. 会优先渲染其它组件，最后渲染使用useDeferredValue的组件
		1. 避免渲染较慢的UI阻塞其他UI渲染
用途
```js
function SearchPage() {
  const [query, setQuery] = useState('');
  // 传入state变量
  const deferredQuery = useDeferredValue(query);
  // ...
}
```
结果
	1. 新UI未生成前，一直是旧的，没有提示。
		1. 结果出来前降低亮度：`<div style={{opacity: query !== deferredQuery ? 0.5 : 1}}>` 
# useEffect：副作用
> [!功能] 

执行目的
	1. 组件挂载/依赖更新/没有依赖时，对组件内状态进行**捕获并排队**。组件==渲染后==，先**执行**上次渲染捕获的清除逻辑，再执行此次渲染捕获的添加逻辑。
	2. 组件卸载时，执行上次渲染捕获的清除逻辑
内部机制
	1. 没有依赖：每次渲染时
	2. 空数组
		1. 挂载时：保存添加与清除逻辑。渲染完成后执行添加逻辑，卸载时执行清除逻辑
		2. 更新时：不执行
		3. 卸载时：执行清除逻辑
	3. 存在依赖
		1. 挂载时：保存添加与清除逻辑。渲染完成后执行添加逻辑，卸载时执行清除逻辑
		2. 依赖未更新：不执行
		3. 依赖更新
			1. 所有状态和DOM更新后，上次渲染时定义的清除逻辑。
			2. 是此次渲染时捕获的添加逻辑
执行机制：捕获变量，副作用的添加逻辑在*此次DOM变更、浏览器渲染页面后*执行，副作用的清除逻辑在
	1. 依赖更新：*下次渲染后、副作用添加逻辑执行前*执行
	2. 组件卸载：组件卸载前执行
> [!note] 原理
> 
> 

1. **捕获**定义它的那次渲染中的props与state
	1. 【在副作用设置函数里，拿到的是初始的props与state。如果想拿到最新值】
		1. 添加到依赖队列【仅当副作用需要依赖该state时】
		2. 使用useRef。从外界获取最新state
		3. 在副作用的setState中传入函数。
	2. 清除副作用时保存的值会在下次渲染时被调用。
		1. 此次渲染时执行的清除逻辑中，保存的都是上次渲染的状态
	3. 监听值没有改变，所以该次更新没有执行该effect
形式：useEffect(() => {}, [])
	1. []：该副作用不使用[[react]]*数据流中的值*。只在组件*挂载时*调用一次。
	2. [a]：组件*挂载时、a改变*时【仅在某些状态改变时执行的副作用】
	3. return：
	4. useEffect(()=>{})：每次状态改变时【没有意义，跟直接写在外面相同】
特性
	1. 如果依赖列表中没有监听某个state，则不会重新捕获，导致每次调用副作用时使用的都是旧state。
		1. `setCount(count => count + 1)`。存在问题：如果有两个互相依赖的状态，则不能做到。
		2. 与该方法相似的是[[#useReducer]]可做到
> [!note] 常见问题
> 1. 你以为没有使用数据流中的值，但其实使用了。你要使用策略（主要是useReducer 和 useCallback）来移除这些effect依赖。

> [!note] 应用
> 

1.  仅当组件更新时执行副作用
```js
const Toggler = ({ toggle, onToggle }) => {
// 添加“已挂载”的标识
  const didMount = React.useRef(false);
// 在任意一个副作用中读取ref值，如果是false就取反，如果是true就执行副作用
  React.useEffect(() => {
    if (didMount.current) {
      console.log('I run only if toggle changes.');
    } else {
      didMount.current = true;
    }
  }, [toggle]);

  return (
    <div>
      <button type="button" onClick={onToggle}>
        Toggle
      </button>

      {toggle && <div>Hello React</div>}
    </div>
  );
};
```
2. 仅当依赖改变时执行一次副作用
```js
const Toggler = ({ toggle, onToggle }) => {
  // 添加已“执行一次”的标识
  const calledOnce = React.useRef(false);

  React.useEffect(() => {
    if (calledOnce.current) {
      return;
    }

    if (toggle === false) {
      console.log('I run only once if toggle is false.');

      calledOnce.current = true;
    }
  }, [toggle]);

  return (
    <div>
      <button type="button" onClick={onToggle}>
        Toggle
      </button>

      {toggle && <div>Hello React</div>}
    </div>
  );
};
```
> [!note] 相关
> [useEffect 完整指南 — Overreacted](https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/) 
> [你可能不需要 Effect – React](https://zh-hans.react.dev/learn/you-might-not-need-an-effect) 
## 不需要副作用
何时需要：该副作用与**组件展示**相关
	1. 组件展示时需要focus、发送请求
何时不需要
	1. 事件回调修改了state/父组件修改了props，利用该state/props修改执行一些操作
		1. 弹出提示
		2. 发送请求
			1. 刷新页面会导致发送请求、弹出提示
		3. 更新另一个state
			1. 每次更新都会导致一次不必要的重渲染。如果是链式更新state，会多很多次重渲染。
		4. 更新多个state：放在一个函数中
		5. 重置所有state：传入key
		6. props变化时重置部分state
	2. 只在应用挂载时执行的逻辑
		1. 在开发环境会执行两次，虽然在生产不会，但在所有组件使用相同的逻辑更容易移动、复用[^7] 

### 根据props/state更新state
1. 在渲染中直接计算
### props变化时重置state为初始值
#### 重置所有
将可能变化的props值作为组件调用时的key属性值即可。变化时react认为是不同的组件。
#### 重置部分
不要依赖props更新某个state。
问题写法：
```js
function List({ items }) {
  const [isReverse, setIsReverse] = useState(false);
  const [selection, setSelection] = useState(null);

  // 🔴 避免：当 prop 变化时，在 Effect 中调整 state
  useEffect(() => {
    setSelection(null);
  }, [items]);
  // ...
}
// 每次items改变，先用selection旧值渲染一遍，再更新DOM、执行effect，最后再渲染一遍
```
改良写法：
```js
function List({ items }) {
  const [isReverse, setIsReverse] = useState(false);
  const [selection, setSelection] = useState(null);

  // 在渲染期间调整 state，而不是使用effect
  const [prevItems, setPrevItems] = useState(items);
  if (items !== prevItems) {
    setPrevItems(items);
    setSelection(null);
  }
  // ...
}
```
### 修改state的操作会引起其他操作
某个state的改变会引起其他操作（提示），有多个回调中需要修改该state
	1. 将该state作为依赖，该操作作为副作用
		1. 每次页面刷新都会触发该操作！
	2. 应该提取共享的逻辑
```js
function ProductPage({ product, addToCart }) {
  // ✅ 非常好：事件特定的逻辑在事件处理函数中处理
  function buyProduct() {
    addToCart(product);
    showNotification(`已添加 ${product.name} 进购物车！`);
  }

  function handleBuyClick() {
    buyProduct();
  }

  function handleCheckoutClick() {
    buyProduct();
    navigateTo('/checkout');
  }
  // ...
}
```
### 事件引起的网络请求
事件引起的[[网络请求]]应该放在事件中，
```js
function Form() {
  const [firstName, setFirstName] = useState('');
  const [lastName, setLastName] = useState('');

  // ✅ 非常好：这个逻辑应该在组件显示时执行
  useEffect(() => {
    post('/analytics/event', { eventName: 'visit_form' });
  }, []);

  // 🔴 避免：在 Effect 中处理属于事件特定的逻辑
  const [jsonToSubmit, setJsonToSubmit] = useState(null);
  useEffect(() => {
    if (jsonToSubmit !== null) {
      post('/api/register', jsonToSubmit);
    }
  }, [jsonToSubmit]);

  function handleSubmit(e) {
    e.preventDefault();
    setJsonToSubmit({ firstName, lastName });
  }
  // ...
}
```
### 频繁的网络请求
**竞态条件**：如果用户输入的input变化较快，通过副作用多次发送的请求，响应顺序可能不总是符合预期，最终展示错误的结果。
```js
  useEffect(() => {
    // 🔴 避免：没有清除逻辑的获取数据
    fetchResults(query, page).then(json => {
      setResults(json);
    });
  }, [query, page]);
```
忽略上次的请求结果
```js
function SearchResults({ query }) {
  const [results, setResults] = useState([]);
  const [page, setPage] = useState(1);
  useEffect(() => {
    let ignore = false;
    fetchResults(query, page).then(json => {
    // 如果下次渲染发生了，则此时不进行操作
      if (!ignore) {
        setResults(json);
      }
    });
    return () => {
      ignore = true;
    };
  }, [query, page]);

  function handleNextPageClick() {
    setPage(page + 1);
  }
```
或者封装为一个Hook，方便维护
```js
  function useData(url) {
  const [data, setData] = useState(null);
  useEffect(() => {
    let ignore = false;
    fetch(url)
      .then(response => response.json())
      .then(json => {
        if (!ignore) {
          setData(json);
        }
      });
    return () => {
      ignore = true;
    };
  }, [url]);
  return data;
}
}
function SearchResults({ query }) {
  const [page, setPage] = useState(1);
  const params = new URLSearchParams({ query, page });
  const results = useData(`/api/search?${params}`);

  function handleNextPageClick() {
    setPage(page + 1);
  }
  // ...
}
```
当一次耗时的[[副作用]]还没结束，第二次渲染就开始了。可能导致**竞态条件** 
可利用return的下次渲染时执行、捕获上次变量的特性，避免上次的副作用生效
### 初始化逻辑
不要直接把只执行一次的逻辑这样定义，因为组件刷新可能会导致执行多次
```js
function App() {
  // 🔴 避免：把只需要执行一次的逻辑放在 Effect 中
  useEffect(() => {
    loadDataFromLocalStorage();
    checkAuthToken();
  }, []);
  // ...
}
```
外部添加一个flag
```js
let didInit = false;

function App() {
  useEffect(() => {
    if (!didInit) {
      didInit = true;
      // ✅ 只在每次应用加载时执行一次
      loadDataFromLocalStorage();
      checkAuthToken();
    }
  }, []);
  // ...
}
```
# useLayoutEffect：副作用
而我们的组件从 state 变化到渲染，大概可以分为如下几步
	1. 改变 state，触发更新 state 变量的方法
	2. React 根据组件返回的 vDOM 进行 diff 对比，得到新的 Virtual DOM
	3. 将新的 VDom 交给渲染线程处理，**绘制到浏览器上** 
	4. 用户看到新的内容
useEffect 
	1. 在第 3 步之后执行的，也就是在浏览器绘制之后才调用
	2. 异步执行的，所谓异步就是被 requestIdleCallback 封装，只在浏览器空闲时候才会执行，保证了不会阻塞浏览器的渲染过程。
useLayoutEffect
	1. 在第二步之后（diff 出新的 vDOM 之后），第三步之前执行，也就是渲染之前同步执行的，所以会等它执行完再渲染页面到浏览器上。
结论：
	1. 与useEffect的区别
		1. 在渲染前执行，而不是渲染后
		2. 同步的，会阻塞DOM渲染。
		3. 服务端渲染（[[SSR]]）时useLayoutEffect 无效，使用 useEffect
	2. 场景：操作 [[DOM]]/不想出现 **内容闪烁** 
# useContext：传递
功能：在函数组件中读取一个组件中的[[context]]。
	1. 在某个组件中修改全局用到的数据

# useMemo：缓存
传参：同[[函数组件#useEffect]]。
功能：当依赖改变时，重新计算并返回一个新值
> [!note] 应用
> 

## 避免无意义的重新计算
一个值的计算过程较复杂，参数没有更新时，不需要重新计算
	1. totoList已完成、未完成、全部的筛选
## 避免重渲染
1. 组件的渲染开销较大时
	1. 定义时使用react.memo包裹组件
	2. 调用时使用useMemo包裹引用类型的属性值[^4] 
原因：当一个组件更新时，即使子组件接收的props没有更新也会重新渲染。
问题：如果传递的属性是引用类型数据，从内容上看确实没变，但父组件重新执行就是声明了一个*新值*，所以子组件仍会更新
	方案：将传递的引用类型数据【函数或其他引用类型值】使用useMemo，保留引用值。
```js
import React, { memo, useState } from 'react';

// 子组件
const ChildComp = (props:{info:{name, age}}) => {
  console.log('ChildComp...',name,age);
  return (<div>ChildComp...</div>);

};

const MemoChildComp = memo(ChildComp);

// 父组件
const Parent = () => {
  const [count, setCount] = useState(0);
  const [name] = useState('jack');
  const [age] = useState(11);
  // 更新前：会一直重新渲染
  const info = { name, age };
  // 更新后：引用类型不会再导致重新渲染
  const info = useMemo(() => ({ name, age }), [name, age]);
  return (
    <div className="App">
      <div>hello world {count}</div>
      <button onClick={() => { setCount(count => count + 1); }}>点击增加</button>
      <MemoChildComp info={info}/>
    </div>
  );
};

export default Parent;

```

## 缓存另一个hook的依赖
```js
function Dropdown({ allItems, text }) {
  // 作为依赖，每次渲染都会重新生成，导致下方的visibleItems的缓存失去作用
  const searchOptions = { matchMode: 'whole-word', text };
  // 作为依赖的对象字面量，应使用useMemo创建
  const searchOptions = useMemo(() => {
    return { matchMode: 'whole-word', text };
  }, [text]);
  
  const visibleItems = useMemo(() => {
    return searchItems(allItems, searchOptions);
  }, [allItems, searchOptions]); // 🚩 Caution: Dependency on an object created in the component body
  // ...
  }
```

# useCallback：缓存
传参：同[[函数组件#useEffect]]。
功能：返回一个函数定义。当依赖改变时，返回一个新函数
	即使多次更新，也能拿到相同的函数
```js
import { useCallback } from 'react';

export default function ProductPage({ productId, referrer, theme }) {
  // 缓存函数声明
  const handleSubmit = useCallback((orderDetails) => {
    post('/product/' + productId + '/buy', {
      referrer,
      orderDetails,
    });
  }, [productId, referrer]);
  return ()
  }
```
## 避免重渲染
当子组件使用了react.memo且存在某个属性为函数时，使用useCallback（减少渲染次数）
	问题：父组件内重新渲染时，重新声明了一个不同的函数。所以**子组件认为props改变了**。
	方案：将需要下传的回调使用useCallback包裹【仅处理下传的函数】
## 使用旧值更新状态
```js
function TodoList() {
  const [todos, setTodos] = useState([]);
  // state的更新依赖于之前的state
  const handleAddTodo = useCallback((text) => {
    // 每次todos更新，都会保存下来
    const newTodo = { id: nextId++, text };
    setTodos([...todos, newTodo]);
  }, [todos]);
```
也可以通过更新函数，去使用上次的值
```js
function TodoList() {
  const [todos, setTodos] = useState([]);

  const handleAddTodo = useCallback((text) => {
    const newTodo = { id: nextId++, text };
    setTodos(todos => [...todos, newTodo]);
  }, []); // ✅ No need for the todos dependency
```
## 避免副作用重复执行/副作用的依赖是函数时
问题：如果函数声明放在外面，在副作用内调用该函数，可能导致多次调用
```js
function ChatRoom({ roomId }) {
  const [message, setMessage] = useState('');

  function createOptions() {
    return {
      serverUrl: 'https://localhost:1234',
      roomId: roomId
    };
  }
  // 创建一个新的房间连接
  useEffect(() => {
    const options = createOptions();
    const connection = createConnection();
    connection.connect();
    // ...
```
createOptions每次的返回值不同，所以每次渲染都必须获得最新的函数
方案
	1. 将createOptions添加到依赖列表：没有意义，因为每次更新都会创建，所以副作用每次都会执行
	2. 将createOptions缓存后，添加到依赖列表：可保证仅在函数更新时，副作用重新执行。
	3. 不使用函数依赖，将需要依赖state/props更新的函数声明放在副作用内部
```js
function ChatRoom({ roomId }) {
  const [message, setMessage] = useState('');

  useEffect(() => {
    function createOptions() { // ✅ No need for useCallback or function dependencies!
      return {
        serverUrl: 'https://localhost:1234',
        roomId: roomId
      };
    }

    const options = createOptions();
    const connection = createConnection();
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]); // ✅ Only changes when roomId changes
  // ...
```
## 优化自定义Hook
将任意函数声明放在useCallback中
```js
function useRouter() {
  const { dispatch } = useContext(RouterStateContext);

  const navigate = useCallback((url) => {
    dispatch({ type: 'navigate', url });
  }, [dispatch]);

  const goBack = useCallback(() => {
    dispatch({ type: 'back' });
  }, [dispatch]);

  return {
    navigate,
    goBack,
  };
}
```
# useLayout

# useRef：保存不变值、传递
作用：保存一个页面渲染无关的数据，在组件的执行周期中始终不变。一般是DOM。
特性
	1. useRef在后续渲染中始终返回相同对象。可通过手动修改current属性存储数据
		1. 在多次渲染中拿到相同的值
	2. 改变ref不会触发更新
	3. 不要在**渲染期间**读写[^8]ref.current
	4. 每次渲染都会调用，但react始终保存初始值
		1. 不要使用函数调用去作为初始值，否则每次都会进行无意义的计算：`const playerRef = useRef(new VideoPlayer());` 
		2. 使用语句进行复杂的初始化：`const playerRef = useRef(null); if (playerRef.current === null) {playerRef.current = newVideoPlayer();}` 

> [!abstract] 应用
> 1. 使副作用仅在更新时执行
> 2. 定时器

# useImperativeHandle：传递
目的：父组件获取子函数组件暴露出来的**部分值**[^6]
	1. 通过父组件修改子组件数据
```js
import {  useRef,forwardRef,MutableRefObject,useImperativeHandle,Ref} from "react";

//只暴露value、getType、focus给父级
const InputEl = forwardRef((props: {}, ref: Ref<any>): JSX.Element=>{
    const inputEl: MutableRefObject<any> = useRef();

    useImperativeHandle(ref, ()=>({//第一个参数：暴露哪个ref；第二个参数：暴露什么
        value: (inputEl.current as HTMLInputElement).value,
        getType: () => (inputEl.current as HTMLInputElement).type,
        focus: () => (inputEl.current as HTMLInputElement).focus()
    }));

    return(
        <input ref={inputEl} type="text" {...props}/>
    )
})
//暴露整个input节点给父级
const InputEl = forwardRef((props: {}, ref: Ref<any>): JSX.Element=>{
    return(
        <input ref={ref} type="text" {...props}/>
    )
});

//父级
function InputWithFocusButton() {
    const inputEl: MutableRefObject<any> = useRef(null);

    function onButtonClick() {
        console.log('子组件input的对象:', inputEl.current);
        inputEl.current.focus();
    };
    return (
        <>
            <InputEl ref={inputEl} />
            <button onClick={onButtonClick}>Focus the input</button>
        </>
    );
}

```
对比：forwardRef结合ref拿到子函数组件中的**元素** 
# 自定义hook
```js
import React from 'react';
// 定义检测在线状态的hook
function useOffline() {
  const [isOffline, setIsOffline] = React.useState(false);

  function onOffline() {
    setIsOffline(true);
  }

  function onOnline() {
    setIsOffline(false);
  }

  React.useEffect(() => {
    window.addEventListener('offline', onOffline);
    window.addEventListener('online', onOnline);

    return () => {
      window.removeEventListener('offline', onOffline);
      window.removeEventListener('online', onOnline);
    };
  }, []);
// 返回在线状态
  return isOffline;
}
// 在整个应用层级调用
function App() {
  const isOffline = useOffline();

  if (isOffline) {
    return <div>Sorry, you are offline ...</div>;
  }

  return <div>You are online!</div>;
}

export default App;
```
# 案例
1. 倒计时
```js
import React, { useState, useEffect, useRef } from "react";

export default function CountDown() {
  const maxTime = 60;
  const [countDownText, setCountDownText] = useState("获取验证码");
  const [timerNum, setTimerNum] = useState(maxTime);
  const [boolCountDown, setBoolCountDown] = useState(false);
  const refCountDown = useRef(null);
  const handleClick = () => {
    if (!boolCountDown) {
      setBoolCountDown(true);
    }
  };

  refCountDown.current = () => {
  // 为什么在这里读取的就是更新后的值
  // 因为这里每次重新声明了一个函数，内部捕获到了最新的state
    if (timerNum > 0) {
      setTimerNum(timerNum - 1);
    } else {
      setTimerNum(maxTime);
      setBoolCountDown(false);
      setCountDownText("重新获取");
    }
  };

  // const otherCountDown = () => {
  // 为什么在这里读取的就一直是初始值
  // 因为定时器是异步的。第一次执行effect时这里读取到timerNum是60，
  //   console.log(timerNum, "timerNum");
  //   setTimerNum((timerNum) => timerNum - 1);
  // };

  useEffect(() => {
    if (boolCountDown) {
      const timer = setInterval(() => {
        // otherCountDown();
        refCountDown.current();
      }, 1000);
      return () => clearInterval(timer);
    }
  }, [boolCountDown]);

  return (
    <div>
      <button type="button" onClick={handleClick}>
        {boolCountDown ? `${timerNum}s` : countDownText}
      </button>
    </div>
  );
  
// 分析需求：点击时：切换展示倒计时或文案
每次倒计时减1s后，判断倒计时是否是0。如果是0，重置点击布尔、当前时间。如果不是0，减1
```
1. [blissful-colden-5vmuw - CodeSandbox](https://codesandbox.io/s/blissful-colden-5vmuw)：用函数组件实现一个定时器。
# 总结
1. useMemo：保存**传入函数的返回值**，避免重新生成
	1. 用于组件。被React.memo的组件可避免*属性未改变*时重新渲染
		1. 如果属性传递的引用类型，子组件仍会更新。
			1. 使用useMemo保存该引用类型值：`const info = useMemo(() => ({ name, age }), [name, age]);`[^2] 
	2. 用于值。需要大量计算过程，或很少改变的值。
	3. 如果函数的返回值是另一个函数，则类似useCallback
2. useCallback：保存**传入函数**，避免重新生成
	1. 避免每次因为父组件更新而生成新的函数
		1. 向已memo的子组件传递回调
3. useCallback是useMemo的子集，因为函数也是值。当useMemo中回调的返回值是函数时，简洁写法是使用useCallback。
## 可以实现的功能
1. 状态及其更新：useState/useReducer
2. [[副作用]]：同步或异步：useEffect/useLayoutEffect
3. 长期保存*不变的值*：useRef
4. 数据深层双向传递：React.createContext、useContext
	1. 深层修改高层数据，再辐射到其它深层组件
5. 向父组件暴露子组件[^5] ：forwardRef、useRef
	1. 整个元素：ref
	2. 部分数据：useImperativeHandle
6. 避免重渲染、重计算/保留引用类型的引用值
	1. React.memo
7. 迟延更新【组件的展示依赖于大量数据】
	1. React.Suspense：使用提示组件代替空白
		1. 使用Suspense组件的fallback定义提示组件
	2. useDeferredValue：
		1. 使用旧UI代替空白
		2. UI未更新的提示
# 实践
## 定义
1. 导出组件前使用React.memo包裹组件【仅对比原始类型数据比较好用，引用类型】

## 调用
1. 使用useCallback包裹需要下传的回调
2. 使用useMemo包裹需要下传的非函数的值

```dataviewjs

```


[^1]: 被保存在react中，等待下次更新过程中调用
[^2]: 仅当目标值改变时再生成一个全新的引用值
[^3]: 原生元素，如input，可直接通过绑定ref属性获得该元素
[^4]: 可从两个方面避免父组件更新的重渲染：基础值和引用值
[^5]: 前提：使用forwardRef为函数组件添加ref属性
[^6]: 使用ref，父组件可获得整个DOM元素，使用该API，可获得部分。
[^7]: 认证逻辑调用两次会导致token失效
[^8]: 渲染期间读：在return中读取ref.current。渲染期间写：在函数组件的顶层作用域中修改ref.current。