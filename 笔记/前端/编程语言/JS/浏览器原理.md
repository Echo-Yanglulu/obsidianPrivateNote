# [[浏览器]] 
从打开一个浏览器标签开始，发生了什么？
每打开一个tab页，就创建了一个独立的浏览器进程
# 渲染、绘制
资源：[[HTML]]代码、媒体文件（图片、视频）、[[js]],[[CSS]] 
1. 从输入URL到渲染发生了什么？
	1. [[DNS]]解析：浏览器将URL发送到DNS服务器，将域名解析为IP地址
	2. 建立[[TCP]]连接
	3. 发起[[HTTP]]请求
	4. 服务端响应资源
	5. 浏览器解析渲染页面
		1. 根据HTML代码生成DOM Tree。根据CSS代码生成CSSOM
			1. img的图片不会阻塞UI渲染。加载完毕后会撑开页面空间渲染
		2. 将两者结合形成Render Tree
		3. Layout(回流):根据渲染树，得到节点的*几何信息*（位置，大小）
		4. Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的*绝对像素* 
		5. display:将像素发送给GPU，展示在页面上。
	6. 连接结束

## DOM Tree
1. 产生过程
	1. 转换：浏览器从磁盘或网络读取 HTML 的原始字节，并根据文件的指定编码将它们转换成各个字符。
	2. 令牌化： 浏览器将字符串转换成 W 3 C 标准规定的各种令牌，例如，“”、“”，以及其他尖括号内
	3. 字符串。每个令牌都具有特殊含义和一组规则。
	4. 词法分析：令牌转换成定义其属性和规则的“对象”。
	5. DOM 构建：由于 HTML 标记定义不同标记之间的关系（一些标记包含在其他标记内），创建的对象链接在一个树数据结构内，此结构也会捕获标记中定义的父子关系：HTML 对象是 body 对象的父项，body 是 paragraph 对象的父项，依此类推。
2. 机制
	1. 浏览器每次修改HTML标签，都会重新产生一次DOM Tree
## CSSOM
1. 产生过程。同DOM，浏览器引擎需要将收到的 CSS 规则转化成浏览器能理解和处理的东西
	1. CSS 字节转换成字符，
	2. 接着转换成令牌和节点，
	3. 最后链接到一个称为“CSS 对象模型”(CSSOM) 的树结构内。
2. 特点
	1. 构建 CSSOM 树是一个十分消耗性能的过程。
## render tree
目的：用于产出节点的几何信息与绝对像素
生成过程
	1. 从DOM树的根节点开始遍历每个可见节点。
	2. 对于每个可见节点，找到CSSOM树中对应的规则，并应用它们。
	3. 根据每个可见节点以及其对应的样式，组合生成渲染树。
## 渲染/绘制
## 修改
###  回流/重排
定义：有些译为“重排”。
	1. 由于DOM操作改变了原有DOM**布局**，浏览器重新计算元素属性，重新布局
	2. 根据结合生成的render tree计算
常见的会导致回流的操作：
1. 页面首次加载
2. 浏览器窗口尺寸改变
3. 元素尺寸或位置改变
4. 元素内容变化
5. 元素字体大小变化
6. 增删 DOM 元素
7. 查询或调用某些特定属性方法
###  重绘
定义：简单修改**样式**，没有影响布局。
# 垃圾回收
webkit深入
# 引擎

操作符DOM是**实时更新**的。参考[[event-loop]] 

实时更新：立即更新页面展示。
对应操作：插入一个字符，删除页面上一节内容
结果：性能损失
原因：浏览器要重新计算上千个指标，之后才执行更新。
应对：实时更新的次数越少，执行代码所需时间越短。
	1. 使用Fragment创建DOM结构，一次性添加到list元素（只会触发一次实时更新）
```js
let list = document.getElementById("myList"),
  item;
// 执行20次实时更新
for (let i = 0; i < 10; i++) {
  item = document.createElement("li");
  list.appendChild(item); // 1次
  item.appendChild(document.createTextNode('Item ${i}'); // 1次
}
```