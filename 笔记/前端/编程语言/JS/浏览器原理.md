# [[浏览器]] 
从打开一个浏览器标签开始，发生了什么？
每打开一个tab页，就创建了一个独立的浏览器进程
## 相关
[浏览器渲染以及重绘(repaint)和回流(reflow) - 掘金](https://juejin.cn/post/6925253714361974797?searchId=202307150948235DF94EB015C5E0B62825#heading-0) 
# 渲染、绘制
资源：[[HTML]]代码、媒体文件（图片、视频）、[[js]],[[CSS]] 
1. 从输入URL到渲染发生了什么？
	1. [[DNS]]解析：浏览器将URL发送到DNS服务器，将域名解析为IP地址
	2. 建立[[TCP]]连接
	3. 发起[[HTTP]]请求
	4. 服务端响应资源
	5. 浏览器解析渲染页面
		1. 根据HTML代码生成DOM Tree。根据CSS代码生成CSSOM
			1. img的图片不会阻塞UI渲染。加载完毕后会撑开页面空间渲染
		2. 将两者结合形成Render Tree
		3. Layout(布局/回流):根据渲染树、视口大小，得到节点的*几何信息*（位置，大小）
		4. Painting(绘制/重绘):根据渲染树以及回流得到的几何信息，得到节点的*绝对像素* 
		5. display:将像素发送给GPU，展示在页面上。
	6. 连接结束
## DOM Tree
1. 产生过程
	1. 转换：浏览器从磁盘或网络读取 HTML 的原始字节，并根据文件的指定编码将它们转换成各个字符。
	2. 令牌化： 浏览器将字符串转换成 W 3 C 标准规定的各种令牌，例如，“”、“”，以及其他尖括号内
	3. 字符串。每个令牌都具有特殊含义和一组规则。
	4. 词法分析：令牌转换成定义其属性和规则的“对象”。
	5. DOM 构建：由于 HTML 标记定义不同标记之间的关系（一些标记包含在其他标记内），创建的对象链接在一个树数据结构内，此结构也会捕获标记中定义的父子关系：HTML 对象是 body 对象的父项，body 是 paragraph 对象的父项，依此类推。
2. 机制
	1. 浏览器每次修改HTML标签，都会重新产生一次DOM Tree
## CSSOM
1. 产生过程。同DOM，浏览器引擎需要将收到的 CSS 规则转化成浏览器能理解和处理的东西
	1. CSS 字节转换成字符，
	2. 接着转换成令牌和节点，
	3. 最后链接到一个称为“CSS 对象模型”(CSSOM) 的树结构内。
2. 特点
	1. 构建 CSSOM 树是一个十分消耗性能的过程。
## render tree
目的：用于产出节点的几何信息与绝对像素
生成过程
	1. 从DOM树的根节点开始遍历每个**可见节点**。
	2. 对于每个可见节点，找到CSSOM树中对应的规则，并应用它们。
	3. 根据每个可见节点以及其对应的样式，组合生成渲染树。
### 不可见节点
1.一些不会渲染输出的节点，比如script、meta、link等。
2.一些通过css进行隐藏的节点。比如display:none。
注意，利用visibility和opacity隐藏的节点是可见节点。
问题出现了,script、meta、link, img这一类都不可见的节点,例如我要引入css \<link href="1.css">\</link>我是不是永远没法去引入渲染到页面了?那么我们应该去了解[[浏览器线程]] 
## 渲染/绘制
## 修改
###  回流/重排
定义：有些译为“重排”。
	1. 由于DOM操作改变了原有DOM**布局**，浏览器重新计算元素属性，重新布局
	2. 根据结合生成的render tree计算节点几何信息的过程
常见的会导致回流的操作：
1. 浏览器窗口尺寸改变
2. 页面首次渲染
3. 可见元素的增删，或元素位置、尺寸[^1]、内容改变
###  重绘
定义
	1. 简单修改**样式**，没有影响布局。
	2. 根据render tree和节点几何信息重新计算节点像素的过程
原因
	1. 重排/回流。回流一定重绘
	2. 样式改变。visibility, color,background-color
### 如何避免回流和重绘
1. 使用mvvm框架
	1. react和vue,里面的虚拟dom,以及diff算法已经对回流和重绘做了更好的封装与优化
2. 读写分离
	1. 多次写入样式如果在相连的行，是一组，引发一次回流。
3. 样式集中改变
4. 元素批量修改
	1. 插入：使用createDocumentFragment
5. 容易发生位置变化的元素使用定位而不是margin
	1. 定位元素已经离脱离标准流，即使重绘也是这个层级的重绘，不影响标准流
# 垃圾回收
webkit深入
# 引擎

操作符DOM是**实时更新**的。参考[[event-loop]] 

实时更新：立即更新页面展示。
对应操作：插入一个字符，删除页面上一节内容
结果：性能损失
原因：浏览器要重新计算上千个指标，之后才执行更新。
应对：实时更新的次数越少，执行代码所需时间越短。
	1. 使用Fragment创建DOM结构，一次性添加到list元素（只会触发一次实时更新）
```js
let list = document.getElementById("myList"),
  item;
// 执行20次实时更新
for (let i = 0; i < 10; i++) {
  item = document.createElement("li");
  list.appendChild(item); // 1次
  item.appendChild(document.createTextNode('Item ${i}'); // 1次
}
```

[^1]: 外边距、内边框、边框大小、高度和宽度等