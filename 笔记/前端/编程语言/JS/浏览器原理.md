# [[浏览器]] 
从打开一个浏览器标签开始，发生了什么？
每打开一个tab页，就创建了一个独立的浏览器进程
## 相关
[浏览器渲染以及重绘(repaint)和回流(reflow) - 掘金](https://juejin.cn/post/6925253714361974797?searchId=202307150948235DF94EB015C5E0B62825#heading-0) 
# 渲染、绘制
资源：[[HTML]]代码、媒体文件（图片、视频）、[[js]],[[CSS]] 
1. 从输入URL到渲染发生了什么？
	1. 请求
		1. [[DNS]]解析：浏览器将 URL 发送到 DNS 服务器，将域名解析为 IP 地址
		2. 建立[[TCP]]连接
		3. 发起[[HTTP]]请求
		4. 服务端响应 HTML 源码。
		5. 浏览器解析 HTML 过程中，遇到静态资源（CSS/JS/图片/视频），继续发起网络请求
	2. 解析
		1. 背景：得到的 HTML,CSS,JS 都是字符串，
		2. 目的：把*字符串*转换为*结构化数据*。
		3. 过程
			1. 根据[[HTML]]生成 DOM Tree
			2. 根据 CSS 代码生成CSSOM 
				1. img 的图片不会阻塞 UI 渲染。加载完毕后会撑开页面空间渲染
			3. 将两者**结合**形成 Render Tree
		4. 优化
	3. 渲染
		1. Layout(布局/回流 reflow):根据渲染树、视口大小，**计算**得到节点的*几何信息*（位置，大小）
		2. Painting(绘制/重绘 repaint):根据渲染树以及回流得到的几何信息，**计算**得到节点的*绝对像素* 
		3. display:将像素发送给GPU，**渲染**在页面上。
	4. 连接结束![[Pasted image 20230803163537.png]]
## DOM Tree
1. 产生过程
	1. 转换：浏览器从磁盘或网络读取 HTML 的原始字节，并根据文件的指定编码将它们转换成各个字符。
	2. 令牌化： 浏览器将字符串转换成 W 3 C 标准规定的各种令牌，例如，“”、“”，以及其他尖括号内
	3. 字符串。每个令牌都具有特殊含义和一组规则。
	4. 词法分析：令牌转换成定义其属性和规则的“对象”。
	5. DOM 构建：由于 HTML 标记定义不同标记之间的关系（一些标记包含在其他标记内），创建的对象链接在一个树数据结构内，此结构也会捕获标记中定义的父子关系：HTML 对象是 body 对象的父项，body 是 paragraph 对象的父项，依此类推。
2. 机制
	1. 浏览器每次修改HTML标签，都会重新产生一次DOM Tree
## CSSOM
1. 产生过程。同DOM，浏览器引擎需要将收到的 CSS 规则转化成浏览器能理解和处理的东西
	1. CSS 字节转换成字符，
	2. 接着转换成令牌和节点，
	3. 最后链接到一个称为“CSS 对象模型”(CSSOM) 的树结构内。
2. 特点
	1. 构建 CSSOM 树是一个十分消耗性能的过程。
## render tree
目的：用于产出节点的几何信息与绝对像素
生成过程
	1. 从DOM树的根节点开始遍历每个**可见节点**。
	2. 对于每个可见节点，找到CSSOM树中对应的规则，并应用它们。
	3. 根据每个可见节点以及其对应的样式，组合生成渲染树。
### 不可见节点
1.一些不会渲染输出的节点，比如script、meta、link等。
2.一些通过css进行隐藏的节点。比如display:none。
注意，利用visibility和opacity隐藏的节点是可见节点。
问题出现了,script、meta、link, img这一类都不可见的节点,例如我要引入css \<link href="1.css">\</link>我是不是永远没法去引入渲染到页面了?那么我们应该去了解[[浏览器线程]] 
## 渲染/绘制
## 修改
### 布局的回流/重排
定义
	1. 由于 DOM 操作改变了原有 DOM**布局**，浏览器重新计算元素属性，并重新布局
	2. 根据结合生成的render tree计算节点*几何信息*的过程
常见的会导致回流的操作：
1. 浏览器*窗口尺寸*改变
3. *可见元素的增删*，或位置、尺寸[^1]、内容改变
2. 页面首次渲染
### 重绘
定义
	1. **样式**修改，没有影响布局。
	2. 根据render tree和节点几何信息重新计算节点像素的过程
原因
	1. 重排/回流。回流一定重绘
	2. 样式改变。visibility, color,background-color
### 如何避免回流和重绘
【框架，位移，读写，增删】
1. 使用[[mvvm]]框架
	1. [[React]]和[[vue]],里面的虚拟dom,以及diff算法已经对回流和重绘做了更好的封装与优化
2. 读写分离
	1. 多次写入样式如果在相连的行，则被视为一组，只引发一次回流。
	2. 修改之前先设置为 `display: none;` 脱离文档流。修改样式后再展示
3. 元素批量修改
	1. 插入：使用createDocumentFragment
4. 容易发生位置变化的元素使用定位而不是margin
	1. 定位元素已经离脱离标准流，即使重绘也是这个层级的重绘，不影响标准流
5. 使用 [[BFC]]特性，不影响外部元素的渲染。
6. 频繁触发的（resize, scroll）使用节流或防抖
7. 优化动画，使用 CSS3与[[requestAnimationFrame]]实现动画
# 垃圾回收
webkit深入
# 引擎

操作符DOM是**实时更新**的。参考[[event-loop]] 

实时更新：立即更新页面展示。
对应操作：插入一个字符，删除页面上一节内容
结果：性能损失
原因：浏览器要重新计算上千个指标，之后才执行更新。
应对：实时更新的次数越少，执行代码所需时间越短。
	1. 使用Fragment创建DOM结构，一次性添加到list元素（只会触发一次实时更新）
```js
let list = document.getElementById("myList"),
  item;
// 执行20次实时更新
for (let i = 0; i < 10; i++) {
  item = document.createElement("li");
  list.appendChild(item); // 1次
  item.appendChild(document.createTextNode('Item ${i}'); // 1次
}
```

[^1]: 外边距、内边框、边框大小、高度和宽度等