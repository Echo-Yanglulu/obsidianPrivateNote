# 概述
范围：现代浏览器通过XHR对象原生支持CORS
ajax请求
# XHR对象

## XHR level 2
### [[FormData]]类型
不需要手动序列化
不需要手动添加表示模拟表单提交的请求头contentType: xml/app-formurlencoded
### 超时
timeout
ontimeout
### overrideMimeType
重写XHR响应的MIME类型。
因为响应的XHR类型决定了XHR对象如何处理该响应，所以覆盖响应的MIME类型是很有用的。
## 进度事件
1. loadstart：收到响应的第一个字节
2. progress：接收响应期间
3. 结果
	1. load：**成功**接收完响应
	2. error：响应**出错**
	3. abort：调用abort()方法**中止** 
4. loadend：通信结束
# 跨源资源共享
背景：XHR的主要限制是跨源安全策略。但浏览器也需要进行合法跨源的能力
CORS：规定了浏览器与服务器如何实现跨源通信
基本思路：通过添加自定义头部让浏览器与服务器互相了解，以确认响应应该成功或失败
## 分类
### 简单请求
需要对查询字符串中的每个key与value都调用encodeURIComponent。
（GET或POST）：没有自定义头部，且请求体是text/plain。
		1. 会在发送时额外添加一个Origin头部，包含发送请求的页面的的源。让服务器确认是否为该源的资源提供响应
		2. 如果服务器没有Access-Control-Allow-Origin，或有源但不匹配，则不会响应。否则会响应
### 预检请求
使用自定义头部、非GET/POST的[[请求方法]]，不同请求体内容类型。
		1. 某个涉及以上某个高级选项时，会先发一次送预检请求[^1] 
		2. 预检请求响应
			1. allow origin
			2. allow headers
			3. allow method
			4. max age：预检请求的响应会被缓存
### 凭据请求
默认情况：跨源请求不提供[[凭据]]（cookie, http认证，和客户端[[SSL]]证书）。可通过设置withCredentials为true，以表明**请求会发送凭据**。
如果服务器允许带凭据的请求，可在响应中包含头部allow credentials : true.。
结果：如果凭据请求的响应中没有该头部，则浏览器不会把这个响应交给JS
# 替代性跨源技术
CORS出现之前，实现ajax通信比较麻烦：需要依赖能够执行跨源请求的DOM特性。
虽然CORS已经得到广泛支持，但这些技术仍然可用，因为**不需要修改服务器**。
## 图片探测
## JSONP
# Fetch API

1. 定义了请求、响应、及其连接过程：获取(fetch)，
2. 特点：有XHR对象的所有功能，但更容易使用，接口更现代化（接口更现代化是什么意思）。是JS**请求资源**的优秀工具
3. 场景
	1. 能在web工作线程等现代web工具中使用
	2. 服务线程：拦截，重定向，修改通过fetch()生成的请求接口。
4. 范围：全局作用域
	1. 主页面执行线程
	2. 工作线程
	3. 模块
5. 机制：调用这个方法，浏览器会向指定URL发送请求。
	1. 分派请求
		1. 接收目标资源的[[URL]]，返回一个[[Promise]] 
		2. URL的格式的解释与XHR对象一样。
	2. 读取响应
		1. 文本化内容: res.text()
	3. 处理状态码和请求失败
		1. status:状态码
		2. statusText：状态文本
		3. ok: 当前请求是2xx
		4. 3xx：重定向
			1. 默认行为：跟随重定向，并
	4. 自定义选项
		1. body：请求体的内容：Blob, Buffer Source, FormData, URLSearchParams, Readable Stream, String实例
		2. cache
			1. no-store：直接发送请求不检查缓存，且响应不缓存直接通过fetch()返回
			2. no-cache：发送条件式请求。会发送请求，如果响应已修改，则缓存最新值，然后fetch()返回缓存的值
		3. 
## 常见fetch请求模式
同XHR，fetch()可发送数据、接收数据。
发送请求体时必须带有一种[[HTTP]]方法
### 发送**JSON**字符串
```javascript
	
```
### 在请求体中发送**字符串**参数
请求体支持任意字符串
### 发送**文件** 
请求体支持FormData实现
使用FormData模拟表单，将文件添加到FormData对象中，作为body配置
### 加载[[Blob]]文件 
常见做法：明确地把图片文件加载到内存，再添加到HTML图片元素。此时可使用响应对象上的`.blob()`方法，返回一个期约（解决为一个Blob实例）。可以将这个实例*调用URL.createObjectUrl()生成可以添加给图片元素src属性的值*。
```javascript
const imageElement = document.querySelector('img');

fetch('my-image.png')
  .then((response) => response.blob())
  .then((blob) => {
    imageElement.src = URL.createObjectURL(blob);
  });
```
### 发送跨源请求
需要响应：响应要包含CORS头部，才能保证浏览器收到响应
不需要响应：发送no-cors请求。此时res.type为opaque

---

## Headers对象
1. 定义：是所有外发请求与所有入站响应的**容器**
	1. 每个外发的Request实例都包含一个空的Headers实例（可通过Request.prototype.headers访问）
	2. 同理，每个入站的Response实例也有（整个属性皆可写）
2. 相似
	1. 与[[Map]]相似。合理，因为HTTP头部本质上是序列化后的键/值对，它们的JS表示是中间接口。都有get, set, has, delete等实例方法
3. 特点
	1. 初始化时可使用键值对形式的对象，而Map不能。
4. 头部护卫
	1. 定义：可防止不允许的修改
	2. 不同的护卫设置会修改set, get ,delete的行为
		1. none
		2. request
		3. request-no-cors
		4. response
		5. immutable
	3. 违反头部护卫会报TypeError
## Request对象
定义：获取资源请求的接口
功能：提供请求的相关信息、使用请求体的不同方式
### 使用
#### 创建
`let r = new Request('http://foo.com');`
#### 克隆
#### 在fetch()中使用
## Response对象
定义：获取资源响应的接口
功能：提供了响应的相关信息、使用响应体的不同方式
### 使用
#### 创建
可快速创建一个有许多HTTP头部的对象
#### 读取响应状态信息
#### 克隆
## Request、Response及Body混入
两个对象都使用的fetch API的 body混入，以使两者可承担有效载荷

该混入为两个对象提供了只读的body属性、只读的bodyUsed布尔值、一组方法，用于从流中**读取**内容并**转换**为某种JS对象类型。

将request/response的主体作为流使用的原因
	1. 有效载荷的大小可能导致网络延迟
	2. 流API本身在处理有效载荷方面有优势

### body混入提供的方法
#### Body.text()
#### Body.json()
#### Body.formData()
#### Body.arrayBuffer()
#### Body.blob()
#### 一次性流
因为body混入是构建在ReadableStream之上，所以主体流只能使用一次。所以所有方法都只能调用一次。
#### 使用ReadableStream主体
# Beacon API
场景：分析工具需要在页面生命周期中尽量晚的时刻向服务器发送遥测或分析数据

在unolad中创建的任何异步请求都会被浏览器取消。所以异步XHR或fetch不适合这个任务。
	1. 可使用同步XHR发送，但会导致体验问题：需要等处理完回调才导航到下一个页面。
所以W3C引入了补充性的Beacon API在[[navigator]]中。
# Web Socket
功能：通过一个*长时连接*，实现与服务器*全双工、双向*的通信。
机制：
特点：必须使用支持该协议的专有服务器。
## API
## 发送与接收数据
## 其他事件

# 安全

# 小结
浏览器控制：是否把响应交给JS

[^1]: 一种服务器验证机制：使用OPTIONS方法，包含头部：Origin, Access-Control-Request-Method：请求希望使用的方法。Access-Control-Request-Headers：要使用的自定义头部列表，逗号连接