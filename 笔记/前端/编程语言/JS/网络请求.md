# 概述
范围：现代浏览器通过XHR对象原生支持CORS
[[AJAX]]请求
## 内容
探讨*浏览器请求数据*和资源的*常用方式* 
	1. 早期的 XMLHttpRequest 
	2. 现代的 Fetch API
	3. [[axios]]等[[网络请求库]]  
# XHR对象
## XMLHttpRequest对象
### 组成
1. xhr.open()：初始化一个请求
	1. [[HTTP Method]] 
	2. [[URL]] 
	3. 是否异步：默认是
	4. user
	5. pwd
2. xhr.readyState：当前连接的状态
	- 0：unset 尚未调用open方法【未初始化请求】
	- 1：opened open方法已调用【已初始化请求】
	- 2：headers_received 已收到头部
	- 3：loading 正在下载，resonseText已有部分内容
	- 4：done 下载完成
3. xhr.status：[[HTTP状态码]] 
	1. 要在readyState为4时请求才完成
### 使用
```js
	const xhr = new XMLHttpRequest()
	// 因为是网络请求，所以不能阻塞，需要异步进行，设置为true
	// 同步会导致阻塞
	xhr.open('GET', '/test/data.json',true)
	xhr.onreadystatechange = function () {
		if(xhr.readyState === 4){
			if(xhr.status === 200 ){
				alert(xhr.responseText)
			} else {
				console.log('其他情况')
			}
		}
	}
	// 因为是GET请求，不用发送数据
	xhr.send()
	// post请求
	xhr.send(JSON.parse({name: 'fjwie', pwd: 'jif'}))
```
## XHR level 2
### [[FormData]]类型
不需要
	1. 手动序列化
	2. 手动添加表示模拟表单提交的请求头contentType: xml/app-formurlencoded
### 超时
timeout
ontimeout
### overrideMimeType
重写XHR响应的MIME类型。
因为响应的XHR类型决定了XHR对象如何处理该响应，所以覆盖响应的MIME类型是很有用的。
## 进度事件
1. loadstart：收到响应的第一个字节
2. progress：接收响应期间
3. 结果
	1. load：**成功**接收完响应
	2. error：响应**出错**
	3. abort：调用abort()方法**中止** 
4. loadend：通信结束
# 跨源资源共享
主题：[[前端安全]] 
背景：XHR存在限制，主要是跨域安全策略，[[同源策略]]。但浏览器也需要进行合法跨源的能力
核心：服务端设置[[HTTP Header]] 
CORS：规定了浏览器与服务器如何实现跨源通信
基本思路：通过添加自定义头部让浏览器与服务器互相了解，以确认响应应该成功或失败
![[Pasted image 20230701140146.png]] 
## 分类
### 简单请求
需要对查询字符串中的每个key与value都调用encodeURIComponent。
（GET或POST）：没有自定义头部，且请求体是text/plain。
		1. 会在发送时额外添加一个Origin头部，包含发送请求的页面的的源。让服务器确认是否为该源的资源提供响应
		2. 如果服务器没有Access-Control-Allow-Origin，或有源但不匹配，则不会响应。否则会响应
### 预检请求
使用自定义头部、非GET/POST的[[请求方法]]，不同请求体内容类型。
		1. 某个涉及以上某个高级选项时，会先发一次送预检请求[^1] 
		2. 预检请求响应
			1. allow origin
			2. allow headers
			3. allow method
			4. max age：预检请求的响应会被缓存
### 凭据请求
默认情况：跨源请求不提供[[凭据]]（cookie, http认证，和客户端[[SSL]]证书）。可通过设置withCredentials为true，以表明**请求会发送凭据**。
如果服务器允许带凭据的请求，可在响应中包含头部allow credentials : true.。
结果：如果凭据请求的响应中没有该头部，则浏览器不会把这个响应交给JS
## 替代性跨源技术
CORS出现之前，实现ajax通信比较麻烦：需要依赖能够执行跨源请求的DOM特性。
虽然CORS已经得到广泛支持，但这些技术仍然可用，因为**不需要修改服务器**。
### 图片探测
### [[JSONP]] 
# Fetch API
1. 定义了请求、响应、及其连接过程：获取(fetch)，
2. 特点
	1. 有XHR对象的所有功能，但更容易使用，接口更现代化（接口更现代化是什么意思）。是JS**请求资源**的优秀工具
	2. 请求失败不会调用reject。网络故障、请求被阻止时才会
	3. 默认情况，fetch不会从服务端发送或接收cookies
		1. 要发送cookie进行论证必须设置credentials选项。
			1. 默认为same-origin
3. 兼容性：
4. 场景
	1. 能在web工作线程等*现代web工具*中使用
	2. 服务线程：拦截，重定向，修改通过fetch()生成的请求接口。
5. 范围：全局作用域
	1. 主页面执行线程
	2. 工作线程
	3. 模块
6. 机制：调用这个方法，浏览器会向指定URL发送请求。
	1. 分派请求
		1. 接收目标资源的[[URL]]，返回一个[[Promise]] 
		2. URL的格式的解释与XHR对象一样。
	2. 读取响应
		1. 文本化内容: res.text()
	3. 处理状态码和请求失败
		1. status:状态码
		2. statusText：状态文本
		3. ok: 当前请求是2xx
		4. 3xx：重定向
			1. 默认行为：跟随重定向，并
	4. 自定义选项
		1. body：请求体的内容：Blob, Buffer Source, FormData, URLSearchParams, Readable Stream, String实例
		2. cache
			1. no-store：直接发送请求不检查缓存，且响应不缓存直接通过fetch()返回
			2. no-cache：发送条件式请求。会发送请求，如果响应已修改，则缓存最新值，然后fetch()返回缓存的值
## 常见fetch请求模式
同XHR，fetch()可发送数据、接收数据。
发送请求体时必须带有一种[[HTTP]]方法
### 发送**JSON**字符串
```javascript
	
```
### 在请求体中发送**字符串**参数
请求体支持任意字符串
### 发送**文件** 
请求体支持FormData实现
使用FormData模拟表单，将文件添加到FormData对象中，作为body配置
### 加载[[Blob]]文件 
常见做法：明确地把图片文件加载到内存，再添加到HTML图片元素。此时可使用响应对象上的`.blob()`方法，返回一个期约（解决为一个Blob实例）。可以将这个实例*调用URL.createObjectUrl()生成可以添加给图片元素src属性的值*。
```javascript
const imageElement = document.querySelector('img');

fetch('my-image.png')
  .then((response) => response.blob())
  .then((blob) => {
    imageElement.src = URL.createObjectURL(blob);
  });
```
### 发送跨源请求
需响应：响应要包含CORS头部，才能保证浏览器收到响应
不需响应：发送no-cors请求。此时res.type为opaque

---
## Headers对象
1. 定义：是所有外发请求与所有入站响应的**容器**
	1. 每个外发的Request实例都包含一个空的Headers实例（可通过Request.prototype.headers访问）
	2. 同理，每个入站的Response实例也有（整个属性皆可写）
2. 相似
	1. 与[[Map]]相似。合理，因为HTTP头部本质上是序列化后的键/值对，它们的JS表示是中间接口。都有get, set, has, delete等实例方法
3. 特点
	1. 初始化时可使用键值对形式的对象，而Map不能。
4. 头部护卫
	1. 定义：可防止不允许的修改
	2. 不同的护卫设置会修改set, get ,delete的行为
		1. none
		2. request
		3. request-no-cors
		4. response
		5. immutable
	3. 违反头部护卫会报TypeError
## Request对象
定义：获取资源请求的接口
功能：提供请求的相关信息、使用请求体的不同方式
### 使用
#### 创建
`let r = new Request('http://foo.com');` 
#### 克隆
#### 在fetch()中使用
## Response对象
定义：获取资源响应的接口
功能：提供了响应的相关信息、使用响应体的不同方式
### 使用
#### 创建
可快速创建一个有许多HTTP头部的对象
#### 读取响应状态信息
#### 克隆
## Request、Response及Body混入
两个对象都使用的fetch API的 body混入，以使两者可承担有效载荷

该混入为两个对象提供了只读的body属性、只读的bodyUsed布尔值、一组方法，用于从流中**读取**内容并**转换**为某种JS对象类型。

将request/response的主体作为流使用的原因
	1. 有效载荷的大小可能导致网络延迟
	2. 流API本身在处理有效载荷方面有优势

### body混入提供的方法
#### Body.text()
#### Body.json()
#### Body.formData()
#### Body.arrayBuffer()
#### Body.blob()
#### 一次性流
因为body混入是构建在ReadableStream之上，所以主体流只能使用一次。所以所有方法都只能调用一次。
#### 使用ReadableStream主体
# Beacon API
场景：分析工具需要在页面生命周期中尽量晚的时刻向服务器发送遥测或分析数据

在unolad中创建的任何异步请求都会被浏览器取消。所以异步XHR或fetch不适合这个任务。
	1. 可使用同步XHR发送，但会导致体验问题：需要等处理完回调才导航到下一个页面。
所以W3C引入了补充性的Beacon API在[[navigator]]中。
# Web Socket
功能：通过一个*长时连接*，实现与服务器*全双工*的通信。
机制：发送一个HTTP请求以建立连接。当响应返回，连接根据HTTP头部的upgrade进行协议切换
特点：必须使用支持该协议的专有服务器。

关于专有协议
	1. 优点：客户端与服务器之间可发送少量数据，不会对HTTP造成任何负担。**使用更小的数据包**使WS适合带宽与延迟问题明显的移动应用。
	2. 缺点：定义协议的耗时大于定义JS API
## API
### 创建
传入一个提供连接的URL（不适用同源策略）
readyState：当前连接的状态
	- opening
	- open
	- closing
	- close
## 发送与接收数据
传入接收三种数据
	1. 字符串
	2. ArrayBuffer
	3. blob
```javascript
let socket = new WebSocket("ws://www.example.com/server.php");

let stringData = "Hello world!";
let arrayBufferData = Uint8Array.from(['f', 'o', 'o']);
let blobData = new Blob(['f', 'o', 'o']);

socket.send(stringData);
socket.send(arrayBufferData.buffer);
socket.send(blobData);
```
## 其他事件
在连接生命周期中的三个**事件**
1. open
2. error
3. close

添加监听时使用DOM Level 0的**事件处理程序**监听

只有close事件的event有额外信息
	1. wasClean
	2. code
	3. reason
# 安全
AJAX应用程序要考虑的安全问题很多，主要有
	1. AJAX可访问的URL，通过客户端或服务器也可访问。

如URL：/getuserinfo.php?id=23
	1. 该php文件必须知道该资源的访问者是否拥有访问权限，否则服务器大门敞开，泄漏用户信息

[[CSRF]]：

用于防护CSRF，其实无效的手段
	1. 使用POST替换GET（修改请求方法很容易）
	2. 使用源站URL（易伪造）
	3. 使用cookie做验证（易伪造）
# 小结
浏览器控制：是否把响应交给JS

[^1]: 一种服务器验证机制：使用OPTIONS方法，包含头部：Origin, Access-Control-Request-Method：请求希望使用的方法。Access-Control-Request-Headers：要使用的自定义头部列表，逗号连接