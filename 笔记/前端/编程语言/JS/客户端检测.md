# 概述
**跨平台的浏览器**即使版本相同，也会存在不同的问题。这些差异迫使开发者使用各种方法检测客户端。

客户端检测一直是web开发中饱受争议的话题。
	1. 普遍认为所有浏览器都应支持一组公共特性

关键：客户端检测是解决问题的“不得已而为之”的最后一步考量。
# 能力检测
定义：在JS[[宿主环境|运行时]]中使用一套检测逻辑，测试宿主环境是否支持某种特性（又称特性检测）。
特点：这种方式不关心特定浏览器的信息，只关心是否存在所需特性。
规范
	1. 先检测最**常用**的能力
		1. 先检测document.getElementById，再检测document.all
	2. 必须直接检测切实**需要**的能力
		1. 如果要根据IE获取DOM元素，不要间接通过检测document.all等方法是否存在判断，而是使用浏览器分析。
## 基本模式
```js
if (object.propertyInQuestion) {
  // 使用object.propertyInQuestion
}
// IE5之前的版本中没有document.getElementById()这个DOM方法，但可以通过document.all属性实现同样的功能。
function getElement(id) {
  if (document.getElementById) {
    return document.getElementById(id);
  } else if (document.all) {
    return document.all[id];
  } else {
    throw new Error("No way to retrieve element!");
  }
}
```
## 安全能力检测
不要只是检测某个特性是否存在，而是检测该特性的数据类型是否是期望类型。

推荐使用typeof进行安全能力检测
但某些宿主对象并不保证typeof返回合理的值，如IE8以下的浏览器中，typeof document.createElement返回'object'
## 浏览器分析
使用**能力检测**，而不是使用**用户代理检测**分析运行代码的浏览器的原因在于，用户代理字符串很容易伪造。
仿造能够欺骗*能力检测*的浏览器特性却很难。
### 检测特性
可按照能力将浏览器归类。
如果当前web应用需要使用特定的浏览器能力，应当在一开始进行所有检测，而非用到时再重复进行检测。
```js
// 检测浏览器是否支持Netscape式的插件
let hasNSPlugins = !!(navigator.plugins && navigator.plugins.length);

// 检测浏览器是否具有DOM Level 1能力
let hasDOM1 = !!(document.getElementById && document.createElement &&
         document.getElementsByTagName);
```
### 检测浏览器
可根据对浏览器特性的检测与已知特性的对比，确定用户使用的浏览器。
	1. 比*用户代码嗅探*的结果更准确
	2. 可能不支持未来版本的浏览器
```js
class BrowserDetector {
  constructor() {
    // 测试条件编译
    // IE6~10支持
    this.isIE_Gte6Lte10 = /*@cc_on!@*/false;

    // 测试documentMode
    // IE7~11支持
    this.isIE_Gte7Lte11 = !!document.documentMode;

    // 测试StyleMedia构造函数
    // Edge 20及以上版本支持
    this.isEdge_Gte20 = !!window.StyleMedia;

    // 测试Firefox专有扩展安装API
    // 所有版本的Firefox都支持
    this.isFirefox_Gte1 = typeof InstallTrigger !== 'undefined';

    // 测试chrome对象及其webstore属性
    // Opera的某些版本有window.chrome，但没有window.chrome.webstore
    // 所有版本的Chrome都支持
    this.isChrome_Gte1 = !!window.chrome && !!window.chrome.webstore;

    // Safari早期版本会给构造函数的标签符追加"Constructor"字样，如：
    // window.Element.toString(); // [object ElementConstructor]
    // Safari 3~9.1支持
    this.isSafari_Gte3Lte9_1 = /constructor/i.test(window.Element);

    // 推送通知API暴露在window对象上
    // 使用默认参数值以避免对undefined调用toString()
    // Safari 7.1及以上版本支持
    this.isSafari_Gte7_1 =
        (({pushNotification = {}} = {}) =>
          pushNotification.toString() == '[object SafariRemoteNotification]'
        )(window.safari);

    // 测试addons属性
    // Opera 20及以上版本支持
    this.isOpera_Gte20 = !!window.opr && !!window.opr.addons;
  }

  isIE() { return this.isIE_Gte6Lte10 || this.isIE_Gte7Lte11; }
  isEdge() { return this.isEdge_Gte20 && !this.isIE(); }
  isFirefox() { return this.isFirefox_Gte1; }
  isChrome() { return this.isChrome_Gte1; }
  isSafari() { return this.isSafari_Gte3Lte9_1 || this.isSafari_Gte7_1; }
  isOpera() { return this.isOpera_Gte20; }
}****
```
随着浏览器的变迁及发展，可以不断调整底层检测逻辑，但主要的API可以保持不变。
### 检测的局限
适合用于检测下一步该怎么做，不一定能够作为识别浏览器的标志。
```js
// 不要这样做！不够特殊
let isFirefox = !!(navigator.vendor && navigator.vendorSub);

// 不要这样做！假设太多
let isIE = !!(document.all && document.uniqueID);
```
这是假设IE将来的版本中还会继续存在这两个属性，而且其他浏览器也不会实现它们

不过这两个检测都使用双重否定操作符来产生布尔值（这样可以生成便于存储和访问的结果）
# 用户代理检测
通过浏览器的**用户代理字符串**确定使用的是什么浏览器
	1. 在每个HTTP请求的头部
	2. JS可通过navigator.userAgent访问。
	3. 服务器端：常见的做法是根据接收到的用户代理字符串确定浏览器并执行相应操作
	4. 客户端：用户代理检测被认为是不可靠的，只应该在没有其他选项时再考虑。
用户代理字符串最受争议的地方就是，在很长一段时间里，浏览器都通过在用户代理字符串包含错误或误导性信息来欺骗服务器
## 用户代理字符串的历史
### 早期浏览器
### Netscape Navigator 3和IE3
### Netscape Communicator 4和IE4~8
### Gecko
### WebKit
### Konqueror
### Chrome
使用Blink作为渲染引擎，使用V8作为JavaScript引擎
用户代理字符串包含所有WebKit的信息，另外又加上了Chrome及其版本的信息：
```js
Mozilla/5.0 (Platform; Encryption; OS-or-CPU; Language)
AppleWebKit/AppleWebKitVersion (KHTML, like Gecko)
Chrome/ChromeVersion Safari/SafariVersion
```
Chrome 7完整的用户代理字符串：
```js
Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/534.7
  (KHTML, like Gecko) Chrome/7.0.517.44 Safari/534.7
```
### Opera
Opera默认的用户代理字符串是所有现代浏览器中最符合逻辑的，因为它正确标识了自己和版本
### iOS与Android

## 浏览器分析
# 硬件、软件检测
