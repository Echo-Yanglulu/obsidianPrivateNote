# 概述
1. 为什么
	1. 提高页面加载速度。避免多余的网络请求
2. 是什么：*首次请求*某个资源时，保存在本地，避免二次请求资源未更新导致，浪费网络资源
	1. 缓存内容：[[静态资源]] 

当**强制缓存**不可用（本地对比Expires）时尝试**协商缓存**（请求对比ETag || Last-Modified），如果协商返回304就使用缓存，否则重新请求。
## 分类
强制缓存、协商缓存，是不是又可以称为本地缓存和服务端缓存？【错，概念被放大了。还有其他缓存策略】
1. 本地缓存
	1. 强制缓存
2. 服务端缓存
	1. 协商缓存
### 强制缓存(CCE)
客户端的缓存策略：由客户端缓存
1. Expires(老字段，已被Cache-Control代替)
2. Cache-Control【可直接控制客户端缓存和服务端缓存】
流程
	1. **初次请求**时，返回**资源、Cache-Control** 
		1. max-age=3153600【单位是秒】
		2. no-cache：禁用强制缓存，让服务端处理缓存
		3. no-store：禁用强制缓存和服务端缓存，每次请求都**回源**即可
		4. private：允许最终用户做缓存
		5. public：允许中间的路由/代理做缓存
	3. **二次请求**，如果本地检验**Cache-Control未过期**，使用该缓存，返回200（disk cache）

本地缓存与请求的URL有关，所以要更新本地缓存，只需更新资源的URL，让用户打开页面时，元素请求的链接是新的静态资源文件名。
1. 用什么修改静态资源的文件名？
	1. 版本号
		1. 每次都要全量更新
	2. hash
2. 如何修改html中对资源的引用链接？
	1. 禁用html缓存
机制
	1. 如果同时存在，浏览器以CC为主
### 协商缓存(LME)
**服务端的缓存策略**：由服务端缓存
1. 使用Last-Modified：时间，只精确到秒
2. 使用ETag：字符串
流程
	1. 初次请求，返回**资源、Last-Modified或Etag** 
	2. 二次请求，**请求头带着if-modified-since或if-none-match** 
		1. 资源未更新：返回304
		2. 资源已更新：返回200、资源、新Last-Modified或Etag
机制
	1. Etag优先级更高
服务器会告诉浏览器，请求的资源已经多久没有更改过。浏览器发现这段时间内请求过这个资源，就直接使用缓存资源。
### 综述
![[Pasted image 20230702212718.png]]

# 刷新
**刷新方式，对缓存的影响** 
	1. 正常进入：在地址栏输入[[URL]]、点击跳转链接【导航的网页】、前进后退。
		1. 强制缓存有效、协商缓存有效
	2. 手动刷新：F5，ctrl + r，浏览器的刷新功能，右键菜单刷新
		1. 强制缓存失效，协商缓存有效
	3. 强制刷新：ctrl + F5[^1] 
		1. 强制缓存失效，协商缓存失效

[^1]: 项目刚上线时，需要强制刷新【为什么连网易的工程师都这么讲？没有办法不通过强制刷新的方式读取最新上线的内容吗？】