# 概述
1. 为什么
	1. 提高页面加载速度。避免多余的网络请求
2. 是什么：*首次请求*某个资源时，保存在本地，避免二次请求时浪费网络资源
	1. 缓存内容：[[静态资源]] 


当**强制缓存**不可用（本地对比Expires）时尝试**协商缓存**（请求对比ETag || Last-Modified），如果协商返回304就使用缓存，否则重新请求。
## 分类
强制缓存、协商缓存，是不是又可以称为本地缓存和服务端缓存？【错，概念被放大了。还有其他缓存策略】
1. 本地缓存
	1. 强制缓存
2. 服务端缓存
	1. 协商缓存
### 强制缓存(CCE)
客户端的缓存策略：由客户端缓存
1. Expires(老字段，已被Cache-Control代替)
2. Cache-Control
流程
	1. **初次请求**时，返回**资源、Cache-Control** 
		1. max-age=3153600【单位是秒】
		2. no-cache：不使用强制缓存，让服务端处理
		3. no-store：不用强制缓存和服务端缓存，每次请求都**回源**即可
		4. private：只允许最终用户做缓存
		5. public：允许中间的路由/代理做缓存
	3. **二次请求**，如果本地检验**Cache-Control未过期**，使用该缓存，返回200（disk cache）

本地缓存与请求的URL有关，所以要更新本地缓存，只需更新资源的URL，让用户打开页面时，元素请求的链接是新的静态资源文件名。
1. 用什么修改静态资源的文件名？
	1. 版本号
		1. 每次都要全量更新
	2. hash
2. 如何修改html中对资源的引用链接？
	1. 禁用html缓存
机制
	1. 如果同时存在，浏览器以CC为主
### 协商缓存(LME)
**服务端的缓存策略**：由服务端缓存
1. 使用Last-Modified
2. 使用ETag
流程
	1. 由服务端判断，是否需要
		1. 客户端与服务端现在存的资源一样，提示304
		2. 不一样，返回最新资源，提示200、
	2. 初次请求，返回**资源、Last-Modified或Etag** 
	3. 二次请求，**请求头带着if-modified-since或if-none-match** 
		1. 资源未更新：返回304
		2. 资源已更新：返回200、资源、新Last-Modified或Etag
服务器会告诉浏览器，请求的资源已经多久没有更改过。浏览器发现这段时间内请求过这个资源，就直接使用缓存资源。
# 刷新
不同的刷新操作方式，对缓存的影响