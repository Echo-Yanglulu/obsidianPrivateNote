# 概述
## 是何
1. [[模块化编程]]：将程序分解为*功能离散的chunk组块*，称为**模块**，
	1. 体积：每个模块的体积都小于程序体积，便于验证，调试，测试。
	2. 组织良好的模块提供了良好抽象与封装的模块

## 表现形式
[[webpack]]中：每个文件都是模块
## 为何
1. 项目代码量很大
2. 大量使用[[库、框架]]。
## 如何
将代码拆分为很多模块，通过某种方式（[[模块化]]）将这些部分（模块）组合。

浏览器原生不支持模块行为，但这种行为被迫切需要。ES也不支持，因此想使用[[模块模式]]的库必须基于JS语法与词法特性“伪造”出类似模块的行为。

由于JS是**异步加载**的[[解释型语言]]，所以各种模块实现也有不同形态。这些形态虽然有不同的结果，但都实现了经典的[[模块模式]]。

文件与脚本中的JS代码如何使用其他文件和脚本中定义的JS函数和类？
与[[模块化]]有什么关系？
定义
	1. Node模块是==包含JS代码的文件==，可输出值供其他文件使用。
		1. 那JAVA模块就是包含JAVA代码的文件？
	2. 
## 分类
### 凑合的模块系统
函数作用域与IIFE，将**模块定义**（立即执行）封装在匿名闭包中。
将模块定义的返回值给一个变量，就为一个模块创建了命名空间。

一般为了暴露API，创建模块的IIFE返回一个对象。
### ES6之前的模块加载器
#### CommonJS
Node.js对CJS的实现
	1. 使用相对路径

主要用于在服务器端代码的模块化，也可用于浏览器环境中**定义模块依赖**。但其模块语法不能在浏览器中直接运行。
Node主要在服务器环境下使用，不用考虑网络延迟问题。

什么是“*模块定义*”，如何将字符串解析为模块，取决于**模块系统的实现**（与模块标识符一样）
	node.js中，模块标识符可能指向文件，也可能指向包含index.js文件的文件夹。

模块是单例。一个模块无论被require引用多少次，都*只加载一次*（代码只执行一次）。
	1. 第一次加载后会被缓存，后续加载从缓存中取。
	2. 如果已经加载过，再次引入只是暴露这个命名空间。

CMD中，模块加载是模块系统执行的同步操作，因此require()可进行动态加载。
#### 异步模块定义
#### 通用模块定义
#### 模块加载器的没落
### ES6模块
1. 模块标签及定义
2. 模块加载
3. 模块行为
4. 模块导出
5. 模块导入
6. 模块转移导出
7. 工作者模块
8. 向后兼容
# node模块
## 内置模块
定义：Node自带的库
## 第三方模块
三方开发者提供的[[库]]