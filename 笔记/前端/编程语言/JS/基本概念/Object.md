# 概述
在ES6之后，==使用[[Map]]类，通常比使用普通对象更好==。
定义
	1. 一种**复合值**（汇聚多个值），允许按名字读写这些汇聚的值
	2. ECMA-262：一组属性的**无序集合** 
	3. 通常说：把字符串映射为值
范围
	1. 任何不是[[String]],[[Number]], Boolean, null, undefined, [[Symbol]], [[BigInt]]的值**都是对象**。前三者不是对象，行为也类似不可修改的对象
特性
	1. **动态**：可随时增删属性
		1. 可模拟静态类型语言中的**静态对象**和结构体
	2. **可修改**：按引用操作，而不是按值操作（操作保存同一对象引用的变量，改动是同时可见）
	3. **关联数组**：可看作以字符串作为索引的数组
## 分类
[[可迭代对象]] 
[[类数组对象]] 
## 单个创建
用于创建、初始化一个新对象（创建和初始化有什么区别？创建只是有这个变量LHS，初始化是有值RHS？）
实践
	1. 字面量：想创建多个，使用[[Object.prototype]]对象作为原型的对象
	2. 构造函数：[[class]] 
	3. create：定义了很多属性、方法的对象
### 字面量
组成：大括号包围，逗号连接属性，冒号连接属性名与属性值。
特性
	1. 最后一个**逗号**合法（合乎语法）
	2. 本质是一个**表达式**：每次求值都会创建一个==唯一==的对象
		1. 在循环中使用字面量创建，会得到多个完全不同的对象。
### new [[构造函数]] 
组成：后跟一个函数调用（被这样调用的函数特称为[[构造函数]]）
特性
	1. 如果传入一个保存对象的变量，则返回该变量。【返回对象与传入对象的引用值相同】
### Object.create()
传参：原型对象，新对象
指定[[原型对象]]地创建新对象是一种很强大的特性
	1. 防止对象被修改（读取继承属性，写入自有属性）
	2. 传入Null创建一个没有原型的对象，不能使用+操作符
	3. 如果不传呢？报TypeError：必须是对象或null
## 多个创建：JS继承
> [!note] 批量创建
> 问题：创建具有同样接口的多个对象时，需要编写重复代码：[[JS继承]] 
### 工厂模式
用于抽象出创建特定对象的过程
```js
function createPerson(name, age, job) {
  let o = new Object();
  o.name = name;
  o.age = age;
  o.job = job;
  o.sayName = function() {
    console.log(this.name);
  };
  return o;
}

let person1 = createPerson("Nicholas", 29, "Software Engineer");
let person2 = createPerson("Greg", 27, "Doctor");
```
### [[构造函数]]模式
自定义构造函数，以函数的形式为自己的对象类型定义属性和方法。通过new的方式调用
```js
function Person(name, age, job){
  this.name = name;
  this.age = age;
  this.job = job;
  this.sayName = function() {
    console.log(this.name);
  };
}

let person1 = new Person("Nicholas", 29, "Software Engineer");
let person2 = new Person("Greg", 27, "Doctor");

person1.sayName();  // Nicholas
person2.sayName();  // Greg
```
与工厂模式比较
	1. 相同
		1. 都使用了函数
	2. 不同
		1. 没有显式创建对象
		2. 属性与方法赋值给了this
		3. 没有return
new操作符机制
	1. 在内存中*创建*一个新对象
	2. 将新对象的\[\[prototype]] *特性赋值*为该**构造函数的prototype属性** 
	3. 构造函数内部的*this赋值*为该新对象。
	4. *执行*构造函数，添加属性与方法
	5. 如果构造函数主动*返回*非空对象，则使用该对象；否则返回新建对象
#### 问题
1. 构造函数也是函数
	1. 在调用一个函数而没有明确设置this值的情况下（即没有作为对象的方法调用，或者没有使用call()/apply()调用），this始终指向Global对象
2. 构造函数的问题
	1. 其定义的方法会在每个实例上都创建一遍。
		1. 可以把方法定义为全局变量，这样都可引用，但会扰乱全局作用域。
### 原型模式
基于原型的继承：每个函数都会创建一个prototype属性，它是一个对象，包含应该*由特定引用类型的实例共享*的属性和方法。
	1. 这个对象就是通过调用构造函数创建的对象的原型
使用原型对象的好处：在它上面定义的属性和方法可以被该引用类型的实例共享

利用new操作符的机制，直接修改构造函数的Prototype属性
```js
function Person() {}

Person.prototype.name = "Nicholas";
Person.prototype.age = 29;
Person.prototype.job = "Software Engineer";
Person.prototype.sayName = function() {
  console.log(this.name);
  };

let person1 = new Person();
person1.sayName(); // "Nicholas"

let person2 = new Person();
person2.sayName(); // "Nicholas"

console.log(person1.sayName == person2.sayName); // true
```
任何时候创建一个函数实例时，都会将该实例内部的prototype指针，赋值为构造函数的原型对象， [[原型对象]] 存在constructor属性，指回构造函数

形成闭环
	1. 实例与构造函数原型之间有直接联系，但实例与构造函数之间没有直接联系
#### 问题
1. 弱化了向构造函数传递*初始化参数*的能力，导致所有实例默认都取得相同的属性值
2. 如果共享属性是引用类型，则修改一个实例的共有属性，会导致多个实例使用该属性时被修改
### [[JS继承|继承]] 
### [[class|类]] 
## 扩展
把一个对象的属性复制到另一个对象
### 方式
1. Object.assign(目标对象，来源对象)：修改并返回目标对象（因为对象是可修改的，所以调用这个方法不需要返回值？）
	1. 原因：用来源对象定义了一组默认值，后续希望覆盖目标对象中的同名属性（webpack？）
	2. 功能：把来源的**自有且可枚举**属性复制到目标（按传入顺序覆盖同名）
	3. 机制：以属性的读写方式进行复制（如果有setter或getter，则复制期间不会复制这个函数，而是调用）
2. 扩展操作符：...
	1. o = {...defalults, ...0}
尝试
	1. 仅复制目标没有的属性
	2. 仅覆盖目标对象存在的属性
## 序列化
把对象转换为字符串的过程，并可恢复为对象。
### 方式
[[JSON]] 
## [[JS继承]] 
## 方法
如何在对象上添加重要的方法
所有对象都从Object.prototype继承属性(虽然中间还隔了一层当前类型对象的[[原型对象]]。)
1. 继承属性[[Object.prototype]] 
2. 静态属性Object.assign等
## [[class|类]]  
对象

# 属性
## 概述
大括号，属性之间逗号，属性名与属性值冒号
1. 形式与内容
	1. 属性名
		1. [[标识符]] | [[Number]]([[Array]])数组是一种[[类列表对象]] | [[String]] | [[Symbol]] 
		2. 可动态设置：\[表达式，求值结果会转换为字符串]
		3. 不可重名：重名自动覆盖
	2. 属性值
		1. 任意JS[[值]] | [[表达式]] 
		2. 设置、读取函数
		3. 简写
			1. 存储的变量名同属性名时
			2. 存储函数时
##   分类
1. 来源
	1. 自有属性：直接定义在对象上的属性
	2. 继承属性：从[[原型对象||原型]]，对象中继承的属性。这种“原型式继承”也是JS的主要特性
2. 枚举
	1. 可枚举属性
	2. 不可枚举属性
3. key类型
	1. 字符串属性
	2. 符号属性
4. 存在
	1. 静态属性
	2. 实例属性
5. 值
	1. 数据属性
	2. [[访问器属性]] 
##  特性
1. 组成
	1. writable：可修改值
	2. enumerable：可在for/in循环中返回
	3. configurable：属性可删除，特性可修改
2. 初始化
	1. 许多JS内置对象的属性：不可修改、删除、枚举
	2. 创建的对象：可修改、删除、枚举
## 读取
### 语法
操作符：.或\[]
左侧：一个求值为对象的[[表达式]] 
右侧：
	1. 点语法：命名属性的简单[[标识符]] 
	2. 中括号语法：[[表达式]] (**可求值或转换为[[String]]或[[Symbol]]的[[值]]**)【最终会转换为字符串？】

| 读写方式 | 优点 | 缺点 |
| --- | --- | --- |
| . | 可直观地看到属性名 | 只能在代码编写时确定属性名（静态读写） |
| [] | 可在代码编写/运行时确定属性名（动态读写） | 输入字段较多 |

对象使用for/in[[循环语句]]时，中括号语法可**批量读写属性**。
### 机制/过程
[[原型对象]] 
==原型链==：自有属性 ||[[ 原型对象]]上的继承属性 || 原型对象的原型对象的继承属性 ||  ... || null
	如何上溯？通过原型对象的__protot__属性
instanceof 是基于原型链实现
### 结果
1. 属性不存在：undefined（在自有属性、继承属性中没有）
2. 对象不存在：报错
## 设置
### 语法
将读取的语法放到赋值表达式左侧
obj.a
obj\[0]：如果其中不是[[String]]或[[Symbol]]，会转换为字符串。
	1. [[String]]或[[Number]]会保存为[[String]]；
	2. 其它会保存为[[标识符]]。
### 机制/过程
==向自有属性集写入==：新增/修改(不影响原型链)
	1. 可覆盖继承属性（如果继承属性为不可配置，那不可新增同名自有属性。那修改已有的自有属性呢？应该可以）
### 结果
1. 赋值成功
2. 赋值失败
	1. 自有或继承属性writtable为false，则不可修改
	2. 对象的extensible特性为false，则不可新增
3. 执行非赋值操作：访问到了继承的setter函数定义的访问器属性。则会调用而不是创建新属性。
## 删除
形式：delete[[操作符]] 属性访问[[表达式]]
效果：虽然操作数是属性访问表达式的值，但其实是将**属性本身**从自有对象中移除。而非将属性的值移除
返回值
	1. true：删除成功、属性不存在、操作符的不是属性访问表达式
	2. false：尝试删除configurable为false的属性，普通模式下为false，[[严格模式]]下报TypeError
## 测试
对象是一组属性的无序集合
1. 是否存在某个**自有或继承**属性：属性名（[[String]], [[Symbol]]） in 对象名
2. 是否存在某个**自有**属性：prototype.hasOwnProperty
3. 是否存在某个**自有且可枚举**属性：prototype.propertyIsEnumerable
	1. for/in时可通过该方法排除继承的可枚举属性。只遍历自有、可遍历属性

in可做到而属性访问判断做不到的：in可判断是否存在。访问断言只能判断是否为undefined
## 枚举
### 方式
1. 所有：Reflect.ownKeys()
2. 自有字符串：Object.getOwnPropertyNames()
3. 自有符号：Object.getOwnPropertySymbols()
4. 自有可枚举字符串：Object.keys()
	1. 枚举顺序不确定
5. 可枚举字符串：for/in
	1. 枚举顺序不确定
6. Object.assign()
7. 自有字符串
	1. Object.values()：属性值组成的数组
	2. Object.entries()：
### 顺序
Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()和Object.assign()的枚举顺序
1. 自有
	1. *升序*枚举数值。非负整数的字符串，按**数值**顺序从小到大
	2. *插入序*枚举字符串、符号
2. 上溯原型链
如果希望有序枚举对象属性，就使用数值字符串作为属性名。或使用符号依次添加。
## 计算属性名
属性名并不是可以在编译时写入代码的常量。
## 简写标识符
标识符作为属性值时，且**属性值的标识符与属性名的标识符相同**时：可省略值。
## 简写方法
函数作为属性值时：属性名直接作为函数名。

方法：存储在对象中的[[Function]]。
构造函数
# 原型
[[Object.prototype]] 
# JS中的对象实例
# 操作
1. [[深拷贝]]，浅拷贝


1. 对象为何需要序列化？
2. 对象上为何要创建方法？
3. 为何要测试、枚举属性？