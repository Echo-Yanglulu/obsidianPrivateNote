使用==IEEE 754格式==*表示*整数与浮点值。不同类型有不同的字面量格式

# 分类
1. 整数值

2. 浮点值
==组成==：必须包含小数点。后面必须至少1位数字，前面可能没有，但建议加上。

存储时==占用内存==是整数值的两倍。所以ES经常把值转换为整数。
	1. 小数点但后面没有数字
	2. 小数点后全为0

浮点值可用于==科学计数法==表示很大/小的数值
	整数值/浮点值 大写或小写的e 整数
默认情况小数点后包含大于等于6个0时会被转为科学计数法

==精确度==最高17位小数。
为何存在0.1+0.2  !== 0.3的问题？因为使用的是IEEE 754格式表示数值。所有使用这种格式的语言都会存在==舍入问题==。（先转换成二进制，再进行计算）
# 格式
十进制
[[八进制]]： 0o
十六进制：0x

八进制与十六进制格式在<u>数学操作</u>中被视为十进制
由于JS*保存*数值的方式，实际可能存在+0与-0。（什么方式？）
# 范围
由于内存限制，不保存所有数值。
ES*可表示*的最小数值：Number.MIN_VALUE。多数浏览器中是5e-324
ES可表示的最大数值：Number.MAX_VALUE。多数浏览器中是1.9796931348623157e-308

超出可表示范围，会自动*转换*为一个Infinity（不能用于计算）
可通过<u>isFinite()</u>*判断*是否超出范围。

# NaN
NaN：本来要返回数值的==操作失败==，而不是抛出错误。
	1.  0, -0, +0相除
	2. 分子非0，分母为0或正负0，返回Infinity或-Infinity
	3. 涉及NaN的操作（使用操作符？）始终返回NaN
	4. NaN不<u>相等</u>于任何值（包括自己），但<u>全等</u>于自己

为解决<u>相等</u>问题，可通过isNaN<u>判断</u>是否是NaN
	1. 隐式转换为数值。不能转为数值（'blue'）会返回true。
# 转换
Number()
parseInt()
parseFloat()
| Number() | parseInt() | parseFloat() |
| --- | --- | --- |
|  |  |  |
