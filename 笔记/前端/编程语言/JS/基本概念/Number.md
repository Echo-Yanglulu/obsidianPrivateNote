使用==IEEE 754规定的[[双精度浮点数]]数据类型==*表示*整数与浮点值。不同类型有不同的字面量格式

# 分类
1. 整数值
2. 浮点值
==组成==：必须包含小数点。后面必须至少1位数字，前面可能没有，但建议加上。
存储时==占用内存==是整数值的两倍。所以ES经常把值转换为整数。
	1. 小数点后没有数字
	2. 小数点后全为0
可通过==科学计数法==表示很大/小的数值
	整数值/浮点值 大写或小写的e 整数
默认情况小数点后包含**大于等于6个0**时会被转为科学计数法

==精确度==最高17位小数。
为何存在0.1+0.2  !== 0.3的问题？因为使用的是IEEE 754格式表示数值。所有使用这种格式的语言[^1]都会存在==舍入问题==。（先转换成二进制，再进行计算）
# 格式
十进制
[[八进制]]： 0o
十六进制：0x

八进制与十六进制格式在<u>数学操作</u>中被视为十进制
由于JS*保存*数值的方式，实际可能存在+0与-0。（什么方式？）
# 范围
由于内存限制，不保存所有数值。
ES*可表示*的最小数值：Number.MIN_VALUE。多数浏览器中是5e-324
ES可表示的最大数值：Number.MAX_VALUE。多数浏览器中是1.9796931348623157e-308

超出可表示范围，会自动*转换*为一个Infinity（不能用于计算）
可通过<u>isFinite()</u>*判断*是否超出范围。

分子非0，分母为0或正负0，返回Infinity或-Infinity
# NaN
NaN：本来要返回数值的==操作失败==，而不是抛出错误。
	1.  0, -0, +0相除
	2. 涉及NaN的操作（使用操作符？）始终返回NaN
	3. NaN不<u>相等</u>于任何值（包括自己），但<u>全等</u>于自己

为解决<u>相等</u>问题，可通过isNaN<u>判断</u>是否是NaN
	1. 隐式转换为数值。不能转为数值（'blue'）会返回true。
# 转换
Number可用于任何类型，后两个往往用于字符串类型（从字符串中得到整数值/浮点值）
![[转为数值类型.svg]]
parseInt：为避免转换带有其他整数格式数值的字符串时发生混淆，第二个参数接收==进制数==。结果为十进制。
parseFloat：暂时未看
| 规则 | Number() | parseInt() | parseFloat() |
| --- | --- | --- | --- |
| 含义 | 其他类型转Number型 |  |  |
| 布尔 | 0或1 |  |  |
| 数值 | 直接返回 |  |  |
| 字符串 | 包含数值字符？忽略前面存在的0，返回十进制  \n 包含浮点值？忽略前面的0返回相应浮点值 | 第一个字符不是（数值字符、+、 -），直接返回NaN | 同左 |
| null |  |  |  |
| undefined |  |  |  |
| 对象 | 调用valueOf方法，返回值按上述规则转换。如果转换得到NaN则重新调用toString，再按字符串规则 |  |  |

# 属性方法
## Number
1. 常量
	1. NaN
	2. MAX_SAFE_INTEGER 2\*\*53-1(可表示的最大数值)
	3. MAX_VALUE
	4. Infinity
2. 检测
	1. isNaN()
	2. isSafeInteger()
	3. isInteger()
	4. isFinite()
3. 转换
	1. parseInt()
	2. parseFloat()
4. 精度
	1. toFixed()
	2. toPrecision()
	3. toExponential()


## Math
trunc()：取整数部分
floor
ceil
round
abs
random
cbrt
sqrt平方根
pow
sign 正负
min
max多个参数中的最小值

[^1]: C, C++, JAVA，