# 基本思想
逻辑分块封装，相互独立。每个块自己决定暴露什么，引入什么。

1. 模块标识符
	1. 模块系统本质上是**键/值实体**，其中每个模块都有个**用于引用它**的标识符。
	2. 模块系统如果足够完善，不存在模块标识符冲突的问题，且系统中任何模块都可无歧义地引用其他模块
	3. 模块系统对模块标识符的实现，决定了将模块标识符解析为实际模块的过程[^1]。
		1. 除了文件路径，[[node]]还会搜索node_modules目录，用标识符匹配包含index.js文件的目录[^2]
2. 模块依赖
	1. 模块系统的核心是模块的**依赖管理**。
		1. 指定依赖的模块与周围的环境会达成一种**契约**。
		2. 本地模块向模块系统声明一组外部模块（依赖），这些外部模块对于当前模块的正常运行是必须的。
		3. 模块系统会检测这些外部模块，保证能够被加载、在本地模块运行时初始化所有依赖
		4. 每个模块与唯一的模块标识符关联。
3. 模块加载
	1. 当一个外部模块被指定为依赖时，本地模块期望在执行它时，依赖已准备好并已初始化。
	2. 浏览器中加载模块的步骤[^3]
		1. 浏览器收到模块代码→递归加载所有依赖→所有**依赖模块加载完毕**→**执行**入口模块。
4. 入口
	1. 相互依赖的模块必须指定一个模块作为入口，也是代码的==执行起点==[^4]。
	2. 入口模块可能依赖其他模块，其他模块可能再依赖其他模块，所以模块化JS应用程序的所有模块会构成依赖图
5. 异步依赖
6. 动态依赖
7. 静态分析
8. 循环依赖

[^1]: import \* as styled from './index.module.less'
[^2]: 没看懂
[^3]: 浏览器加载模块需要执行其中代码，但在执行之前需要确认该模块的所有依赖模块已加载完毕。
[^4]: JS是顺序执行，且单线程，所以必须有执行起点