# 基本[[思想]]
==逻辑分块封装，相互独立。每个块自己决定暴露什么，引入什么==。
![[模块系统.svg]]
1. 模块标识符
	1. 模块系统**本质**上是**键/值实体**，其中每个模块都有个**用于引用它**的标识符。
	2. 模块系统如果足够完善，不存在模块标识符冲突的问题，且系统中任何模块都可无歧义地引用其他模块
	3. 模块系统对*模块标识符*的实现，决定了将*模块标识符解析为实际模块*的过程[^1]。
		1. 除了文件路径，[[node]]还会搜索node_modules目录，用标识符匹配包含index.js文件的目录[^2]
2. 模块依赖
	1. 模块系统的**核心**是模块的**依赖管理**。
		1. 指定*依赖*的模块与周围的环境会达成一种**契约**。
		2. 本地模块向模块系统声明一组外部模块（依赖），这些外部模块对于当前模块的正常运行是必须的。
		3. 模块系统会检测这些外部模块，保证能够被加载、在本地模块运行时初始化所有依赖
		4. 每个模块与唯一的模块标识符关联。
3. 模块加载
	1. 当一个外部模块被指定为依赖时，本地模块期望在执行它时，依赖已准备好并已初始化。
	2. 浏览器中*加载*模块的步骤[^3]
		1. 浏览器收到模块代码→递归加载所有依赖→所有**依赖模块加载完毕**→**执行**入口模块。
	3. 加载方式：因为是==立即执行==，且模块的实现是包含将被立即执行的JS代码的文件。所以一种可能的加载方式是按照依赖图依次请求各个脚本。
	4. 模块加载是[[阻塞]]的。前面的操作完成后才能执行后面的操作。按顺序加载多个JS文件并不理想，且手动管理时较为麻烦
4. 入口
	1. 相互依赖的模块必须指定一个模块作为入口，也是代码的*执行起点*[^4]。
	2. 入口模块可能依赖其他模块，其他模块可能再依赖其他模块，所以模块化JS应用程序的所有模块会构成依赖图
5. 异步依赖
	1. 利用立即执行、可[[异步JS|异步]]的特点，让依赖的模块按需加载[^5]。当前模块则可通过使用script标签来动态加载，执行时会*异步加载*当前模块的依赖。这样不会生成依赖列表。
6. 动态依赖
	1. 有些模块系统要求在开始时列出所有依赖，有些模块系统允许在运行时*动态添加*依赖
		1. 动态添加的依赖：必须在模块执行前加载完毕。
	2. 动态添加依赖能实现更复杂的依赖关系，却增加了对模块静态分析的难度
7. 静态分析
	1. 浏览器收到JS代码，会使用分析工具在不执行代码的情况下检查*代码结构*推断行为[^6]。
	2. 静态分析友好的模块系统能让模块打包系统更容易地将模块整理为较少的文件。
8. 循环依赖
	1. 要建立一个没有循环依赖的JS应用程序几乎不可能。所以所有模块系统[^7]都支持循环依赖。
	2. 一个带有循环依赖的JS应用程序中，模块*加载顺序*可能出人意料。（只要*恰当封装*，使模块没有副作用，加载顺序就一般不影响应用程序的运行）



[^1]: import \* as styled from './index.module.less'
[^2]: 没看懂
[^3]: 浏览器加载模块需要执行其中代码，但在执行之前需要确认该模块的所有依赖模块已加载完毕。
[^4]: JS是顺序执行，且单线程，所以必须有执行起点
[^5]: 执行到这个模块时，自动调用里面的函数
[^6]: 动态依赖无疑会为静态分析带来困难。导致模块依赖加载不完全，执行时报错？
[^7]: CommonJS，AMD，ES6