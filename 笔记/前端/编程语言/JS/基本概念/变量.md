# 概述
消耗[[内存]]，存储[[值]]。
最基本的一个技术：使用一个**名字**/标识符来表示一个值。通过添加名字，提供了一种使用**值**的方式。
## 特点
1. 松散/动态类型
	1. 保存的[[数据类型]]在执行期间可改变。

# 创建/声明
## 方式
定义方式：原始值和引用值的定义方式很类似，都是创建一个变量，然后给它赋一个值
1. var
	1. 变量会被自动添加到最接近的上下文
	2. 声明会被拿到函数或全局作用域的顶部，位于作用域中所有代码之前
		1. 初始化不会被提升，即，提前访问一个被声明且初始化的var变量，得到undefined
	3. 未经*声明*就被*初始化*（赋值）了，那么它就会自动被添加到全局上下文
		1. 会导致很多问题
		2. 严格模式下会报错
2. function
3. let
4. const
5. [[解构赋值]] 
## 小结
function **声明提升**，跨块作用域（声明提示会跨过块作用域，是提升到当前作用域的顶部）
1. var 
	1. 声明：声明提升，可重复声明，允许不初始化
	2. [[作用域]]：全局作用域下声明会成为==全局对象==的属性[^1]（无法通过delete删除）
2. let
	1. 声明：可不初始化，不可重复声明
	2. 作用域：块级作用域，暂时性死区
3. const 
	1. 声明：必须初始化，不可重复声明
	2. 作用域：块级作用域，暂时性死区
	4. 常量

let i, sum 声明不赋值
let i = 0, j = 0, k=0 声明赋值
let x=2, y=x\*x。 使用前面声明的值

for循环中
var：外部的函数作用域
```js
function constF() {
    let funcs = []
    for (var i = 0; i < 10; i++) {
        funcs[i] = () => i
    }
    return funcs
}
let funcs = constF() // 返回后，变量i的值是10
console.log(funcs[5]()) // 10
由于使用了var关键字，变量i是在函数作用域中定义的，而不是在块作用域中定义的（i的作用域是整个函数体，而不是更小的循环体）。因此，当函数返回时，i的值将是10，因为所有10个函数都引用了同一个i变量。
```
let：块作用域
```js
function constF() {
    let funcs = []
    // 闭包是在同一个函数调用中定义的，所以可以共享i
    for (let i = 0; i < 10; i++) {
        funcs[i] = () => i
    }
    return funcs
}
由于使用了let关键字，变量i是在块作用域中定义的，而不是在函数作用域中定义的。因此，每次迭代时，都会创建一个新的变量i，它的值等于当前迭代的索引。这意味着，当任何一个函数被调用时，它们都将返回不同的值，从0到9。
```
相当于，使用var变量时，闭包使用的是外部函数[[作用域]]中的i，共享的。使用let时，闭包使用的是当前块作用域中的i。
**let和const是块级作用域的标志**：*每次循环都会定义一个与其他循环不同的独立作用域*，每个作用域中都有独立的i绑定。【形成了一个块级作用域，每次闭包查找i时找到的都是函数所在的独立的块级作用域中的i？】
【那i是什么时候被绑定的？在循环结束的时候？还是在funcs的元素被调用的时候？应该是循环结束的时候】

声明常量const
必须初始化：声明变量时必须赋值
修改TypeError
变量名常为全大写，下划线连接。

## 重复
同一作用域内，SyntaxError
## 场景
1. 函数形参
2. 变量交换
## 思路
1. 只对不会改变的使用const
2. 全部使用const。避免意外修改导致的bug
# 存储
值类型的数据：在栈[^2]中存储数据
引用类型数据
	1. 在栈中存储：内存地址
	2. 在堆内存中存储：数据
为何要分开存储两种类型？
	1. 一个JSON对象可能非常大。如果直接放在栈中可能太大，不容易管理【复制缓慢】
	2. 计算机所有语言都是这样管理，基于空间和CPU的计算耗时作出区分
## 相关
1. [[深比较]] 
# 操作
操作方式：大有不同。
	1. 增加属性
		1. 引用值
			1. 实际上操作的是对该对象的引用
			2. 可以随时添加、修改和删除其属性和方法
		2. 原始值：不能有属性，尽管尝试给原始值添加属性不会报错
```js
let name = "Nicholas";
name.age = 27;
console.log(name.age);  // undefined
```
小结：只有引用值可以动态添加后面可以使用的属性
## 访问
方式
	1. 保存原始类型的变量：按值访问
	2. 引用类型：按引用访问
从作用域链，向上查找
由于JS使用词法作用域，[[Function]]与其他变量一样，**作用域链的形成是在变量声明/函数定义时**（函数在执行时，内部的变量也是从定义的位置向上查找）
## 复制
1. 原始值：会被复制到新变量的位置
	1. 两个变量可以独立使用，互不干扰
2. 引用类型：复制的实际上是一个指针，指向存储在**堆**内存中的对象。
	1. 一个对象上面的变化会在另一个对象上反映出来
相关
1. [[深拷贝]] 
## 传参
方式
	1. 按值传参：值被复制到一个局部变量
		1. ECMAScript中函数的参数就是局部变量。修改这个变量不会改变外部变量
	2. 按引用传参：值在内存中的位置[^3]会被保存在一个局部变量
		1. 对本地变量的修改会反映到函数外部
[[Function|函数]]的参数都是**按值传递**的。
	1. 对本地变量的修改并还会反映到函数外部：将传入的变量赋值为一个新对象时，外部的变量并没有成为这个新对象
## 类型检测
1. 基本类型或三种类型：typeof[[操作符]]【8种】：三种类型：值、函数、引用
	1. undefined
	2. boolean
	3. string
	4. number
	5. symbol
	6. bigint
	7. function
	8. object
2. 引用类型：instanceof
3. 所有类型：toString
# 工作机制
变量是如何工作的？
1. [[编译器]] 
2. [[作用域]] 
3. [[JS引擎]] 
## 执行上下文
意义：变量或函数所在的执行上下文决定它
	1. 可访问的数据
	2. 行为
特点
	1. 每个执行上下文都有一个**关联**的变量对象 。这个执行上下文中定义的所有变量和函数都存在于这个对象上。
	2. 执行上下文在其所有代码都执行完毕后会被**销毁**，包括定义在它上面的所有变量和函数
		1. 全局上下文在应用程序退出前才会被销毁，比如关闭网页或退出浏览器
	3. 上下文中的代码在执行的时候，会创建变量对象的一个作用域链
### 执行上下文
一段代码执行时所在的环境。走到某个执行上下文时，开始执行其中代码。
	1. 分类
		1. 全局上下文：不同的[[宿主环境]]，表示全局上下文的对象可能不同
			1. [[浏览器]]：[[window]]对象
				1. 所有通过var定义的全局变量和函数都会成为window对象的属性和方法
				2. let和const的顶级声明不会定义在全局上下文中，但在作用域链解析上效果是一样的
		2. 局部上下文。每个函数调用都有自己的上下文
	2. 可形成层级
		1. 全局上下文是最外层的上下文
	3. 内部上下文可以通过作用域链访问外部上下文中的一切，但外部上下文无法访问内部上下文中的任何东西
### 变量对象
关联执行上下文，用于保存在一个执行上下文中定义的所有变量/函数
	1. 无法通过代码访问，后台处理数据会用到
### 作用域链
有顺序的多个变量对象。决定了各级执行上下文中的代码在访问变量和函数时的顺序。
	1. 顺序
		1. 最前端：*正在执行*的代码所在的执行上下文对应的变量对象
			1. 如果上下文是函数，则其活动/**激活对象**（activation object）用作变量对象。最初只有一个定义变量：arguments
		2. 下一个变量对象：来自包含上下文以此类推直至全局上下文
		3. 最后一个变量对象：全局上下文的变量对象
	2. 代码执行时的**标识符解析**是通过沿作用域链逐级搜索标识符名称完成的
	3. 作用域链增强：在作用域链前端临时添加一个上下文[^5] 
		1. try/catch语句的catch块：创建一个新的变量对象，包含要抛出的错误对象的声明
		2. with语句：向作用域链前端添加指定的对象
## 回收
[[垃圾回收机制]] 
# 使用
1. 使用未声明的变量
2. 在循环中使用
动态类型：可修改值的内容与类型
# 总结


[^1]: （window/globalThis）
[^2]: 计算机的一种内存结构，存储变量的地方。由JS引擎/[[虚拟机]]实现
[^3]: 值在内存中的位置，就是变量的指向。如果是按引用传递，改变的就是变量的指向。
[^5]: 在作用域链前端添加一个变量对象