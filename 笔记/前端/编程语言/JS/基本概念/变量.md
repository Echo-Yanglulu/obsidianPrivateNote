[[内存]]，存储值。
最基本的一个技术：使用一个**名字**/标识符来表示一个值。通过添加名字，提供了一种使用**值**的方式。
# 创建/声明
## 方式
1. var
2. function
3. let
4. const
5. [[解构赋值]] 
## 小结

var 声明提升，可不初始化，全局作用域下声明会成为==全局对象==的属性[^1]（无法通过delete删除）
function 声明提升，跨块作用域（声明提示会跨过块作用域，是提升到当前函数/全局作用域的顶部）
let 暂时性死区，可不初始化，不可重复声明
const 暂时性死区，声明时必须初始化，不可重复声明

let i, sum 声明不赋值
let i = 0, j = 0, k=0 声明赋值
let x=2, y=x\*x。 使用前面声明的值

for循环中
var：外部的函数作用域
```js
function constF() {
    let funcs = []
    for (var i = 0; i < 10; i++) {
        funcs[i] = () => i
    }
    return funcs
}
let funcs = constF() // 返回后，变量i的值是10
console.log(funcs[5]()) // 10
由于使用了var关键字，变量i是在函数作用域中定义的，而不是在块作用域中定义的（i的作用域是整个函数体，而不是更小的循环体）。因此，当函数返回时，i的值将是10，因为所有10个函数都引用了同一个i变量。
```
let：块作用域
```js
function constF() {
    let funcs = []
    // 闭包是在同一个函数调用中定义的，所以可以共享i
    for (let i = 0; i < 10; i++) {
        funcs[i] = () => i
    }
    return funcs
}
由于使用了let关键字，变量i是在块作用域中定义的，而不是在函数作用域中定义的。因此，每次迭代时，都会创建一个新的变量i，它的值等于当前迭代的索引。这意味着，当任何一个函数被调用时，它们都将返回不同的值，从0到9。
```
相当于，使用var变量时，闭包使用的是外部函数[[作用域]]中的i，共享的。使用let时，闭包使用的是当前块作用域中的i。
**let和const是块级作用域的标志**：*每次循环都会定义一个与其他循环不同的独立作用域*，每个作用域中都有独立的i绑定。【形成了一个块级作用域，每次闭包查找i时找到的都是当前作用域中的i？】
【那i是什么时候被绑定的？在循环结束的时候？还是在funcs的元素被调用的时候？应该是循环结束的时候】

声明常量const
必须初始化：声明变量时必须赋值
修改TypeError
变量名常为全大写，下划线连接。

## 重复
同一作用域内，SyntaxError
## 场景
1. 函数形参
2. 变量交换
## 思路
1. 只对不会改变的使用const
2. 全部使用const。避免意外修改导致的bug

# 机制
1. [[作用域]] 
# 使用
1. 使用未声明的变量。
2. 在循环中使用
[[动态类型]]：可修改值的内容与类型
# 工作机制
变量是如何工作的？
1. [[编译器]] 
2. [[作用域]] 
3. [[JS引擎]] 
# 总结
[^1]: （window/globalThis）