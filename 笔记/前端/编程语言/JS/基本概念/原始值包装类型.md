每当用到某个原始值的方法或属性时，后台都会创建一个相应原始包装类型的对象，从而暴露出操作原始值的各种方法

机制
	1. 读模式访问一个原始值时，后台都会执行以下3步[^1]
		1. 创建一个该类型的实例
		2. 调用实例上的特定方法
		3. 删除该实例
	2. 引用类型与原始值包装类型的主要区别在于**对象的生命周期** [^2]
		1. 自动创建的原始值包装对象则只存在于*访问它的那行代码执行期间* 
		2. new实例化引用类型后，得到的实例会在*离开作用域时*被销毁

```js
// 不能在运行时给原始值添加属性和方法
let s1 = "some text";
s1.color = "red";  // 运行时会临时创建一个String对象，而当第三行代码执行时，这个对象已经被销毁了
console.log(s1.color);  // undefined
// 实际上，第三行代码在这里创建了自己的String对象，但这个对象没有color属性
访问的是另一个对象，因为上一个已经被销毁
```




[^1]: 于是原始值有了对象的行为
[^2]: 所以不能在运行时给原始值添加属性和方法