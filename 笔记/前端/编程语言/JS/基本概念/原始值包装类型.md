每当用到某个原始值的方法或属性时，后台都会创建一个相应原始包装类型的对象，从而暴露出操作原始值的各种方法

机制
	1. 读模式访问一个原始值时，后台都会执行以下3步[^1]
		1. 创建一个该类型的实例
		2. 调用实例上的特定方法
		3. 删除该实例
特性
	1. 引用类型与原始值包装类型的主要区别在于对象的**生命周期** [^2] 
		1. 自动创建的原始值包装对象则只存在于*访问它的那行代码执行期间* 
		2. new实例化引用类型后，得到的实例会在*离开作用域时*被销毁
	2. 使用new调用原始值包装类型的*构造函数*，与调用同名的*转型函数*并不一样
		1. 字符串25，传入Number转型函数，返回值类型是'number'
		2. 字符串25，传入new Number构造函数，返回值类型是'object'
	3. 原始值包装类型的实例上调用typeof会返回"object"
	4. 原始值包装对象都会转换为布尔值true

```js
// 不能在运行时给原始值添加属性和方法
let s1 = "some text";
s1.color = "red";  // 运行时会临时创建一个String对象，而当第三行代码执行时，这个对象已经被销毁了
console.log(s1.color);  // undefined
// 实际上，第三行代码在这里创建了自己的String对象，但这个对象没有color属性
访问的是另一个对象，因为上一个已经被销毁
```

# Boolean
对应布尔值的引用类型，Boolean对象在ECMAScript中用得很少
Boolean的实例会重写valueOf()方法，返回一个原始值true或false。
toString()方法被调用时也会被覆盖，返回字符串"true"或"false"。

原始值和引用值（Boolean对象）的区别
	1. typeof操作符对原始值返回"boolean"，但对引用值返回"object"
	2. Boolean对象是Boolean类型的实例，在使用instaceof操作符时返回true，但对原始值则返回false
强烈建议永远不要使用Boolean对象


[^1]: 于是原始值有了对象的行为
[^2]: 所以不能在运行时给原始值添加属性和方法