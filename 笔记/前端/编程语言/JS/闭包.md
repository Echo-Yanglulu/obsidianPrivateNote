定义：
	1. “将**函数对象**与**作用域**组合起来**解析函数中变量**的**机制**”在计算机科学文献中被称为闭包。
		1. 严格讲，JS中所有[[Function]]都是闭包。因为多数调用与定义在同一[[作用域]]，所以闭包的存在无关紧要。
		2. 因为JS使用的是静态作用域，所以**函数作用域的上级作用域是函数定义所在的作用域**。
			1. 当函数定义与函数调用分别在不同的作用域时，可实现强大的编程特性
机制
	1. 封装：只有暴露的API能访问所在函数作用域中的变量
	2. 常驻内存：内部函数使用了外部函数的变量时，即使外部函数已经执行结束，被闭包函数引用的变量也会保存在内存中，直到闭包函数被销毁。

```js
function counter(){
    let n = 0;
    return {
        count: function(){return n++;},
        reset: function(){ n = 0}
    }
}
c = counter();
d = counter();
c.count() // 1
d.count() // 1
c.reset() // 0
// 两个方法都有权访问私有变量
// 每次调用都会创建一个新作用域。
```

作用
	1. 创建<u>私</u>有变量：将变量私有化，不被外部访问，可保护数据的安全性
		1. 函数被返回后，拥有嵌套函数内部变量的*专有访问权*。
	2. 保存状态、延长变量的<u>生</u>命周期：保存函数执行时的状态，可在函数执行完毕后继续使用该状态。类似于缓存
	3. 函数作为参数或返回<u>值</u>：可实现高级的函数操作（柯里化）
小结：函数内部嵌套定义的函数使用了外部函数作用域中的变量，并作为外部函数的返回值
特性
	1. 嵌套嵌套函数
	2. 函数内部可引用外部的变量，被引用的变量不会被垃圾回收机制回收
		1. 滥用。可能导致内存泄漏
优点
	1. 变量保存在内存中，实现数据共享
	2. 执行过程中所有变量都在函数内部
# 相关
[[JS垃圾回收机制]] 
# 应用
有什么需要时可用闭包？
	1. 在函数内创建一个对象，通过向外暴露API来限制该对象的操作。
		1. 防抖，节流
## [[react]]中函数组件
## 控制数据的读写规则
```js
function counter(n){
    return {
        get count(){return n++;},
        set count(m){
            if(m>n) n =m
            else throw new Error('count must be greater than last value')
        }
    }
}

let c = count(1000)
c.count // 1000
c.count // 1001
c.count = 2000
c.count // 2000
c.count = 2000 // Error
// 可让调用者指定私有变量的初始值


```


如果闭包要使用包含函数的[[this]]：使用箭头函数或bind，或将外部的this赋值给将继承的变量。