定义：
	1. “将**函数对象**与**作用域**组合起来**解析函数中变量**的**机制**”在计算机科学文献中被称为闭包。
严格讲，JS中所有[[Function]]都是闭包。因为多数调用与定义在同一[[作用域]]，所以闭包的存在无关紧要。

机制
	1. 只有闭包函数能访问所在函数作用域中的变量
	2. 内部函数使用了外部函数的变量时，即使外部函数已经执行结束，被闭包函数引用的变量也会保存在内存中，直到闭包函数被销毁。
关键是，当**函数的定义与调用不在同一个作用域**时【最常见的就是一个函数返回了内部定义的函数】
	1. 函数*内部状态*保存的一组变量是**定义时**所在[[作用域]]（词法作用域）中的变量
	2. 不论如何调用，闭包函数的内部所访问的始终是**定义时形成的作用域链**。

```js
function counter(){
    let n = 0;
    return {
        count: function(){return n++;},
        reset: function(){ n = 0}
    }
}
c = counter();
d = counter();
c.count() // 1
d.count() // 1
c.reset() // 0
// 两个方法都有权访问私有变量
// 每次调用都会创建一个新作用域。
```

作用
	1. 封装变量：将变量私有化，不被外部访问，可保护数据的安全性
		1. 函数被返回后，拥有嵌套函数内部变量的*专有访问权*。
	2. 保存状态、延长变量的生命周期：保存函数执行时的状态，可在函数执行完毕后继续使用该状态。类似于缓存
	3. 作为函数参数或返回值：可实现高级的函数操作（柯里化）

小结：函数内部嵌套定义的函数使用了外部函数作用域中的变量，并作为外部函数的返回值

# 有什么需要时可用闭包？
## [[react]]中函数组件
## 控制数据的读写规则
```js
function counter(n){
    return {
        get count(){return n++;},
        set count(m){
            if(m>n) n =m
            else throw new Error('count must be greater than last value')
        }
    }
}

let c = count(1000)
c.count // 1000
c.count // 1001
c.count = 2000
c.count // 2000
c.count = 2000 // Error
// 可让调用者指定私有变量的初始值


```
创建一个对象，并拥有对该对象的独有访问权

如果闭包要使用包含函数的[[this]]：使用箭头函数或bind，或将外部的this赋值给将继承的变量。