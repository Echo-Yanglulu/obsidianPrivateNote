为什么JS是单线程的？
	如果使用多线程的话，一个线程正在渲染DOM，另一个线程执行脚本时修改了DOM，就会发生冲突。所以JS不合适多线程，适合把渲染DOM和执行脚本放在一个线程中执行。

JS是单线程的，比较耗时的任务不能借助多线程完成，所以使用[[event-loop|事件循环]]实现异步：在主线程空闲时执行耗时任务。
浏览器与node中的API默认都是异步的
	1. 浏览器
		1. 事件
		2. 定时器
		3. 网络请求
	2. node
		1. 文件读写
		2. 网络请求
		3. 发送接收数据
# 原理
异步的基础原理：[[event-loop]] 
# 有序异步任务
解决方案
	1. 回调嵌套/地狱
	2. [[Promise]] 
	3. [[async]] 
		1. promise也是基于回调函数，它是用看起来同步的方式写异步。只是个语法糖
	4. [[生成器]] 
	5. iterable

使用async与promise的区别
	1. 都需要定义promise，不同的是Promise状态改变之后的处理逻辑换了一种书写方式
	2. 前者
		1. await相当于then。
			2. 后面是promise对象，会解包，拿出解决值。
			3. 后面是普通值，拿出该值
		2. 返回值会被包装为一个解决的promise对象， 
		3. 捕获异常需要使用try...catch... 

# 异步API
网易老师：宏任务是[[浏览器]]规定的，微任务是[[ES规范]]语法规定的。
MDN：同步脚本也是宏任务。
## 分类
### 宏任务
包含：script，定时器【setImmediate(node 独有)】，ajax，DOM事件，[[requestAnimationFrame]](浏览器独有)，UI render（浏览器独有），IO
### 微任务
定义：有一个专门的微任务队列。
包含：Promise.then()、async/await、MutationObserver、process.nextTick(node 独有)、Object.observe（已废弃）
## 机制
宏任务->微任务->UI渲染（宏任务）
# 相关问题
## [[event-loop]]与dom渲染
微任务的执行先于宏任务。

执行一段添加DOM的JS操作后（调用栈清空后），浏览器开始渲染DOM，然后再开始轮询任务队列
	1. 调用栈清空
	2. 微任务[^1]执行【存在专用的微任务队列】
	3. 尝试[[DOM]]渲染
	4. 触发event-loop，轮询回调队列【专用于对宏任务队列】
因为，**微任务在DOM渲染前执行，宏任务在DOM渲染后执行**，所以，微任务的执行先于宏任务。为何先微任务？
	1. 从[[event-loop]]出发，理解为何微任务先执行


[^1]: 此轮宏任务执行时添加的微任务