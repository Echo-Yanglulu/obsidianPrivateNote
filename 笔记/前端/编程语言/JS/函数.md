
# 概述
有名字，有参数的JS**代码块**。定义一次可反复调用。
## 组成
函数定义时需要注意的事项，更方便的语法。
### function关键字
### 函数名
标识符。新定义的**函数对象**会被赋值给这个标识符
### 形参
逗号连接的0或多个标识符
JS函数定义时不需要确定类型，调用时不会进行实参的个数、类型检查。如何显式测试实参，以避免不恰当的实参对函数进行调用？
#### 可选形参
实参个数<形参个数：多出的形参获得默认值：undefined
#### 剩余形参/收集参数
...：一种JS语法：可针对数组字面量或函数调用使用。
作用：展开任何可迭代对象的元素（数组，字符串）
形式：(...arg)
含义：调用时可传入任意数量实参
特点
	1. 必须是最后一个参数
	2. 函数体中：一定是数组。
	3. 不要给默认值：无用，且不合法
#### 默认值
有时函数定义时，形参需要默认值，以应对没有传参的情况（因为参数是对象时，undefined并没有属性、方法）
	1. 函数体内：a = a || \[]
	2. ES6中：定义形参时( a = expression )
		1. 形参默认值可基于前面的形参
		2. 默认值语法可用于任何函数定义方式
#### 类型
JS不会对入参做类型检查，但会做[[数据类型||类型]]转换。
#### 小结
大量同质化参数时，使用剩余参数。
### 函数体
0或多个JS[[语句]] 
#### arguments对象
作用：变长函数在ES6引入剩余形参之前的实现
特点
	1. [[类数组对象]] 
	2. **效率低，难优化**。尤其在非严格模式下。
	3. 严格模式下是保留字，不应作为形参或局部变量。
应使用...arg代替。
#### 调用上下文
即[[this]][[关键字]]的值
函数**通过一个[[普通对象]]被调用**/**在一个[[普通对象]]上被调用**时。
取决于函数调用方式
	1. 函数调用
		1. 非严格模式：[[全局对象]] 
		2. 严格模式：undefined
	2. 方法调用：调用对象
	3. 构造函数调用：new初始化的对象
	4. 间接调用：指定对象
	5. 隐式调用
#### 返回值

## 特性[^1]
从外到里：本身是对象，参数化，闭包，调用上下文。
1. **对象**：可进行保存、传递、添加属性
	1. 场景：函数需要一个静态变量，且每次调用时都可访问。（只有自己会用到的一个值。比如期望每次返回一个不同的值，可用属性保存返回过的值）
2. **参数化**：函数定义可包含一组**形参**标识符
	1. 定义时：剩余、解构、默认
	2. 调用时：收集
3. **闭包**：函数定义可访问*所在函数作用域*中的所有参数和变量。（虽然书目原句是这么说，全局作用域内的函数定义就不叫闭包了吗？）
	1. 基于闭包可实现重要、强大的编程技巧。
4. **调用上下文[[this]]** 
5. 作为**值**
	1. 赋值给另一个变量
	2. 保存为对象属性值
	3. 保存为数组元素
6. 作为[[命名空间]] 
> [!NOTE] Title
> 除了[[String]]，[[Number]]，bool，null, undefined, [[Symbol]], [[BigInt]]都是对象 --- [[普通对象]] 

作为值的用处
	1. sort方法根据传入函数的返回值决定排序方式。
	2. 将多个操作组合
## 机制/原理
调用栈

## 分类
### 目的
1. [[构造函数]]：通过new关键字调用，用于初始化一个新对象的函数
2. 生成器函数：function*
3. 异步函数：async function
4. 方法：通过一个对象调用(往往与对象内的操作有关)
5. 变长函数：可接收任意数量实参的函数
# 定义
## 函数声明
关键字，函数名标识符，形参标识符，函数体
关键在于
	1. **函数名变成了一个变量，保存的值就是函数本身**。
	2. 声明语句被提升到包含脚本、函数、代码块的顶部。（调用可以出现在定义之前）
## 函数表达式
使用函数名可方便在函数体内调用自身。
最佳实践是使用const把函数表达式赋值给常量：防止意外重写
## 箭头函数
是[[表达式]]，不是[[语句]]，所以不必使用函数名

更简洁的定义，是为了更方便地调用？
为什么要专门做个，上下文是根据定义环境决定的函数？（==写死this==，不能修改）
作用
	1. 简洁定义、传入需要函数参数的函数
	2. 继承定义时，外层嵌套函数的[[this]]。外层函数不用再保存调用上下文到另一个变量

返回：直接返回一个[[对象]]字面量时，需要用圆括号包裹。否则花括号标识会被认为是函数体的标识。
## Function构造函数
## 嵌套函数
函数定义可以嵌套在嵌套定义中。
最重要的是理解变量[[作用域]]规则：可访问函数定义的外层的参数和变量。
## 小结
|  | 函数声明 | 函数表达式 | 箭头函数 | 嵌套函数 |
| --- | --- | --- | --- | --- |
| 定义 | 4个都必须 | 函数名可选 | 函数名、function可选 |  |
| 场景 |  |  |  |  |
| 调用上下文 | 取决于被谁调用 |  | 从定义自己的环境继承[[this关键字]] |  |

声明与表达式的不同
	1. 函数声明有**声明提升** 
		1. 不要在[[语句]]中声明
	2. 箭头函数
		1. **调用上下文的值**：从函数定义的环境中继承
		2. 没有prototype属性
			1. 不能作为新类的[[构造函数]] 
			2. 不能使用[[Function.prototype]]的方法?

分类
	1. 匿名函数：无函数名的函数定义
	2. 具名函数：需要重用、内部递归
	3. [[构造函数]] 

方法：保存在对象内的函数
# 调用
构成函数体的JS代码在调用的时候执行。
函数是一种可产生副作用的对象？
只有函数能被调用，而且处处都是函数。
## 方式

### 函数
通过**调用表达式**，被作为函数或方法调用
用于执行函数体中的JS代码

形式：调用表达式：求值为函数对象的[[表达式]](逗号分隔的0或多个**参数表达式列表**)

区别：
1. 条件调用
2. 函数的**返回值**会变成函数调用表达式的值。
	1. 如果由于解释器到达末尾返回，返回值是undefined
	2. 如果由于解释器执行到return语句返回，返回值是return后面表达式的值（没有值就是undefined）
3. 函数的调用上下文
	1. 非严格模式下，是全局对象。**严格模式下是undefined**
		1. 可通过函数返回，确定代码是否在严格模式下执行。
### 方法
形式：函数作为对象的属性调用。如果函数表达式是个**属性访问表达式**，说明函数是作为方法调用，而非常规函数调用。

目的：为了操作对象

与作为函数调用的重要**区别**：调用上下文。方法和[[this]]是[[面向对象编程]]范式的核心
	1. 函数体可通过this关键字引用属性访问表达式中的对象。
	2. 任何作为方法调用的函数都会隐式收到一个参数：调用它的对象。

启发
	1. 以后再看到形如方法调用的形式，很可能是在操作之前的[[对象]]。清晰地表达出了**对象是方法进行操作的宾语**。
	2. this作为返回值：可进行链式调用，形成**方法调用链**。可对一个对象进行连续操作，如[[Promise]]。
		1. 写的API可以直接返回this，方便**对一个对象进行连续操作**。
### 构造函数
形式：一个函数/方法前加了关键字new，为构造函数调用

目的：初始化新对象。这个==新对象会被用作构造函数的调用上下文==，所以可以在构造函数中使用this引用该新对象。
	1. 即使构造函数作为方法调用，真正的调用上下文也不是该对象。如new o.m()的调用上下文是一个新初始化的对象而不是o。

与常规函数调用的**区别**
	1. 参数处理
	2. 调用上下文
	3. 返回值：通常不使用return[[关键字]]，而是：初始化一个新对象，在到达函数体末尾时隐式返回该对象。该对象就是构造函数调用表达式的值。如果使用的return关键字，则**显式返回的对象**会成为调用表达式的值（不是对象则使用新创建的对象返回）

### 间接调用
JS函数是对象，有方法。两个方法可用于间接调用函数，同时可指定调用时的this。

启发：
	1. 对象与函数解耦。
		1. 将任何函数作为任意对象的方法进行调用。
		2. 用于操作对象的方法进行封装
### 隐式调用
隐式调用导致的bug、副作用、性能问题比常规函数调用更难排查。
会导致JS语言特性
	1. 属性的获取、设置方法。在查询/设置属性值时会调用
	2. 对象在期待字符串的上下文中使用时，调用对象的toString方法。期待数值的上下文中，调用valueOf方法
	3. 枚举可迭代对象的元素时。涉及一系列方法调用。
	4. 标签模板字面量：一种伪装的函数调用。
	5. 代理对象的行为完全由函数控制。对象上几乎所有操作都会调用一个函数。

相关
	1. 返回值
	2. 调用上下文

外部重用
内部递归
### 定义为箭头函数
定义上下文
## 传参
### 扩展参数
...：一种JS语法：可针对数组字面量或函数调用使用。
作用：展开任何可迭代对象的元素（数组，字符串）

技巧：鼓励多使用对象，数组等复合值，可使用[[解构赋值]]或扩展操作符，
### 参数赋值
传入实参会被赋值给函数定义时声明的形参，这个过程类似变量赋值，所以可使用[[解构赋值]]。
# 技巧
## 初阶
1. 收集与扩展
```javascript
// 定义一个函数：计算一个函数调用所使用的时间
// 思路：
//	1. 确定希望的调用形式
//		1. 传入一个函数，并传入参数（一次性接收所有参数，可直接用于测试）
//        （函数与该函数需要调用的参数发生**耦合**，参数可能不会在调用时确定）
//		2. 传入一个函数，返回处理后的函数，再调用传参（常用）（需要再调用一次，且存在闭包）
//	2. 
// 接收该函数，确定开始，执行，确定用时。
function timed(f) {
  return function(...args){
    let startTime = Date.now()
    try {
      return f(...args)
    } finally {
      console.log(`used ${Date.now() - startTime} seconds`)
    }
  }
}
timed((x) => {console.log(x)})(9999)
```
1. 将函数内部可能用到的值保存到函数属性（而不是全局变量）
	1. 使用对象特性实现防抖节流？
## 中阶
1. 形参接收对象时，可直接[[解构赋值]]
	1. 函数定义不需要考虑代码==健壮性==时：写的不是==私有函数==时）
2. 柯里化
3. 高阶函数
4. [[函数式编程]] 
5. 递归
6. 尾递归

[^1]: 参象调包（三只大象调包）