
# 概述
有名字，有参数的JS**代码块**。定义一次可反复调用。
## 组成
1. function关键字
2. 函数名：标识符。新定义的**函数对象**会被赋值给这个标识符
3. 圆括号
	1. 形参：逗号连接的0或多个标识符
4. 花括号：0或多个JS[[语句]] 
	1. 函数体
	2. 返回值
	3. 调用上下文（即this关键字的值）：函数**通过一个[[普通对象]]被调用**/**在一个[[普通对象]]上被调用**时。
## 特性[^1]
从外到里：本身是对象，参数化，闭包，调用上下文。
1. **对象**：可进行保存、传递、添加属性
2. **参数化**：函数定义可包含一组**形参**标识符
3. **闭包**：函数定义可访问*所在函数作用域*中的所有参数和变量。（虽然书目原句是这么说，全局作用域内的函数定义就不叫闭包了吗？）
	1. 基于闭包可实现重要、强大的编程技巧。
4. **调用上下文**
5. 可**嵌套定义**在其他函数中，就像对象中定义对象
> [!NOTE] Title
> 除了[[String]]，[[Number]]，bool，null, undefined, [[Symbol]], [[BigInt]]都是对象 --- [[普通对象]] 
## 机制/原理
## 分类
1. [[构造函数]]：通过new关键字调用，用于初始化一个新对象的函数
2. 生成器函数：function*
3. 异步函数：async function
4. 方法：通过一个对象调用(往往与对象内的操作有关)
# 定义
## 函数声明
关键字，函数名标识符，形参标识符，函数体
关键在于
	1. **函数名变成了一个变量，保存的值就是函数本身**。
	2. 声明语句被提升到包含脚本、函数、代码块的顶部。（调用可以出现在定义之前）
## 函数表达式
使用函数名可方便在函数体内调用自身。
最佳实践是使用const把函数表达式赋值给常量：防止意外重写
## 箭头函数
是[[表达式]]，不是[[语句]]，所以不必使用函数名
返回：直接返回一个[[对象]]字面量时，需要用圆括号包裹。否则花括号标识会被认为是函数体的标识。
## Function构造函数
## 嵌套函数
函数定义可以嵌套在嵌套定义中。
最重要的是理解变量[[作用域]]规则：可访问函数定义的外层的参数和变量。
## 小结
|  | 函数声明 | 函数表达式 | 箭头函数 | 嵌套函数 |
| --- | --- | --- | --- | --- |
| 定义 | 4个都必须 | 函数名可选 | 函数名、function可选 |  |
| 场景 |  |  |  |  |
| 调用上下文 | 取决于被谁调用 |  | 从定义自己的环境继承[[this关键字]] |  |

声明与表达式的不同
	1. 函数声明有**声明提升**
		1. 不要在[[语句]]中声明、
	2. 箭头函数
		1. **调用上下文的值**：从函数定义的环境中继承
		2. 没有prototype属性
			1. 不能作为新类的[[构造函数]] 
			2. 不能使用[[Function.prototype]]的方法?

分类
	1. 匿名函数：无函数名的函数定义
	2. 具名函数：需要重用、内部递归
	3. [[构造函数]] 

方法：保存在对象内的函数
# 调用
构成函数体的JS代码在调用的时候执行。
函数是一种可产生副作用的对象？
只有函数能被调用，而且处处都是函数。
## 方式
### 作为函数
通过**调用表达式**，被作为函数或方法调用
用于执行函数体中的JS代码

调用表达式：求值为函数对象的[[表达式]](逗号分隔的0或多个参数表达式)
如果前者是属性访问表达式（函数是对象的属性或数组的元素），则是个方法调用表达式。

1. 函数的**返回值**会变成函数调用表达式的值。
	1. 如果由于解释器到达末尾返回，返回值是undefined
	2. 如果由于解释器执行到return语句返回，返回值是return后面表达式的值（没有值就是undefined）
2. 函数的调用上下文
	1. 非严格模式下，是全局对象。严格模式下是undefined
### 作为方法
在对象下调用
### 作为构造函数
用于生成新对象
### 通过call, apply方法间接调用
### 通过JS语言特性隐式调用
相关
	1. 返回值
	2. 调用上下文

外部重用
内部递归
# 技巧
柯里化
高阶函数
[[函数式编程]] 


[^1]: 参象调包（三只大象调包）