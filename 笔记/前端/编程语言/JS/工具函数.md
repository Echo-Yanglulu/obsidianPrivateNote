## 防抖
在规定时间后执行函数，如果规定时间内调用，则取消调用并重新计时
```js
  const debounce = (fn, second == 500) => {
    let timeid = null;
    return function (...args) {
	let context = this
      if (timeid) {
        clearTimeout(timeid);
        timeid = false;
      }
      timeid = setTimeout(() => {
	      fn.apply(context, args)
	      timer = null;
      }, second);
    };
  };
```
场景：输入后搜索/保存
## 节流
在规定时间内只执行一次【可以在开始，也可以在结束】，第二次调用时不予执行。
本质：多次调用时，减少触发频率
```js
  const throttle = (fn, delay) => {
    let timeid = null;
    return function (...args) {
		let context = this
	    if (!timeid) {
	        // 如果希望在规定时间开始时执行，fn调用放在外面；
	        // 希望在规定时间结束时执行，fn调用放在定时器里面
	        //【先执行】:点击发送请求时
	        //【后执行】：拖拽一个元素时，拿到元素被拖拽的位置。获取拖拽位置的话一般是100ms,太久了不准确
	        // 不建议使用arguments，建议使用参数收集
	        fn.apply(this, args);
	        // 调用，在规定时间后清除即可
	        timeid = setTimeout(() => {
	          clearTimeout(timeid);
	          timeid = null;
	        }, delay);
	    }
    };
  };
  // 如果内部使用this，传入函数时就不能传箭头函数
  const fn = throttle(function (){
	  console.log('clicked')
  }, 1000)
```
场景：获取鼠标位置，窗口的 resize，发送请求（在计时的开始时触发）