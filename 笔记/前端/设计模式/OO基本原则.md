>原则是目标，设计模式是实现这些目标的方法。往往一个设计模式会包含（体现）几个原则。

# 开闭

>定义：一个软件实体（类，模块，函数等）开放拓展，关闭修改。开放拓展（功能），关闭修改（内部实现）
1. 理解：在实现需求前，应先尽可能全面（关闭修改）且单一（单一职责）地实现该功能的抽象/封装，并留有拓展接口。后续相关需求的实现应尽量依赖对该软件实体/封装的调用与扩展。难点是封装时如何确定不变的部分，并使留出的扩展接口能较大程度满足用户的需求。  
2. 函数的拓展：在原型上实现一个extend方法以拓展函数功能a.extend(() => {})

# 里氏替换

>定义：父类可以替换为子类（子类需要包含父类的所有功能），而程序执行效果不变。。所有引用基类的地方必须能透明地使用其子类的对象。

理解：
1.  用于替换原有父类的类必须完全包含父类所有的属性与方法，且不能重写。
2.  哪些方式会导致新的类替换父类时会发生问题？
	1.  定义父类时存在禁止被继承的方法。【定义类时不要带有不能被继承的属性/方法？】
	2.  定义子类时重写了父类的某个方法。【父类定义方法时设置为只读？】

举例：

# 单一职责

>定义：一个类只允许有一个职责，即只有一个导致该类变更的原因。

理解：
	1.  当一个类/对象/函数的职责不唯一时，提高了程序的耦合性。如果有多个职责，一个软件实体被用到的地方就可能会很多，一旦需要修改，这种高耦合就可能导致无法预料的问题。

举例：门诊负责区分生病的种类，医生负责治病，护士负责护理。如果门诊除了分科还要看一些病，医生要治病也要看护病人，护士除了护理还要看一些简单的病，就会形成干扰，一旦其中一个发生了变动其他人都会受到影响

# 依赖倒置
>定义：一个高级模块不应依赖低级模块，而应依赖它的抽象。细节依赖抽象，而非抽象依赖细节。

-   依赖抽象，而不是依赖实现。
-   抽象不应依赖细节；细节应该依赖抽象。
-   高层模块不应依赖低层模块，二者都应依赖抽象。
# 接口独立
>定义：客户端不应被强迫依赖它并不需要的接口。

理解：
	1.  工具的使用者不应该拥有他根本用不上的工具。
	2.  设计接口时，不要把所有接口定义在一个较为通用的总接口中暴露出去，而是根据使用场景/功能暴露多个单一的特定接口。

举例：一个工具箱，里面有几十个螺丝刀，每个种类又有大中小三种规格。如果不是专业工作，而是普通家用，**实际能用到**的工具可能只有几个，买下一整个工具箱对家用而言就是负担，不如只买那几个需要的螺丝刀。

JS中没有“接口”的概念，TS中有interface。（JS是动态类型语言，不需要对变量的数据类型进行限制）
接口：对一个对象的属性与方法的定义与调用进行规范。当接口应用到一个对象时
# 迪米特法则
>定义：一个对象应该对其他对象保持最少的了解。

~~理解：事物之间如何联系？一个事物不应深入到另一个事物的内部方法去调用，因为两个事物是分别作为两个**整体存在**的，如果要交互，应该只关注两个事物分别向外界提供什么功能，而不是一个事物深入到另一个事物内部去和**事物的细节**进行交互。~~

~~举例：一个国家内某个地区盛产粮食，而其他国家粮食匮乏。其他国家想要买它的粮食时，不应该每次都让所有想买的国家去这个国家的这个地区去买，而是应该由这个盛产粮食的国家本身做好粮食出口【国家层面的人应该和国家层面的人沟通，而不是和地区层面的人沟通】。

类之间关系越密切，耦合越高，其中一个发生变化时，对另一个影响就越大。

如：一个类在实现某个方法时，不应依赖另一个类中的某个方法，应由该类向外提供一个接口~~

迪米特法则和依赖倒置的比较：

1.  迪米特：一个对象对另一个对象保持最少的了解。
2.  依赖倒置：不要跨抽象层级进行通信。
3.  迪米特强调应当进行**同级通信**，依赖倒置强调进行同级通信时**不应直接通信**，而是通过抽象。迪米特是对**通信对象**的规定，依赖倒置是对通信双方使用的**通信方式**进行规定

# 面向对象原则总结：

1.  **创建**一个软件实体（函数，类，模块，【接口？】）时：
	1.  保证它对外部而言只有一个功能（单一职责）；
	2.  只提供对外接口（关闭修改），并留有扩展接口（开放扩展）
	3.  **定义父类时**要定义可继承，但只读的方法。继承**创建子类时**不要重写父类的方法（里氏替换）。子类替换父类时如果确实需要重写方法，可创建新类，同时拥有父类方法和希望使用的方法【有点像React提到的“用组合代替继承”】（里氏替换）
2.  软件实体之间进行**沟通**时：
	1.  不要跨层级，而应由软件实体提供一个接口，进行软件实体层面的通信（迪米特）；
3.  最终实现一个高内聚，低耦合的程序
	1.  创建一个软件实体时，要开闭，单一职责，迪米特法则，依赖倒置，接口独立。软件实体沟通时，要依赖倒置。

软件实体内部：
	1. 开闭法则
软件实体之间
	1. 里氏替换
	2. 迪米特法则
	3. 依赖倒置
软件实体对外
	1. 接口独立
