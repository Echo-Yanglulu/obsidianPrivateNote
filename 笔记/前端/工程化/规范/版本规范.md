# 版本规范
> 我们的npm包应该发什么版本？
> 我们的依赖应该应该写什么版本？

说起npm包的版本，首先是一个概念==Semantic Versioning==[^1] 
方案举例：
	2.3.1-beta.1
正式版本-preRelease版本
正式版本
	1. 主版本major：破坏性改动。架构重构或使用，或兼容上有巨大差异。如webpack 4.x与5.x
	2. 次版本minor：新feature出现，不会出现兼容问题
	3. 补丁patch：只是bug修改或与功能无关的修改
pre-release版本[^2] ^uwud5g

为何要遵循Semantic versioning这个规范？
	1. 让版本语义与npm社区统一，让我们的npm包可以被用户正确地使用。
		1. 用户不想引入breaking change，就可通过^限制
	2. 享受社区生态带来的便利，利用社区现有方案，灵活地管理依赖的版本。
## 大小比较
![[Pasted image 20220717170014.png]]
## 版本范围
点（限制升级），限制次版本的升级（允许[[#^uwud5g|补丁版本]]升级），允许第二个非零版本的升级（限制主版本的升级），闭区间，。
![[Pasted image 20220717170053.png]]
^0.0.3：这个第二个非0的允许是不起作用的，因为没有第二个非零版本。
即：项目当前不能只是不成熟的补丁版本阶段，。如果有主版本，就允许次版本升级，如果最新只有次版本，就允许补丁版本升级。
8种升级规则
# changelog
>对于变更应该如何管理、维护、阅读？

定义：以时间为倒序的列表，记录所有版本的重大变动。
功能：让（我们提供的框架，库的）用户了解，每个版本发生了哪些变化[^3]。

无论是npm包的版本变化，还是changelog 的更新，都和npm包的内容变化有关，这个变化又能通过npm包的内容变化体现。

# 自动化的管理版本与changelog方案
>一个自动化的发包流程应该是怎样的？

发布npm包的时候，是一个非常适合规范版本号与更新changelog的时间
第三方库[[release-it]]：自动根据提交信息生成版本修改日志、修改版本号。
# [[commit message规范]] 

[^1]: 语义化版本：版本号的每一位都有一定语义。不仅是npm包，也是其他请多语言的包管理方案使用的一种规范
[^2]: 预发行版本：不是必须存在，只存在于联调与测试状态。正式包的版本号不应包含这部分。没有标准，但一般使用alpha, beta, rc(release candidate)
[^3]: 用户看到3.1.0变成3.2.0，就知道新增了feature，可通过详情查看。