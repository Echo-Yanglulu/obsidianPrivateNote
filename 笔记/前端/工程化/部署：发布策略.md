由于有[[前后端分离]]，所以可从前端与后端两个方面讨论发布策略。
# 前端发布策略
前端发布的本质是[[静态资源]][^1]的发布[^2]。
## 初始状态下的前端资源
1. 存在一个HTML模板
2. HTML中引入了一个CSS，
3. 这两个都由服务器反向代理
![[Pasted image 20220817230244.png]]
网络时序图：页面与CSS会依次加载
这种原始状态的前端加载，如何进行优化？可用[[缓存]]，协商缓存可以，因为还要发送一次请求。本地缓存可以，但本地缓存浏览器要怎么知道**资源已经更新**？
![[笔记/前端/工程化/Untitled Diagram.svg]]
1. 给静态资源的URL加上**版本号**[^3]
	1. 不可取，因为版本号是整个应用的，每次都要全量更新版本号。静态资源可能很多，如果有一个资源发生了变化，就全量修改每个资源的URL的版本号后缀，缓存的意义就不大了[^4]
2. 用静态资源的[[hash值]]作为后缀替代版本号[^5]
	1. 看似可取。但大公司所有的静态资源都部署在CDN，即：HTML模板与静态资源不在一个服务器上。
		1. 不在一个机器，部署必然存在==时间差==。（如果用户在这个时间差内访问了页面）
			1. 页面先部署，就会导致页面访问旧资源，在这个时间差内访问页面的用户加载的静态资源是旧资源，但浏览器可能把这些旧内容当作新内容缓存[^6]。
			2. 静态资源先部署，导致
		2. ==非覆盖更新==[^8]
> 小结
> 使用本地缓存时：
> 覆盖式更新：每次部署时用新资源替换旧资源，
# 后端发布策略

[^1]: 一般是JS与CSS，不包括动态渲染出来的HTML模板。
[^2]: 因为HTML页面本身并没有什么东西？都是JS,CSS,图片等内容？
[^3]: 因为==本地缓存与请求的URL有关==，就在资源的URL后面加上一个版本相关的参数，每次更新资源就同步更新参数。下次更新时修改版本号，让用户的缓存失效。
[^4]: 只有某个资源变化，却全量更新资源的URL，就没有必要缓存了，因为内容没有变化的资源也会被重新请求（只是版本号变了）。
[^5]: 只有被改动过的静态资源，缓存才会失效。
[^6]: 除非用户手动清除缓存，否则无法访问最新资源。
[^8]: 不再通过URL参数带hash的方式解决缓存问题，而是将==hash写入静态资源的文件名==。原来是同名文件只能有一份。非覆盖式更新是把hash值加在文件名上