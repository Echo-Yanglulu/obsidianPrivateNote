由于有[[前后端分离]]，所以可从前端与后端两个方面讨论发布策略。
# 前端发布策略
前端发布的本质是[[静态资源]][^1]的发布[^2]。
## 初始状态下的前端资源
1. 存在一个HTML模板
2. HTML中引入了一个CSS，
3. 这两个都由服务器反向代理
![[Pasted image 20220817230244.png]]
网络时序图：页面与CSS会依次加载
这种原始状态的前端加载，如何进行优化？可用[[缓存]]，协商缓存可以，因为还要发送一次请求。本地缓存可以，但本地缓存浏览器要怎么知道**资源已经更新**？
![[静态资源缓存.svg]]
1. 给静态资源的URL加上**版本号**[^3]
	1. 不可取，因为版本号是整个应用的，每次都要全量更新版本号。静态资源可能很多，如果有一个资源发生了变化，就全量修改每个资源的URL的版本号后缀，缓存的意义就不大了[^4]
2. 用静态资源的[[hash值]]作为==查询参数==替代版本号[^5]
	1. 看似可取。但大公司所有的静态资源都部署在[[CDN]]，即：HTML模板与静态资源不在一个服务器上。
		1. 不在一个机器，部署必然存在==时间差==。（如果用户在这个时间差内访问了页面）
			1. 页面先部署，就会导致页面访问旧资源，在这个时间差内访问页面的用户加载的静态资源是旧资源，但浏览器可能把这些旧内容当作新内容缓存[^6]。
			2. 静态资源先部署，导致
		2. ==非覆盖更新==[^8]
> 小结
> 使用本地缓存时：
> 覆盖式更新：每次页面部署时为资源的==URL查询参数==添加hash，每次资源部署时资源文件名不变，用新资源替换旧资源。
> 非覆盖式更新：页面部署与资源部署分别为资源URL与==资源文件名==同时添加hash。
# 后端发布策略
本质：后端服务在多台服务器上的分发。
## 原因
大公司不可能用单个服务器承载所有流量，而是一个服务器集群，分摊高并发服务的成本，提高了服务的可用性。
## 核心问题
1. 如何减小用户对新旧版本不一致的感知
2. 发布过程中的服务如何尽可能稳定
3. 如何保证发布的结果是一致的
## 常用策略
### 滚动更新
定义：应用的新版本逐步替换旧版本。在此期间，新旧版本共存。[^9]
特点
	1. 节约**资源**（滚动更新过程中不需要额外的**服务器资源**）
	2. **流量**冲击小
	3. **回滚**不及时（逐步更新过程中如果有问题，需要逐步替换回去。事故的影响时间较长）
	4. 中间状态不一致（新旧代码有逻辑不一致，冲突。用户的两个操作可能造成奇怪的错误）
### 蓝绿部署
定义：不停止老版本，在新服务器上对新版本进行部署与测试。通过后把流量切换到新版本
特点
	1. 占用资源
	2. 流量冲击大（整体切换流量）
	3. 回滚方便（流量切回原来的）
	4. 切换流量时要妥善处理**未完成的请求**。
### 灰度发布/金丝雀发布
定义：


[^1]: 一般是JS与CSS，不包括动态渲染出来的HTML模板。
[^2]: 因为HTML页面本身并没有什么东西？都是JS,CSS,图片等内容？
[^3]: 因为==本地缓存与请求的URL有关==，就在资源的URL后面加上一个版本相关的参数，每次更新资源就同步更新参数。下次更新时修改版本号，让用户的缓存失效。
[^4]: 只有某个资源变化，却全量更新资源的URL，就没有必要缓存了，因为内容没有变化的资源也会被重新请求（只是版本号变了）。
[^5]: 只有被改动过的静态资源，缓存才会失效。
[^6]: 除非用户手动清除缓存，否则无法访问最新资源。
[^8]: 不再通过URL参数带hash的方式解决缓存问题，而是将==hash写入静态资源的文件名==。原来是同名文件只能有一份。非覆盖式更新是把hash值加在文件名上
[^9]: 这个过程中服务不会中断。可能有的请求响应的是新版本，有的响应是老版本。