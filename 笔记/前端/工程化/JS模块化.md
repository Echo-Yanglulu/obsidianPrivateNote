# 方案
JS模块化方案
## [[CommonJS]] 
意义
	1. 主要是服务端使用
		1. node.js对它的实现依赖了node.js本身的功能，但随着[[打包工具]]的出现，经过处理的CommonJS代码也可在浏览器中使用。其模块语法不能在浏览器中直接运行。
		2. 不用考虑网络延迟问题。
什么是“*模块定义*”，如何将字符串解析为模块，取决于**模块系统的实现**（与模块标识符一样）
	node.js中，模块标识符可能指向文件，也可能指向包含index.js文件的文件夹。

模块是单例。一个模块无论被require引用多少次，都*只加载一次*（代码只执行一次）。
	1. 第一次加载后会被缓存，后续加载从缓存中取。
	2. 如果已经加载过，再次引入只是暴露这个命名空间。
实现
	1. Node.js
## [[AMD]] 
CommonJS 规范之后推出的一个解决 web 页面**动态异步加载 JavaScript** 的规范
特点
	1. 实现简单
	2. 浏览器支持
	3. 可异步加载
虽然适合浏览器端开发，但随着npm包管理机制流行，这种方式可能逐步被淘汰。
使用
	1. 引入模块：require()
	2. 定义新模块：define()
## UMD
兼容CommonJS与AMD规范。即要在node.js环境运行，又要在浏览器环境运行，一般使用该规范对项目进行模块化。
## [[CMD]] 
node环境
实现
	1. SeaJS模块加载器
## [[ES Module]] 
AMD与CommonJS都没有**统一浏览器与客户端的模块化规范**
1. node.js可通过在.mjs文件中node --experimental-modules some-esm-file.mjs添加-experimental-modules：true启用该语法。
2. 可通过[[babel]]或[[TS]]提前体验（为啥，因为都有编译器？）
