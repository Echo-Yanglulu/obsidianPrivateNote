# 方案
JS模块化方案
## [[CommonJS]] 
该规范
	1. 概述了同步声明依赖的模块定义。
	2. 主要服务器端代码的模块化，也可浏览器环境中**定义模块依赖**。但其模块语法不能在浏览器中直接运行。
意义
	1. 
node.js对它的实现依赖了node.js本身的功能（**浏览器环境不可用**），但随着[[打包工具]]的出现，通过处理的CommonJS代码也可在浏览器中使用
[[node]]主要在服务器环境下使用，不用考虑网络延迟问题。
Node.js对CJS的实现
	1. 使用相对路径



什么是“*模块定义*”，如何将字符串解析为模块，取决于**模块系统的实现**（与模块标识符一样）
	node.js中，模块标识符可能指向文件，也可能指向包含index.js文件的文件夹。

模块是单例。一个模块无论被require引用多少次，都*只加载一次*（代码只执行一次）。
	1. 第一次加载后会被缓存，后续加载从缓存中取。
	2. 如果已经加载过，再次引入只是暴露这个命名空间。
## [[AMD]] 
node环境
CommonJS 规范之后推出的一个解决 web 页面**动态异步加载 JavaScript** 的规范
特点
	1. 浏览器支持
	2. 实现简单
	3. 可异步加载
虽然适合浏览器端开发，但随着npm包管理机制流行，这种方式可能逐步被淘汰。
## [[ES Module]] 
AMD与CommonJS都没有**统一浏览器与客户端的模块化规范**
1. node.js可通过在.mjs文件中node --experimental-modules some-esm-file.mjs添加-experimental-modules：true启用该语法。
2. 可通过[[babel]]或[[TS]]提前体验（为啥，因为都有编译器？）
## UMD
兼容CommonJS与AMD规范。即要在node.js环境运行，又要在浏览器环境运行，一般使用该规范对项目进行模块化。
## CMD
node环境
