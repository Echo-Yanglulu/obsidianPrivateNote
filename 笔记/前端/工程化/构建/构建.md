# 概述

为何构建？
	1. 因为模块化形成了许多文件，只方便开发、维护，需要一个*适合运行*的代码。
		1. 减少内容
			1. 静态资源压缩、使用CDN、合并精灵图
	2. 为了避免被直接审查*看到源码*，需要进行编译
		1. 对JS进行混淆，提高代码阅读难度
如何构建？
	1. **预编译**
		1. 将大量浏览器无法直接识别的，新增的预处理器（[[Sass]], [[LESS]]）语法、TS、ES6语法，编译为浏览器可识别的css或js代码[^9]。
	2. **合并**
		1. 策略
			1. 把所有js文件合并为一个js
			2. 把三方库合并为一个js，页面代码合并为一个js
			3. 根据依赖关系（频率的高低）生成公共js，页面代码合并为一个js
	3. **混淆**[^10]
		1. [[Uglyfy]]。将合并后的代码混淆，生成一个压缩后的js文件，一个sourcemap。
		2. [[PostCSS]]。
# 简史
1. 93，94，95年依次出现HTML,CSS,JS
2. 最热话题：DOM，BOM，样式，浏览器兼容性。不用构建
3. Jquery
![[Pasted image 20220724152718.png]]
![[Pasted image 20220724152754.png]]
![[Pasted image 20220724152831.png]]
4. nodejs出现之后，前端可以使用自己熟悉的语言编写==构建脚本==。如
	1. 使用node-sass处理sass转css的工作
5. 随着构建任务越来越多，构建过程复杂，“为每个构建任务开发脚本”的方式难以管理。于是这个时代有了（运行在node环境的）==自动化构建==工具[[grunt]] ,[[gulp]][^1]
	1. 前端生产力提高，[[预编译语言]]进入黄金时代。
6. 这些初代构建工具存在局限性。
## 语言的进化
### ES6的出现
正式出现以前就开始使用[[转义工具]]进行试用
特点
	1. 语法提高了前端开发效率
		1. 箭头函数
		2. class
		3. Promise
		4. es module
## MV\*框架的出现
意义：不再关心DOM细节，用数据驱动UI。
react, vue, angular
## 模块化方案
ES5时代的JS没有这个概念，最佳实践是在一个JS文件中写所有代码[^2]。于是出现了[[模块化]]方案。
## 如何将模块化的代码转换成浏览器支持的格式
# 现代化前端构建
==关心内容== 
	1. 性能[^3]
	2. 模块化支持[^4]
	3. 语法转换[^5]
	4. 统一的打包过程、整体分析优化[^6]
# [[打包工具|工具]] 
[[Browserify]]属于？
## 自动化打包工具
1. [[grunt]] 
2. [[gulp]] 
## 静态模块打包工具
这类构建工具通常需要**指定入口**，根据一个构建模块依赖图module graph，将graph分离为三种类型的bundle
	1. entry所在的initial bundle
	2. lazy load的async bundle
	3. 其他自定义分离规则的custome bundle 
1. [[webpack]]：配置灵活，生态丰富，构建**首选**；
2. [[rollup]]：推崇**ESM**标准开发打包出来的代码干净，适用于**组件库项目**；
3. [[parcel]]：号称零配置，使用简单适合**不需要定制化**构建的项目
## 新一代构建工具
1. [[vite]]：
	1. 开发模式：借助浏览器对[[ES Module]]支持，nobundle方式构建
	2. 生产模式：基于[[rollup]] 进行构建
2. [[Esbuild]]：webpack基于JS，它*基于*go语言实现，*构建速度*比webpack快
# 目标
提高开发效率


[^1]: 两个真正的，专业的，面向前端工作流的工具
[^2]: 限制了一个JS应用的规模。
[^3]: 图片优化，合并资源，减小polyfill体积
[^4]: 把CMD或es module转化为script标签
[^5]: ES 6、ES 7、ES 2022等标准语法，JSX等非标准语法
[^6]: 如一个vue单文件组件的优化
[^7]: 语法：语言级别的，最基础的概念，无法用其他概念实现。
[^8]: feature: 一般指对象，方法，可以通过语法实现。
[^9]: 使用预处理器把less、scss编译为css，使用编译器把ts编译为js，把高版本的ES语法通过babe编译器l转换为低版本的语法以妆容低版本浏览器。
[^10]: 减小代码体积、避免源码被看到