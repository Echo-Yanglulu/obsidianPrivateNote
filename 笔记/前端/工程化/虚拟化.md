# 概述
虚拟化在大规模分布式应用部署中非常重要
	1. 一个机器中部署了多个服务，如果每个服务都需要各自不同的运行环境，可能冲突。手动地在大规模集群中依次解决这些依赖冲突并不现实。虚拟化方案可把各个应用的运行环境隔离开。
# 方案
## 虚拟机
Docker出现之前的最常用方案。
![[Pasted image 20220825234249.png]]
硬件之上的Hypervisor层：抽象了各个硬件平台的区别，通过一些底层代码（如C，汇编），用软件模拟了一个计算机的各个设备。在这个抽象的硬件平台上运行各种虚拟机（虚拟机是对应用与它所依赖的操作系统，对整个环境的打包）
	1. 虚拟机的硬件会有大量性能打损失
	2. 多个完整的操作系统非常占用空间，降低了应用的启动速度。因为一个应用的启动要在操作系统完整启动后。
## Docker
![[Pasted image 20220825234720.png]]
跑在一个普通的操作系统上，每个应用都是Docker的一个子进程。看起来和普通的多进程应用差不多，没有什么性能损失的方面，所以被称为划时代的项目。
Docker是如何把这些进程一个个正确地隔离的？看底层技术
## 底层技术
利用了（Linux）操作系统提供的能力，主要使用
	1. Linux Cgroups ：Linux内核的一种**限制进程所使用资源**的机制
	2. Linux Namespaces：Linux内核中一种对**内核资源进行分区**的机制。
		1. 可使每个进程都访问不同的资源。如两个进程可有各自的操作系统根目录。其实这多个根目录对于宿主机而言是两个目录
所以，最纯正的Docker只存在于Linux平台。想在生产环境使用Docker必须使用Linux。
### 定义
特点
	1. 释放计算虚拟化的威力
	2. 降低云计算应用开发成本
	3. 提高应用的维护效率
	4. 对系统资源利用率更高 
		1. 容器不需要进行硬件虚拟， 运行完整的操作系统
	5. 让应用的部署，测试，分发都更高效轻松
作为一个虚拟化的方案，和虚拟机（同样做虚拟化）的区别是什么？
	1. 高效利用系统资源，相同配置的主机可运行更多应用
	2. 直接运行于宿主机的内核，不用启动完整的操作系统。不同于虚拟机的分钟，这个是秒级甚至毫秒级
	3. 一致的运行环境。
		1. 由于开发、测试、生产的运行环境不一致，导致一些BUG无法在开发过程中发现。提供了除内核外完整的运行环境，
### 基础知识
**容器**container：运行起来的，带有虚拟化环境的程序（本质是**进程**）
**镜像**image：构建好打包好的环境（是个**文件**，一切就绪，可直接执行）
二者像类与对象、程序与进程的关系。
**宿主机**
DockerHub平台：共享自己打包好的镜像，类似Docker中的npm仓库
Dockerfile：一个文件，描述了该镜像是如何建立起来的。
### 使用

安装
![[Pasted image 20220825235438.png]]
### docker [[CLI]] 
使用docker pull jenkins命令**拉取镜像**到本地
docker run jenkins**启动容器**
docker attach进入容器（像进入了一个新的操作系统）
docker stop停止容器
### 案例
#### 使用Docker部署[[Verdaccio]]
task: 使用DockerHub上的官方镜像，一键部署Verdaccio
	1. 要部署一个开源项目，先在DockerHub 上找到这个项目的相关镜像。
## Kubernetes
