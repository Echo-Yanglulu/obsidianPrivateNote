# 意义
在发布流程上，前端不再是后端的附庸。
# 前提/基础
前端的[[工程化]]，[[模块化]]，[[组件化]]
# 目的
# 为前端带来的可能性
# 策略
## 工程拆分
repo分离
	1. 不同的开发、CI、构建、发布节奏
## 技术拆分
前后端使用各自熟悉的技术，通过RESTful API交流
# 时代/不同方案
## 不分离(如[[MVC]]架构)
前端作为VIEW层，后端渲染HTML模板及其[[静态资源]]。在构建与发布流程中，前端是后端附庸。
缺点
	1. 构建
	2. 联调
	3. 发布
	4. 性能
## Nginx代理静态资源
没有页面模板，把**HTML作为静态资源**（HTML只在body里有一个空div），使用代理（Nginx/ Apache HTTP Server）响应对所有静态资源的请求，如果是数据请求（API这个path下的请求）就转发给真正的后端服务。HTML页面内容由JS渲染。
缺点
	1. 只适合纯[[CSR]]，及[[SPA]]
	2. 首屏慢，C端不友好
	3. 不利于[[SEO]]（因为都是静态资源，所以这种模式下SE眼中的）
## 后端渲染+CDN代理
后端渲染HTML页面，静态资源独立构建放在CDN。在构建时后端与前端结合，后端拿到HTML模板（有关静态资源的链接指向CDN）。
优点
	1. 部分解决了前后端分离
	2. 可SEO。
缺点
	1. 流程耦合：因为是在构建时后端重新获取HTML模板，所以前端页面模板更新，后端也要发布。
	2. HTML模板耦合：需要前端学习后端模板语言（如果后端是JAVA需要学习jsp或freemarker）
> 小结
> 开始由后端渲染页面模板。后来第一次尝试，无页面模板，把HTML作为静态资源由后端代理所有静态资源请求，其他请求转发给真正的后端服务（存在首屏，SEO问题，适用范围也小CSR及SPA）。
## Node BFF（前后端分离较为理想的时代）
用NodeJS写BFF层。用于接口聚合与模板渲染。
	1. 如前端有IOS与安卓，需要的数据结构不同。于是前端需要分别书写IOS与安卓的BFF层，这样后端不用关心前端的差异，由BFF层做接口聚合。
	2. 对Web应用，BFF有渲染模板的功能
		1. 利用node BFF，可使用EJS或handle bar等模板语法。不用额外学习JAVA的[[模板引擎]]。
### 意义
它使前端的范围扩大了。
	不再只能写在用户浏览器上运行的代码，而是写为==前端业务==服务的代码。
## 同构
定义：利用[[vue]] ，[[react]] 等前端框架提供的服务器渲染能力，在服务器就将页面渲染好。
本质还是BFF，但使用[[SSR]]渲染的好处是
	1. 可以像写普通的SPA一样去写一个web应用。
	2. 不会像HTML模板引擎一样造成开发流程的割裂。
	3. 没有普通SPA的：首屏性能低，SEO效果差。
## SSR/Serverless/GraphQL