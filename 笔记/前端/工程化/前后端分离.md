# 意义
在发布流程上，前端不再是后端的附庸。
# 前提/基础
前端的[[工程化]]，[[模块化]]，[[组件化]]。
# 为前端带来的可能性
对应不分离产生的痛点
1. 解耦前后端的**架构** 
2. 分工明确，**界限**清晰
3. 提高**效率** 
	1. 前端不用配置与维护本地的后端环境
	2. 应用启动速度提高
4. 前后端**构建、发布**可分别使用不同的[[部署：发布策略|策略]]，节奏。
	1. 前端静态资源可部署在CDN上，不用让一个服务器既要响应前端的静态资源，又要响应数据。
# 策略
## 工程拆分
**repo**分离
	1. 不同的开发、CI、构建、发布节奏
## 技术拆分
前后端使用各自熟悉的技术，通过[[RESTful API]]交流
# 时代/不同方案
## 不分离(典型如[[MVC]]架构)
前端作为VIEW层，后端渲染HTML模板及其[[静态资源]]。在构建与发布流程中，前端是后端附庸。
缺点/痛点
	1. 协作
		1. 前端每次都要启动一个耦合的服务
		2. 环境配置容易错误，还要保证后端代码版本合适。
	2. 联调
		1. 前端很多变量是后端通过模板加入页面
			1. 只能通过console打印出来调试
		2. 后端如果修改代码，前端必须更新代码并重启本地服务。
	3. 发布耦合
		1. 每次其中一个发布另一个也要一起重发
	4. 性能
		1. 前端静态资源与后端服务共享同一web服务器。
			1. 用户访问页面时大量前端静态资源的请求可能耗尽连接池，导致应用整体性性能低下
## [[Nginx]]代理静态资源
较为激进：不用页面模板进行渲染，而是把**HTML作为静态资源**（HTML只在body里有一个空div），
	1. 使用代理（Nginx/ Apache HTTP Server）响应对所有静态资源（HTML+其他资源）的请求
	2. 如果是**数据请求**（API这个path下的请求）就转发给真正的后端服务。HTML页面内容由JS渲染。
![[Pasted image 20220818201254.png]] 
缺点
	1. [[CSR]]，只适合[[SPA]]
	2. 首屏慢，C端不友好
	3. 不利于[[SEO]]（因为都是静态资源，所以这种模式下SE眼中的）
## 后端渲染+CDN代理
后端渲染HTML页面，静态资源独立构建放在CDN。在构建时后端与前端结合，后端拿到HTML模板（有关静态资源的链接指向CDN）。
优点
	1. 部分解决了前后端分离
	2. 可SEO。
缺点
	1. 流程耦合：因为是在构建时后端重新获取HTML模板，所以前端页面模板更新，后端也要发布。
	2. HTML模板耦合：需要前端学习后端模板语言（如果后端是JAVA需要学习jsp或freemarker）
> 小结
> 开始由后端渲染页面模板。
> 后来第一次激进尝试，取消页面模板，把HTML作为静态资源，由后端代理所有静态资源请求，其他请求转发给真正的后端服务（存在首屏，SEO问题，适用范围也小CSR及SPA）。
> 第二次，可能是为了SEO与性能，回到了后端渲染，但静态资源使用CDN，
> 后端渲染页面与静态资源（原始）→后端返回页面与数据，代理返回静态资源→后端渲染页面，静态资源放在CDN→前端写BFF层（BFF）
## Node BFF（前后端分离较为理想的时代）
用NodeJS写BFF层。用于接口聚合与模板渲染。
	1. 如前端有IOS与安卓，需要的数据结构不同。于是前端需要分别书写IOS与安卓的BFF层，这样后端不用关心前端的差异，由BFF层做接口聚合。
	2. 对Web应用，BFF有渲染模板的功能
		1. 利用node BFF，可使用EJS或handle bar等模板语法。不用额外学习JAVA的[[模板引擎]]。
### 意义
它使前端的范围扩大了。
	不再只能写在用户浏览器上运行的代码，而是写为==前端业务==服务的代码。
## 同构
定义：利用[[vue]] ，[[react]] 等前端框架提供的SSR能力，==在服务器将页面渲染好==。
本质还是BFF，但使用[[SSR]]渲染的好处是
	1. 可以像写普通的SPA一样去写一个web应用。
	2. 不会像HTML模板引擎一样造成开发流程的割裂。
	3. 没有普通SPA的：首屏性能低，SEO效果差。
## SSR/Serverless/GraphQL