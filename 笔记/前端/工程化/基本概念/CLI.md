---
时间: 20220827
---
command-line interface

命令的本质是一个（具有发起系统调用能力）**程序**，编写shell脚本是在编写这些程序的执行。

[[node cli]]

# 原理
从基础API到commander这个库

从[[process]].argv说起
	定义：获取当前进程的命令与参数。
	执行： node processArgs.js one two=three four （文件内部打印process.argv，第一个是node路径，第二个是执行的文件的路径，后续是输入的参数）
CLI关心的核心问题，是**参数处理**。（git merge testBranch）如果能提高参数处理的效率，就能提升开发CLI程序的效率：用于node参数处理的库：[[commander]].
# 使用

# 开发
通过开发CLI应用，思考：
	1. 找到问题/需求的==**共性，抽象封装**==为一个通用的解决方案。高级前端的核心竞争力：如何找到需求的共性。
	2. 一定要比别人多思考一步。
		1. 能否做到更细粒度的样板代码生成？
		2. 能否保证生成文件动作的原子性？
		3. 能否做到脚手架的自由组合？
## 重点
### 参数
### 交互
## 常用工具与最佳实践
1. 如何让标准输出带颜色？
2. 复杂交互怎么办？（可能需要一个交互式CLI：[[inquirer]]提供交互式CLI）
	根据提示让用户进行下一步的操作（如git的rebase）
	1. 命令可能太长，难以记忆。
		1. 让用户**一步一步地输入**
	2. 参数太多，容易配置出错
		1. 错误提示（醒目的提示）
		2. 操作成功的给出正面反馈
		3. 对用户搜索的关键词高亮显示（[[chalk]]）
		4. 从当前位置重新输入的机会
		5. 对一些信息，不在命令行的历史信息中留下痕迹
1. 调用其他命令/程序（CLI程序的复用：调用第三方模块/其他程序的库：shelljs, [[execa]]）？
	如此就不用重复发明git/yarn/npm。
	异步进行某些耗时操作，希望网络请求，后台的密集计算等不影响前端CLI程序与用户的交互
	node通过child_process模块提供了创造子进程的能力。但想要使用更专业的CLI程序，不建议使用原生的cp.exec等命令，而是使用工具库shelljs, execa
1. 只想开发个脚手架？
2. 如何把CLI程序写得更好？
## 拆解CLI设计
### 需求描述
设计一个脚手架CLI，根据命令选择不同模板，按照指定参数在指定路径生成一个样板工程。
> 如果只是想实现一个脚手架，可使用写脚手架的框架：[[yeoman-generator]]或[[polp]]
### 需求拆解
1. 参数的输入与结果的输出
	1. 库：[[chalk]], [[commander]], [[inquirer]] 
2. 模板管理（不要和CLI本身耦合在一起维护，分开维护能让使用与开发更加灵活）
	1. 在另一个单独的仓库中维护模板
3. 如何获取模板？
	1. git clone， 使用[[execa]] 或[[shelljs]] 调用
4. 如果根据模板与参数生成工程？
5. 

用React开发CLI应用
	[[ink]]

[[oclif]]