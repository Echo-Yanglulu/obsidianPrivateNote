# 标准
基层工程师：基础知识
高级工程师：基础知识+项目经验
架构师：解决方案能力
# 内容
## 心态
1. 世上没有完美的人，也不要期望把自己变得什么都会。只要有那么一点价值，就可以大胆地发挥出来
## 面试
特点
	1. 经过组织者精心设计[^1] 
	2. 以交谈和观察为主要手段
		1. 表现得积极、向上、踏实、乐观
	3. 评价知识、能力、经验的综合素质。【老师教知识，能力只能看自己】
### 环节与流程
如何拿到面试机会【优先级】
	1. 员工内推
	2. 猎头推荐
	3. HR搜集（主动搜索，接收邮件）
中型以上，较为正规的的面试流程
	1. 技术一面
		1. 基础知识的深度和广度
		2. 框架基本使用
	2. 技术二面
		1. 框架高级特性、框架原理、计算机原理
		2. 项目经验，项目设计能力、问题的解决方案、工作环境
	3. 愿景三面
		1. 能为公司带来什么
		2. 如果有不足如何提升
	4. HR面【有一票否决权】
		1. 表现得阳光，积极，正面
		2. 踏实，谦卑
### JD分析
解读用人单位的招聘信息
	1. 职位描述
		1. 工作内容
		2. 技术栈
	2. 岗位要求
		1. 经验要求
不要过于在意JD【有时候看到JD会想要退却？】
	1. JD不是技术发布的
	2. 不要完全相信
解读
	1. 技术栈
	2. 平台：多终端？【web，移动端，微信】
	3. 性能优化
	4. 工作内容：有较好的抗压能力！
### 写简历
1. 内容【不用写个人爱好、自我评价之类的。顺序不要乱】
	1. 个人信息
		1. 姓名，性别，电话，邮件，籍贯【年龄可不写】
	2. 教育经历
		1. 写上最高学历即可
		2. 学校，专业，入学、毕业时间
		3. *不要写高中*，很不专业
	3. 专业技能
		1. 核心竞争力【不是你会别人不会的，而是你能满足用人单位要求】
		2. 3，5条即可
		3. 不要写太基础、细微的内容【会用vscode, git, echarts, lodash什么的】，会显得你档次低。
	4. 工作经历
		1. 公司，职位，入职/离职时间即可
		2. 存在空窗期，如实写即可。个人原因，自由职业等
	5. 项目经历【不要像工具经验一样逻辑，而是突出能力】
		1. 2-4个具有*说服力*的项目
			1. 重复的项目，不重要的不用写
		2. 项目描述，技术栈，个人角色【开发，管理】
		3. *可以写别人的项目，但你要能自圆其说*，真的理解了。
		4. 或者把其他项目的想法写在某个项目上。
	6. 博客和开源作品
		1. 需要有真内容
2. 要点
	1. 简洁，突出重点
	2. 界面不要花哨，
	3. 慎用“熟练”，“精通”
	4. 表现出优势
### 准备工作与注意事项
面试前的准备工作
	1. 看JD，是否需要临时准备
	2. 打印纸质简历，带纸笔
	3. 最好带自己电脑，现场可能写代码
	4. 不要迟到或早到
	5. 为何离职
		1. 不要吐槽前东家，【想找更好的发展】
	6. 能加班吗
		1. 能。除非你找到了不用加班的公司。
	7. 不要挑战面试官，即使他有问题。要愉快地度过这场面试
	8. 遇到不会的问题，要表现出积极的态度
		1. 去思考1、2分钟
		2. 问面试官“能不能给个引导”
		3. 我回去再研究研究。
	9. 平时怎么学习
		1. 视频，官方文档
	10. 你有什么缺点？
		1. 自己的小程序、性能优化、组件封装不熟练，最近正在学习小程序。
	11. **你有什么想问的吗？**
		1. 职责
			1. 我的日常*工作内容*是什么？如果我入职了，可能会负责哪块，主要做什么？
			2. 这是个*继续开发*的项目，还是*新*项目？
		2. 技术
		3. 业务
			1. 业务内容
		4. 团队
			1. 每次开发和上线流程分别是什么？
			2. 每天*预期工作时间*是多少小时？
			3. *团队规模*有多大，移动端有多少人、Android 端有多少人、测试怎么测
		5. 规划
		6. 待遇
			1. 值班或者遇到问题加班时候有*加班费*吗？
			2. 调薪一般是多久一次？
			3. 除了薪水外其他福利待遇有哪些，比如餐补
[面试过程中应该避免的几种情况（最后附送前端面试题）\_慕课手记](https://www.imooc.com/article/300475)  
## 技术
### [[HTML]] 
1. 如何理解语义化
	1. 由标签名可推测出内容的分类。增加**可读性**，利于开发维护【人读】和[[SEO]]【机读】。
2. 默认情况，哪些是[[块级标签]]，哪些是[[行内标签]] 
	1. display: block/table【div，标题，段落，表单，表格，列表】
		1. div, h1, p, form, table, ul, ol, li, hr
	2. inline/inline-block
		1. span, img, input, button, a, em, i, br, u, s
3. H 5新增元素
	1. header,  nav, aside, section, article, footer, figure
4. 表单元素有哪些
	1. value：input, select,  textarea
	2. checked：radio, checkbox
	3. form
### [[CSS]]【少量HTML，较多CSS】
1. [[布局]] 
	1. [[盒模型]]宽度如何计算
	2. 各种单位的区别[[属性值与单位]] 
	3. margin纵向重叠
		1. 如果**元素内容为空**，也没有设置高度。
	4. margin的四个方向负值会怎样
		1. top/left负值：元素向方向移动
		2. right/bottom：自身不动，右/下侧的元素向左/上移动对应负值
	5. [[BFC]]的理解与应用
	6. float[[布局]]，clearfix
		1. 如何实现[[圣杯布局]][^2]和[[双飞翼布局]]（PC 端常用的两个布局）
			1. 使用float布局
			2. 两侧使用margin负值，以便和中间内容*重叠*；
			3. 防止中间被两侧*覆盖*时，
				1. 圣杯布局。三个盒子的父盒子用 padding, 左右使用相对定位，分别向左和向右移动
				2. 双飞翼：中心区域盒子用 margin，左右两个都使用 margin-left 的负值【###】
			4. 具体
				1. 宽度左右 px，中间100%
		2. 两种布局的区别 [CSS系列之双飞翼布局与圣杯布局 - 掘金](https://juejin.cn/post/7141961493230125063?searchId=2023073023254320D4EA76E80D566036B7#heading-2) 
			1. [[双飞翼布局]] 使用了一个 div 包裹中间区域，可使用 margin 留出两侧空白
		3. 手写clearfix
	7. 居中布局？考虑浏览器兼容性？
	8. 多列等宽布局？多列等高布局？如何通过flex布局实现？
	9. flex画色子
		1. 画一个三个点的色子
2. [[定位]] 
	1. absolute，relative分别相对谁定位
	2. 居中对齐的实现方式
3. 图文样式
	1. lint-height的继承问题：[[CSS属性]] 
4. 移动端响应式
	1. rem是什么：[[属性值与单位]] 
	2. 如何实现[[响应式布局]] 
5. CSS3：flex, 动画
### [[JS]] 
1. [[数据类型]] 
	1. 值类型和引用类型的区别：[[变量]] 
	2. 类型判断instanceof
	3. [[操作符]]typeof判断的类型：8种
	4. 使用\=\==和\=\=的场景？只有需要判断\==null时 
	5. 手写[[深拷贝]] 
	6. 手写[[深比较]] 
	7. 列举强制类型转换与隐式类型转换的情况
		1. 隐式转换
	8. [[Array]]哪些方法影响原数组？
	9. [[Function]]声明与表达式的区别
	10. [[Object]] 
	11. 手写trim方法：[[string]] 
	12. 如何获取最大值
	13. 如何实现[[JS创建对象]] 
	14. 为何0.1+0.2 !\==0.3？
		1. 计算机进行数据的存储和运算时都用二进制。而 JS 使用64位双精度表示浮点数，在将浮点数转为二进制数进行运算时会出现误差
		2. 解决：
			1. 使用三方库 `mathjs` 【如果项目中需要许多浮点数计算】
			2. 项目决定精度后统一进行取舍
2. [[异步JS|异步]]，单线程
	1. [[event-loop]]、[[Promise]]。
	2. DOM事件与[[event-loop]]的关系
	3. DOM渲染与[[event-loop]]的关系
	4. 什么是宏任务、微任务？区别？
	5. 同步和异步的有什么区别？
		1. 是否会阻塞代码执行
	6. 前端使用异步的场景？
		1. 耗时任务
			1. [[网络请求]]，图片加载，大量计算
	7. 异步原理、进阶
3. class和[[JS创建对象]] 
4. [[原型对象]]，原型链
	1. 如何判断一个变量是不是数组？
		1. 类型判断instanceof，判断原型链上是否存在该原型对象
	2. [[class]]的原型 本质
		1. 类的本质是一个函数
5. [[作用域]]，[[闭包]] 
	1. [[this]]在不同场景下的取值
	2. 手写bind[[Function]] 
	3. 实际开发中闭包的应用场景
		1. 防抖，节流：[[工具函数]] 
		2. 隐藏数据，只提供部分API专用于修改该数据
		3. 在react应用的组件中，有些逻辑只需在项目初始化时加载一次，可使用闭包。因为如果在didMount中定义，页面刷新也会执行
6. 如何捕获JS程序中的异常？[[异常捕获]] 
7. 什么是[[JSON]] 
8. 如何获取[[URL]]查询参数
9. [[性能优化]]？一般从哪几个方面考虑？
10. 介绍一下[[requestAnimationFrame]] 
11. [[Map]]和[[Set]] 
12. [[WeakMap]]和[[WeakSet]] 
13. 手写[[工具函数]] ：实际不要手写，可能会出问题，尽量使用 [[lodash]] 等三方库
14. 箭头函数。
	1. 缺点。
		1. 没有 this。 不能使用 apply, call 绑定。
		2. arguments
	2. 不能使用的场景
		1. 因为内部没有 this
			1. 不能作为构造函数、原型上的方法
			2. 不能作为对象的方法
			3. DOM 绑定的事件回调函数
15. for/in 与 for/of 有什么区别？
	1. 目标
		1. 前者：可枚举。[[Object]] ,[[Array]] , [[String]] 
			1. \[\[Enumerable]] 特性
		2. 后者：可迭代。[[Array]] ，[[String]] ，部分[[数据类型#集合引用类型【7个】|集合引用类型]]、生成器函数【出现 [[async]] 后不再常用】
			1. [[Symbol]].iterator 属性
	2. 结果
		1. 前者遍历 key，后者 value
16. for await...of 的作用：遍历多个[[Promise]] 
	1. 与 Promise.all 的区别？
17. [[HTMLCollection]] 与[[NodeList]] 有什么区别？
	1. 前者是 Element 节点类型的集合
	2. 后者是 Node 节点类型的集合
	3. [[类数组对象]] 
18. [[严格模式]]的特点
19. JS 内存泄漏
	1. 如何检测内存泄漏/内存变化？
		1. 使用 [[Chrome Devtools]]中的 Performance，
		2. 勾选 `memory` ，点击增加回收，点击 `record` 后，开始执行代码，
		3. 执行结束后可察看 heap 内存占用的变化
			1. 如果是波形图，则是正常的，如果是逐渐增加，说明存在内存泄漏。
	2. 场景
		1. 数据被全局变量/函数、DOM 事件、定时器、自定义事件引用，组件销毁时未清除
	3. 闭包是内存泄漏吗？
		1. 闭包是 JS 解析函数内变量的机制，内存泄漏是占用内存的数据无法被清除导致的后果。
		2. 滥用闭包是导致内存泄漏的原因之一
	4. 相关：[[WeakSet]], [[WeakMap]] 
20. [[JS垃圾回收机制]] 
21. 浏览器与 [[node]]的事件循环有什么区别？
22. 遍历数组，for 和 forEach 哪个快？
	1. for 循环更快。
		1. forEach 每次循环都要创建一个函数来调用
		2. 函数需要独立作用域，会产生额外开销
	2. 循环 vs 递归
		1. 递归每次都要创建函数
23. [[requestAnimationFrame]]和 requestIdleCallback 的区别？
	1. 都是宏任务
	2. 优先级：RAF 高，每次渲染完毕都会执行。RIC 低，空闲时才渲染
24. 如何实现网页多标签页通讯？【一个页签中的消息被阅读，另一个标签中的未读消息数量自动减少（不需要主动刷新）】
	1. [[WebSocket]]：无跨域限制，但需要服务端支持，成本高
	2. [[localStorage]]：同域限制。A 页面存储 local，B 页面监听 storage 事件，通过参数的 key,value 接收到 A 页面存储的 item 的 key 与 value。
		1. 如果 value 设置的是相同值，则不触发该事件。
	3. [[SharedWorker]] 通讯。[[WebWorker]]的一种
	4. 对比：![[Pasted image 20230803174857.png]]
25. 页面和 [[iframe]]如何通讯？窗口对象[[window]]的[[postMessage]]方法
	1. message 事件接收。[[postMessage]](信息字符串， 域名【一般是'\*'】) 
	2. 页面向 iframe 发送消息的关键： `window.iframe1.contentWindow.postMessage('我是主页发送的消息', '*')` 
	3. iframe 向外部页面发送消息： `window.parent.postMessage('我是iframe页面发送的消息', '*')` 
### [[计算机网络]] 
1. [[HTTP]] 
	1. 常见[[HTTP状态码]] 
	2. 常见[[HTTP Header]] 
	3. [[HTTP Method]] 
	4. 什么是[[RESTful API]]。说出本质即可
	5. 描述一下[[HTTP缓存]]机制
	6. [[协议]]和[[规范]] 
	7. [[HTTPS]] 
	8. 三握四挥：[[TCP]] 
2. 解释[[JSONP]]的原理，为何它不是真正的ajax？
	1. 因为没有用到XHR
3. [[AJAX]]：[[网络请求]] 
	1. 使用 XHR 实现 ajax，并发起请求
	2. [[同源策略]]。跨域的常用实现方式
	3. HTTP 跨域请求时为何发送 options 请求？
4. [[网络请求#XMLHttpRequest 对象|XHR对象]], [[axios]], fetch 的区别
	1. XHR【甄姬关配，】一种 API
		1. 首先，它们不是同一个维度的概念。
			1. [[AJAX]] 是一种技术统称，而 fetch 与 axios 是两种可直接使用的工具。
		2. 特性
			1. 基于原生 XHR 开发，XHR 本身的架构不清晰
			2. 针对 MVC 编程，不符合前端 MVVM 的浪潮
			3. 不符合关注分离（Separation of Concerns）的原则
			4. 配置和调用方式非常混乱，而且*基于事件的异步模型*不友好
		3. 功能：请求的取消、超时控制、进度监控
	2. [[网络请求#Fetch API|fetch]] 
		1. 优点【PA 一只手拖鱼，一只手扣百度】
			1. 基于标准的[[Promise]] 
			2. 更底层，API丰富。
			3. 浏览器提供的规范底层 API，*脱离了 XHR*，是 ES 规范里新的实现方式
			4. 语法简洁，语义化
		2. 缺点
			1. cookie。默认不带cookie，需要配置 `fetch(url,{credentials: 'include'})` 
			2. 请求失败。只对网络请求报错。
			3. 不能检测请求进度、超时控制、取消。XHR 可以
	3. [[axios]] ：一种用于网络请求的三方库【没有基础的 API，是无法实现库的】
		1. P 端蓝转消
5. 实现用户登录验证的方案？
	1. cookie + session
	2. [[JWT]] 
6. [[网络请求]]中 [[cookie]] 与 token 有什么区别？【[[客户端存储]]】【背景，存储，传输】
	1. 目的相同，是两种保存认证凭据的方式。
	2. 背景：cookie 是 [[HTTP]]规范，token 没有标准，是自定义传递。
	3. 存储
		1. 位置与内容
			1. cookie 在客户端存储的是用户标识，在服务端存储的是用户信息。token 在客户端存储的是用户所有信息
		2. 方式
			1. cookie 默认会被存储，token 需要通过 [[Web Storage]]*手动*存储
	4. 传输：前者只要是符合限制，就自动传递。后者需要*手动*赋值，不添加就不传递。
	5. 限制：token 没有*跨域*限制。
7. session 和 JWT 哪个更好？
	1. session 
		1. 优点
			1. 原理简单，易于学习
			2. 用户信息存储在服务端，可*快速封禁*某个违规用户
		2. 缺点
			1. 用户较多时，*占用服务端内存*，硬件成本高
			2. *多进程，多服务器*时，不好同步。需要使用第三方缓存，如 [[Redis]] [^9] 
				1. 第三方缓存是内存级别的第三方缓存，可将多个进程的 session 全放在该缓存中。但需要成本。
			3. cookie 有*跨域限制*
	2. JWT 
		1. 优点
			1. 不使用服务端内存
			2. 多进程、多服务器不受影响
			3. 没有跨域限制
		2. 缺点
			1. 用户信息存储在客户端，违规用户无法快速封禁
			2. 如果服务端加密的*秘钥*泄漏，则用户信息全部丢失
			3. *体积*一般大于 cookie，会增加请求的数据量。
	3. 结论
		1. 如果有严格管理用户信息的需求，使用 session
		2. 如果没有特殊要求，可使用 [[JWT]]（如创业初期的网站，可降低成本）
8. 如何实现 [[SSO单点登录]]？
	1. 如果主域名相同：基于 [[cookie]]。
		1. 默认不跨域，主域名相同时可设置为（子域名）共享。如 `www.baidu.com` 与 `image.baidu.com` [^10] 
	2. 如果主域名不同
		1. [[SSO单点登录]]技术方案
		2. [[OAuth 2.0]]技术方案
9. HTTP 协议与 [[UDP]] 协议有什么区别？[[计算机网络#计算机网络协议|计算机网络协议]] 
	1. 层级不同：HTTP 在[[应用层]]，TCP 和 UDP 在[[传输层]]  [[TCP IP协议群]]、[[OSI协议簇]] 
	2. 稳定与效率的取舍
	3. [[TCP]]：有*连接*的建立与断开，*稳定*传输。
		1. 适用于网页等
	4. [[UDP]]：*无连接*的建立或断开，*不稳定*传输，但*效率高*。
		1. 适用于<u>视频</u>会议、<u>语音</u>通话【光靠无法实现】
10. [[HTTP]]与[[WebSocket]]有什么区别？
11. [[HTTP]]协议1.0，1.1，2.0有什么区别？
	1. [一直在学https和http2协议，那你知道怎么给网站开启吗? - 掘金](https://juejin.cn/post/7253734111664046140) 
	2. 1.0是最基础的 HTTP 协议，只支持基本的 GET,POST [[HTTP Method]]。基本所有网站已经弃用
	3. 1.1【方形的头发，缓虫，断点，连接】
		1. 支持*新方法* PUT，DELETE 等，可用于 [[RESTful API]]。
		2. 增加*缓存策略*：cache-control, e-tag 等
		3. 支持*长连接*：connection: keep-alive，
		4. *断点续传*，状态码206
	4. 2.0【二刀流，压缩送腿】
		1. *二进制协议*。HTTP/2 是一个二进制协议。HTTP/1.1 中报文请求头必须是<u>文本</u>（ASCII 编码），请求体可以是<u>文本或二进制</u>。HTTP/2 则是一个彻底的<u>二进制协议</u>，头信息和数据体都是二进制，并且统称为"帧"，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础。
		2. *多路复用* 。HTTP/2 仍然复用 TCP 连接，但是在*一个 TCP连接*里， 客户端和服务器都可以*同时发送多个*请求或回应，而且不用按照顺序一一发送，这样就避免了"队头堵塞"的问题
		3. *数据流*。HTTP/2 使用了数据流的概念，因为 HTTP/2 的<u>数据包是不按顺序发送</u>的， <u>同一个连接里面连续的数据包， 可能属于不同的请求</u>。因此，必须要对数据包做标记，指出它属于哪个请求。HTTP/2 将*每个请求或响应的所有数据包*，称为一个<u>数据流</u>。每个数据流都有一个独一无二的<u>编号</u>。数据包发送时，都必须标记数据流 ID ，用来区分它属于哪个数据流。
		4. *服务端推送*。现在的服务端推送大部分是使用[[WebSocket]]，很少使用 [[HTTP]]进行 web 推送。
		5. 可*压缩 header* 
			1. 背景
				1. 由于 HTTP 1.1 协议<u>不带状态</u>，<u>每次请求都必须附上所有信息</u>。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，浪费带宽，也影响速度
			2. 过程
				1. 头信息使用 gzip 或 compress 压缩后再发送；
				2. 客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了
12. 什么是 HTTPS 中间人攻击？如何预防？
13. script 标签的 defer 与 async 有什么区别？
	1. 都是*异步加载*（加载就是下载的意思） JS，区别在*执行时机*。
		1. async 是加载完成后立即执行（此时 HTML 解析暂停）
		2. defer 是延迟执行（ HTML 解析完成后）
	2. ![资源加载](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/15a0fa4709a2484db4b13c2009da9de6~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)
14. prefetch 与 dns-prefetch 有什么区别？[[prefetch与preload.png]] 
	1. 都是加载资源，区别是*加载优先级*不同【不会执行】
		1. preload：浏览器*立即*加载资源，在当前页使用。优先级为 Highest
		2. prefetch：浏览器*闲时*加载资源，在未来页面使用。优先级为 Lowest
	2. dns-prefetch 与 preconnect 有关
		1. dns-prefetch：[[DNS]] 预查询
		2. preconnect：DNS 预连接
		3. 使用：[[preconnect.png]] 对于之后访问的页面，提前[[DNS]]查询。
15. *前端攻击*的常用手段？如何预防？
	1. [[CSRF]]：诱导用户点击链接，链接中有其他请求
	2. [[XSS]]：用户输入内容展示在网站页面上
	3. [[DDOS]] 
	4. [[Click Jaking]] ：点击劫持
	5. [[SQL 注入]] 
16. [[WebSocket]]与[[HTTP]]有什么区别？
	1. [[WebSocket]] 
		1. 支持*端对端通讯*。通讯可由 client 发起，也可由 server 端发起。
			1. 可用于：直播间讨论区，聊天室，协同编辑
		2. <u>协议名</u>是 ws://
		3. 通过 send 与 onmessage <u>通讯</u>。（http 通过 req 与 res）
		4. 没有跨域<u>限制</u>
		5. *升级*为 wss
17. [[WebSocket]]与 [[HTTP]]长轮询的区别？
	1. 长轮询[^11]：客户端发起请求，服务端阻塞/等待，不会立即返回。等收到消息时再返回给客户端【单端阻塞】
	2. 双端通讯：双端都可发起请求，没有阻塞【双端即时】
18. [[Koa]]的洋葱模型？
19. 移动端 [[HTML5]]点击有300ms 延迟，如何解决？
	1. 背景：double tap to zoom
	2. 初期解决方案： `FastClick` 库。
		1. 监听 `touchend` 事件
		2. 使用自定义事件模拟一个 click 事件
		3. 把默认的 click 事件（300ms 后触发）禁止
	3. 现代浏览器的改进
		1. 有这个属性，就不会有问题。浏览器认为点击时不再需要300ms 延迟![[Pasted image 20230801192644.png]]
### web api
1. [[DOM]] [[BOM]] 
	1. DOM是哪种数据结构
	2. DOM操作常用的API
	3. attribute与property的区别
		1. 含义
			1. attribute
				1. HTML*标签的属性* 
				2. 是节点类型中的Attr类型
				3. getAttribute可取得HTML属性和自定义属性
			2. property
				1. DOM将HTML标签表示为*元素对象的属性* 
				2. 是节点类型中的Element类型对象的属性
		2. 修改。
			1. 因为attr是html文档上标签的属性，而props是DOM对HTML文档的*结构化表示*后对象的属性。所以修改attr会同步到props，但修改props只是修改了该结构化表示的对象，所以props的修改不会同步到HTML文档的标签上。
			2. 更改property和attribute上的任意值，都会将*反映到HTML页面*中
	4. 一次性插入多个DOM节点，考虑性能
	5. 事件代理是什么。多个事件绑定同一个事件处理函数:[[DOM事件]]  
		1. 当有许多事件处理函数，且处理逻辑比较相似，可利用事件冒泡机制，将事件绑定在公共父节点上，只设置一个事件处理函数，通过event.target判断触发元素选择逻辑。
		2. 场景：瀑布流。
	6. 如何识别浏览器的类型
	7. 如何减少DOM操作
		1. 缓存DOM查询结果、多次操作一次插入
	8. 分析拆解URL各个部分
	9. [[document]] load和ready的区别？【ready就是DOMContentLoaded】
		1. 一般CSS在DOM前，JS在DOM后。所以ready一般是只剩JS没有执行。
2. [[Function]] 
	1. call与apply区别
	2. [[闭包]]定义，特性：基于[[作用域]] 
3. [[JS事件]] 
	1. 编写一个通用的事件监听函数：[[DOM事件]] 
	2. 事件冒泡流程
		1. 基于DOM树形结构，从触发元素开始向上级元素冒泡。
		2. 应用场景：事件代理
	3. 无限下拉的图片列表，如何监听每个图片的点击
		1. 事件代理。用e.target获取触发元素，用matches判断是否是触发元素
	4. 如何阻止事件冒泡和默认行为。
4. [[客户端存储]] 
	1. 描述[[cookie]], localStorage, sessionStorage区别【容基操】
		1. 容量
		2. 机制：生命周期、是否发送
		3. 操作方式：通过API，直接赋值。
### [[浏览器]] 
1. [[浏览器原理]] 
	1. 输入 [[URL]]到渲染的过程
	2. 重绘与重排
### 开发环境
1. [[版本控制|版本管理]]，[[git]] 
2. [[调试]] 
3. 抓包 [[抓包工具]] 
4. bug解决
5. 如何连接测试机服务器
6. [[ES Module]]、[[模块]]、[[模块化]] 、[[js模块化]] 
7. 你常使用的[[ES6新特性]]有哪些？
8. [[linux]]常用命令：本地无法复现，测试、线上可复现
9. 线上环境出问题如何解决
10. 如何登录线上机，线上机有一个文件如何编辑？
### [[运行环境]] 
需要保证代码在浏览器中：稳定且高效
1. 网页加载过程。页面渲染。[[浏览器原理]] 
	1. 从输入[[URL]]到渲染出页面的整个过程
	2. onload事件和DOMContentLoaded事件的区别
		1. 是window对象上的，所有资源加载结束
		2. 是document对象上的， DOM渲染完即可。
	3. 为何把CSS放在HEAD材中
2. [[性能优化]] 
3. [[前端安全]] 
### [[设计模式]] 
[[OO设计模式]] 
### [[库、框架]]  
## [[vue]] 
1. 什么是[[组件化]] 
2. 如何理解 [[MVVM]] 
3. 监听data变化的核心API？
4. 如何深度监听data变化
5. vue如何监听数组变化
6. v-dom。
	1. 原理
	2. diff算法 
7. vue模板被编译成什么？
8. vue组件可用render代替template
9. 组件是如何渲染、更新的？
10. 如何异步渲染的？
11. 如何用JS实现hash路由
12. 如果用JS实现history路由
13. 列表渲染为何使用key
14. data为何是函数
15. 何时使用keep-alive、beforDestory
16. diff算法的时间复杂度
17. [[vue性能优化]] 
##  [[react]] 
1. 组件如何通讯
	1. props，context，[[redux]], 自定义事件
	2. [[context]] 场景。
	3. 复杂的公共信息 (业务的数据比较复杂)，使用redux
2. [[JSX]] 本质是什么 
3. 什么是[[纯函数]] 
4. 列表渲染为何使用key。[[react原理]] 
	1. 如果没有匹配到 key，会进行删除重建。如果匹配到，只需要移动。删除重建是性能较差的。
5. portals 场景
	1. 需要将组件渲染到父组件之外：全局的提示，Modal 框。
		1. 把 fixed 定位的元素放到 body 上，有更好的浏览器*兼容性*。
	2. 父组件是 [[BFC]] ， *z-index* 太小等布局问题
6. 异步加载组件
	1. 场景：懒加载，组件较大
	2. 方式
		1. import ()
		2. React. lazy
		3. React. Suspense
7. [[class组件#生命周期]]  
	1. 父子组件生命周期
8. [[性能优化]] ：永远是面试的重点。因为性能优化相对 [[vue]] 而言，对 [[react]] 更加重要。[[React性能优化]] 
9. setState是同步还是异步？[^3] 
	1. ![[Pasted image 20230706165259.png]]
	2. 异步：在setState后读取state，是原值
		1. 可通过this.setState({},fn)的第二个参数拿到最新
	3. react 17之前：在定时器、[[DOM事件]]中，是同步的。上面的图片打印是0,0,2,3
	4. react 17之后：定时器、DOM 事件中也是异步的
10. 何时会合并 setState
	1. 传递对象时合并。相当于assign，对象会覆盖相同的属性名
	2. 传递函数时不合并
11. 函数组件与 class 组件的区别
	1. 
12. [[React与Vue的比较]] 
13. 什么是受控组件
	1. 需要通过自定义state、创建修改state的函数来控制*表单组件*的值的方式来管理输入
14. 什么是非受控组件？使用场景？
	1. *文件*上传：input type=file
	2. *富文本*编辑器，需要传入 DOM 元素
	3. 必须手动操作 [[DOM]] 元素，setState 无法实现
15. 何时使用异步组件？
	1. 路由[[懒加载]]、组件较大
16. [[class组件]]的 this 绑定方式？
17. class 组件的构造函数是必须的吗？
	1. 如果存在只需要执行一次的*初始化逻辑*，则必须。
18. 如何抽离组件的公共逻辑？
	1. class组件
		1. 什么是 [[react组件#HOC|HOC]]  ？
			1. 模式简单，但增加组件层级
		2. renderProps
			1. 代码简洁。
				1. 定义时：定义逻辑、接收 UI 并传入逻辑
				2. 复用时： 函数接收逻辑，返回展示组件
		3. mixin已废弃
	2. [[函数组件]] ：自定义hook
19. [[redux]] 
	1. 描述 [[redux]] 单向数据流
	2. action 如何处理异步？
	3. 描述[[中间件]]原理
20.  [[react原理]] 
	1. DOM 事件与 react 事件的区别？
	2. vdom 比操作 DOM 更快吗。
		1. 当需要操作的 DOM 很少时，不如直接操作 DOM。因为不用生成 vdom，也不用 diff 和 patch，尤其是初次渲染时。
			1. 数据驱动视图需要合适的技术方案，不能全部 DOM 重建。
		2. vdom 的核心优点是不用直接操作 DOM、抽象性带来的跨平台。
		3. svelte 并不使用 vdom。[[svelte.png]] 
21. react数据持久化有什么实践？
	1. 简单封装localStorage的方法
	2. 使用redux存储的全局state在刷新时会消失。所以登录信息等需要持久化。
		1. 会想到localStorage，但再使用它会导致数据的存储地点较多，难以维护。
		2. 使用[[redux-persist]]库
22. 对 [[React-SSR]] 的理解？
23. 高阶组件使用了什么[[OO设计模式]] ？ [[装饰器模式]] 
## [[react-router]] 
1. 如何配置懒加载？react. lazy 和 suspense 结合，通过 import 引入
## [[函数组件]]  
1. 为什么会有 hooks？它解决了哪些问题？
	1. 完善函数组件的能力，在函数组件中引入了状态、副作用等特性。需要引入状态或副作用时不再需要重构为 [[class组件]] 
	2. [[react组件|组件]]的逻辑复用
		1. 不用记忆特定的模式
		2. 减少组件嵌套层级
	3. [[class组件]]本身的问题
2. 如何模拟组件生命周期？
3. 自定义 hook?
	1. 为何？封装通用功能
	2. 意义
		1. 带来了无限的*扩展性*，解耦代码
		2. 封装通用功能
	3. 如何封装一个 useAxios？![[Pasted image 20230729202501.png]] 
4. hooks [[react性能优化]] 
5. hooks 遇到的坑
	1. *useState 初始值*只有第一次渲染时有效
		1. 如果初始值使用了一个 props，后续组件更新时 state 是不会自动更新的
	2. *useEffect 的捕获与更新*：在 useEffect 中定义的定时器，没有按照预期自增。
		1. 原因：定时器中的变量是被 useEffect 捕获的变量，拿到的始终是刚定义时传入的值
		2. 方案
			1. 不使用依赖数组：会重新执行副作用添加函数
			2. 在外部使用 useRef 重新捕获
	3.  hook 的*依赖项*存在引用类型，会导致死循环。
6. 逻辑复用
	1. [[class组件]] 的 mixins 为何废弃？
		1. 变量*作用域*来源不清
		2. *属性重名* 
		3. mixins 引入过多会导致*顺序冲突* 
	2. 逻辑复用相比 HOC 和 renderProps 有哪些优势？
		1. HOC
			1. 嵌套过多，不易渲染、调试
			2. HOC 会劫持 props【本质是在原来的组件上追加一个属性】
		2. rp：
			1. 只能传递纯函数，默认情况下纯函数功能有限【接收状态的 UI 函数】
		3. 优势
			1. 不会增加嵌套，
7. useReducer 能否代替 [[redux]] ？有什么区别？
	1. 前者是 useState 的替代方案，仍是*单组件*内的状态管理
		1. 【那我把 useReducer 放到最外层不是就可以管理整个项目了？】那子组件修改状态时怎么办？通过 props 一级一级地把方法往下传递？
			1. 【通过 [[context]] 传递】
	2. 后者是全局的状态管理，*多组件*共享数据
	3. 可通过在根组件内使用 useReducer+useContext 的方式代替 [[redux]] ，
		1. 但当需要进行**异步 dispatch** 时，就需要借助 redux 中间件了，这个 useReducer 无法实现
		2. 适用场景：项目较小【大型的项目仍需要 [[redux]] 】
	4. 结论。在小型项目中可替代，大型项目中还是需要 redux
## [[webpack]] 
### 问题
1. 它是成熟的工具，重点是配置和使用，原理并不重要。
	1. 不了解配置，只会用cli工具创建项目。
2. 前端为何要进行[[构建]]？【代码：体积更小，高级语法，错误检查；研发流程：开发环境，构建流程，构建规范】
	1. 代码层面
		1. [[预处理器]]。高级语法、预处理器（ES6, TS, 模块化，LESS）的*编译* 
		2. 代码压缩。*体积*更小，加载更快
		3. 后处理器。兼容性与*错误*检查
	2. 研发流程层面【高级程序员，不能只考虑代码层面，还会关注人、团队、流程】
		1. 统一高效的*开发环境、构建流程、产出标准*。
		2. 集成公司*构建规范*（提测、上线等）
3. 大概的构建流程？[Webpack完整打包流程分析 - 掘金](https://juejin.cn/post/7163528496487071758?searchId=2023072113185556B656C79D5337A017FD#heading-7) [^8] 【初始化，编译，生成，写入】【出屎，便秘，生疼，血入】
	1. 初始化【CPC】
		1. 创建 *compiler* 对象
		2. 读取与合并*配置*信息
		3. 初始化默认*插件*。
			1. 有 compiler 实例对象后，就可以<u>注册</u>配置文件中的<u>插件</u>，在打包构建过程中选择合适的时机来添加操作
	2. 编译，build
		1. *读取*入口文件内容
		2. 调用 loader *转换*模块内容
		3. 借助 babel 解析为 AST *收集*依赖模块
		4. 如果存在依赖，递归对依赖模块进行以上操作（读取，转换，收集）
	3. 生成，seal
		1. 生成 chunks对象，对 chunks 进行一系列的优化操作，并生成要输出的代码
		2. 生成 assets 对象
	4. 写入，emit
		1. assets 上已经拥有了*最终打包后的代码内容*，最后要做的就是将*代码内容写入到本地磁盘*之中
4. 为何[[Proxy]]不能polyfill？
	1. [[Proxy]] 的功能无法使用Object.defineProperty实现
5. module, chunk, bundle分别是什么？区别？ 
	1. module：每个源码文件。src中的每个文件，除html文件
	2. chunk：多模块合并的结果。如入口文件，动态/异步加载模块，分包。根据来源可分为3种chunk，
		1. 是**对module进行分类重组的结果**。
			1. 需要在依赖关系中*直接打包*在一起的module
			2. 需要被*异步加载*的module
			3. 需要被*多次引用*的module打包为一组chunk
				1. [[vendor]], common, style
	3. bundle：最终打包的输出文件。
		1. 是chunk的子概念，一个chunk可能产生多个bundle。
			1. js文件、如果需要映射源码位置，则打包结果还需要map文件
6. loader与plugin区别？
	1. loader只负责编译时的*源码*的解析与处理【文件处理层面】
	2. plugin可在整个编译流程的不同*时机*添加处理【流程进行层面】
		1. 文件提取
		2. 构建、压缩
7. 常见loader与常见plugin
	1. loader
		1. 样式、图片、字体：less, css, style, scss, file, url, [[PostCSS]] 
		2. 语言层面：babel-loader, 
	2. plugin
		1. [[HTML]] 
			1. htmlWebpackPlugin：根据模版生成 HTML
		2. [[CSS]] 
			1. MiniCssExtractPlugin：提取
			2. CssMinimizerWebpackPlugin：压缩
		3. [[JS]] 
			1. TerserWebpackPlugin：压缩 JavaScript 文件
		4. 全局
			1. CompressionWebpackPlugin：通过命令行 gz *压缩静态资源*包大小，提升前端加载性能与速度。该插件需要在服务端代理服务器（如 Nginx）支持 gzip 压缩配置
			2. DefinePlugin
		5. [[开发流程]] 
			1. HotModuleReplacementPlugin
		6. 构建流程
			1. IgnorePlugin：构建过程中忽略（第三方模块的）指定目录
			2. SplitChunksPlugin：分包
			3. DllPlugin：将可共享且不经常改变的代码，抽取成一个共享的库，避免进行二次构建
		7. 构建结果
			1. WebpackBundleAnalyzer
8. 与babel区别？
	1. 一个是插件化的代码构建工具，
	2. 一个是编译器主要负责语法转换，polyfill
9. [[webpack]]如何实现懒加载？
	1. `import()`结合vue react异步组件
	2. 结合各自框架的router库，异步加载路由
10. 如何产出一个lib？
	1. 在output配置的library字段，设置当前lib的全局变量名
	2. 使用babel/runtime，重命名变量名（特殊化处理避免冲突）
11. 了解过webpack5吗？
	1. 主要是**内部效率**的优化，使用方式没有太大变化。
12. 什么是tree-shaking
	1. 打包模块时，忽略导出却未使用的方法。
13. [[ES Module]] 与[[CommonJS]] 区别？
	1. 前者是**静态引入**，*编译*时引入【无条件，无异步地直接引入。不通过语句进行条件引入】
		1. 动态引入会在编译时报错。
		2. 只有前者可进行静态分析，实现[[Tree-Shaking]] 
	2. 后者是**动态**引入，*执行*时引入【代码执行时才知道引入的是什么。webpack打包并不执行代码，只是静态分析，无法确定模块引用关系】
14. 什么是 scope hoisting
	1. 改变打包结果。【代码体积越大，效果越好】
		1. 开启前。n个模块文件的内容打包出n个函数。创造许多函数作用域
		2. 开启后。n个模块文件的内容打包在1个函数中执行
	2. 优点
		1. 代码体积，创建函数作用域更少
15. 什么是[[babel]]，什么是babel-polyfill？babel/runtime与babel/polyfill的区别？
	1. babel-polyfill
		1. 在babel7.4之后被弃用。因为它只是[[core-js]]与[[regenerator]]的合并，建议直接使用二者
			1. 如果是开发三方库，必须使用
		2. 非常大，只使用了几个feature不必引入全部polyfill，如何按需引入？
			1. [[使用版本为3的core-js.png]] 
		3. 缺点
			1. [[污染全局环境.png]] 
				1. 如果只是做一个web系统，可以
				2. 如果想定义一个三方库，则可能出现覆盖。那怎么办？---名称不使用官方常用名
	2. babel/runtime：**变量全局环境污染问题**，将polyfill的api修改命名。如将Promise修改为_Promise。
		1. 使用默认配置即可。
16. module.noParse与IgnorePlugin区别？
	1. 前者
		1. 针对需要出现在打包结果中的模块，只是不使用loader解析。如Jquery.js, react.min.js。【不需要压缩，没有其它依赖】
	2. 后者
		1. 针对不需要出现在打包结果中的模块
17. CRA项目如何修改webpack配置？
	1. 执行项目 eject
	2. 创建项目时使用自定义 scripts 包
	3. [[react-app-rewired]]。不用eject，也不用创建scripts包
18. [[react-app-rewired]] 依赖的webpack版本是4.42.0，但mini-css-extract-plugin需要4.46.0。
### 配置   
1. loader
	1. 配置项？
		1. test: 匹配处理文件扩展名的的正则表达式；
		2. include: 对指定类型模块处理时，只处理该文件夹；
		3. exclude: 对指定类型模块处理时，只排队该文件夹；
		4. use: 指定处理文件时要使用的模块（loader?）名称；
		5. options: 为loader提供额外的配置选项。
	2. text，include与exclude区别？
		1. e优先级最高。如果i和e冲突，则执行e。
		2. **e和i只写一个即可**。
2. 基本配置
	1. 安装配置
	2. 拆分配置与merge。
		1. 减少配置文件的重复代码。通过`webpack-merge`包，可将webpack配置文件拆分为公共部分、dev环境配置文件、prod环境配置文件
		2. 开发环境直接引入url，生产环境通过loader转换图片为base64格式
		3. 开发环境特有：dev-server
	3. dev-server
	4. 解析
		1. [[ES6新特性]] [[webpack配置babel.png]] 使用babel需要配置.babelrc文件 [[Pasted image 20230717234614.png]] 
		2. 样式  [[样式文件的loader配置.png]] 
		3. 图片文件
			1. [[开发环境图片引入配置.png]] 
			2. [[生产环境图片引入配置.png]] 
				1. 根目录一般只放html文件
				2. 以base64形式产出一个图片，可减少一次网络请求。做成[[base64]]编码，写在代码中了。
		4. 其他文件
			1. [[使用file-loader打包图片与icon.png]] 
	6. 在webpack下如何跨域请求其他接口？
		1. 开发环境可使用配置中的proxy字段。如果本地服务端口是8080，服务端端口是3000，[[webpack开发服务器跨域.png]] 
3. 高级配置[^4] 
	1. 多入口
		1. 项目有多个html文件。虽然是SPA，但有时需要产生多个HTML。
		2. 添加入口文件。[[Pasted image 20230718144735.png]] 
		3. 每个入口都需要一个html-webpack-plugin实例 [[Pasted image 20230718144849.png]] 
			1. chunks字段的意义：指定当前html分别需要引入的chunk（JS文件）。如果不写，会引入所有入口JS文件。
		4. 根据入口名字，修改output的文件名[[Pasted image 20230718144647.png]] 
		5. 每次打包前清除dist中上次打包结果[[Pasted image 20230718150758.png]] 
	2. 抽离和压缩CSS
		1. 开发环境，只使用css-loader、style-loader没关系，但生产环境需要抽离和压缩：把样式代码专门放入CSS文件并压缩
		2. 抽离。使用loader和plugin [[CSS抽离插件的注册.png]]  [[CSS抽离插件的使用.png]] 
		3. 压缩 [[Pasted image 20230718153217.png]] 
	3. 抽离公共代码
		1. 被多次引用的三方库/模块，单独抽离，避免打包时被打包多次，在结果中出现很多重复代码。
			1. 抽离之后，成为独立的chunk文件，被单独引入。始终命中缓存
			2. 不会在每次修改业务代码后，再次打包并没有变化的三方库代码
			3. 打包后的bundle不再那么臃肿，包含所有没有必要重新打包的代码（因为没有修改）。
		2. 拆分逻辑【生成chunk】：optimization.splitChunks [[Pasted image 20230718155907.png]] 
		3. 引入拆分【引入chunk】：[[Pasted image 20230718160003.png]] 
	4. [[懒加载]]/异步加载模块
		1. 异步引入 [[Pasted image 20230718160546.png]] 
			1. 浏览器会在1.5s后请求一个chunk
		2. 默认支持，不需要额外配置。
	5. 处理react和vue
		1. 处理JSX：配置@babel/preset-react即可
		2. 处理vue：vue-loader，添加处理 [[vue-loader.png]] 
###   [[webpack#优化：13种]]  
1. 优化
	1. 构建速度：**减少内容，增加速度，缓存。刷新，替换，动态链** 
	2. 产出结果：**to be muscle 清除IC，老公飞楼坠[^7]** 
2. 优化构建速度【1-3可用于生产，后续只用于开发】
	1. 减小打包内容或解析内容
		1. 去除**部分无用**模块，ignorePlugin。比如moment支持多民族语言，默认引入所有语言的JS代码。如项目仅支持中文和英文，只引入两种语言即可。
			1. [[忽略文件夹.png]] 
			2. [[手动引入所需语言.png]]。
			3. 最终打包结果从263k变为55k
		2. 不解析。module.noParse：[[不需要解析的模块.png]] 让 Webpack 去解析这些**有用，但不需要构建**的模块，既耗时又没有意义。忽略的文件中不应含有import , require, define等导入机制。忽略大型的 library 可以提高构建性能
			1. *已经打包*，不需要再次打包的文件。react.min.js
			2. *没使用模块化*的文件。 jQuery、ChartJS 
				1. *没有依赖*其他模块的模块。lodash 
		3. 排除**不需要处理**的文件。使用`babel-loader`处理JS文件时，排除node_modules。【为何？】
		4. 使用外部CDN。externals，打包时排除某个依赖，因为从CDN使用，不用打包[[使用CDN引入不希望打包的依赖.png]] 
			1. 卸载对应依赖，【web应用别用！配置比较复杂】
			2. 对于开发库是最有用的。也有应用使用
	2. 增加打包速度
		1. happyPack【webpack5 已弃用】：**多进程打包**。特别是多核CPU，对处理多进程有优势
			1. 如果只想在生产环境使用，放在prod文件即可。也可放在common配置文件中，在开发和生产环境打包时同时使用
			2. [[处理JS文件时修改Loader.png]] 领悟：可通过plugin调用Loader处理模块
			3. [[添加happyPack插件配置.png]] 
		2. thread-loader。配置在 thread-loader 之后的 loader 都会在一个单独的 worker 池（worker pool）中运行
		3. ParallelUglifyPlugin：**多进程压缩**JS。webpack内置uglify工具压缩JS，但是单线程的。PUG与HP原理相同
			1. 只需放在生产环境的构建配置，因为开发环境不需要压缩。
				1. 如果项目较小，就不需要，因为存在进程开销，开启多进程会降低速度。
				2. 项目较大，打包较慢时开启多进程可提高构建速度
	3. 缓存
		1. babel-loader 。[[缓存babel对js的编译结果.png]] 
			1. 结论：所有loader都可**缓存**处理结果
		2. cache-loader。缓存其他loader的处理结果【能否生产使用？】
	4. 自动刷新[^5] 
		1. [[Pasted image 20230719193141.png]] 开启dev-server会自动启用，不需要配置
	5. [[HMR]] 
	6. DllPlugin：动态链接库插件【 webpack5.x 中已经不建议使用这种方式进行模块缓存，因为其已经内置了更好体验的 cache 方法】
		1. 背景：前端框架如vue, react，体积大、构建慢。它们较稳定，很少发生改变，不必每次都打包。先事将三方库打包为dll文件，之后打包引用它
			1. 同一版本只构建一次即可。
		2. webpack内置，分为两部分
			1. DllPlugin - *产出*dll文件（打包出）
			2. DllReferencePlugin - *使用*dll文件
		3. 使用
			1. 新增[[webpack.dll.js]]配置文件，使用该配置文件在dist中打包出dll.js与manifest.json文件，
			2. [[引入dll文件.png]] 
			3. [[设置dll引用关系.png]] 
				1. 忽略该文件夹，因为react已打包（为稳定的dll）
3. 优化产出代码[^6] 
	1. 小图片base64编码
	2. bundle名使用hash
	3. mode使用production
		1. 自动开启代码*压缩*。线上加载更快、安全
			1. 不需要uglify【webpack 4之后】
			2. 如果压缩确实慢，可开启多进程
		2. 自动*删除*调试代码（如开发环境的warning） 
		3. 自动启用[[Tree-Shaking]] 
			1. 必须使用[[ES Module]] 才能生效。为何（[[ES Module]] 与[[CommonJS]] 的区别）？
	4. scope hoisting。原理是将*多个模块放在同一个作用域下，并重命名防止命名冲突*，通过这种方式可以减少函数声明和内存开销
		1. 背景：bundle的每个模块，都在单独的函数闭包中。
			1. 将所有模块的作用域连接到一个闭包中，执行更快。
		2. [[插件设置.png]] 
			1. 对于第三方模块，优先引用jsnext:main指向的文件名。其中提供了[[ES Module]]语法的文件
			2. 只支持 es6 代码。如果该第三方模块没有提供ES6模块化语法的版本，则不能实现
			3. 5：默认支持，在生产环境下默认开启
	5. *清除*无用
		1. JS。开启生产模式即可。
		2. CSS。`purgecss-webpack-plugin` 会单独提取 CSS 并清除用不到的 CSS
			1. 相当于CSS的tree-shaking
			2. [清除无用的 CSS](https://juejin.cn/post/7023242274876162084#heading-47) 
	6. *忽略*。IgnorePlugin。webpack5 已弃用
	7. *提取*公共代码。[splitChunks 分包配置](https://juejin.cn/post/7023242274876162084#heading-52) ：optimization.splitChunks
		1. 定义分包
			1. 生成 chunk 的最小体积
		2. [[分包实际使用.png]] 
	8. *压缩* 
		1. CSS：`css-minimizer-webpack-plugin` 
		2. js：内置的`terser-webpack-plugin` 
	9. [[懒加载]] 
	10. 使用[[CDN]] 
		1. 步骤
			1. 公司拥有内建或购买的CDN服务
			2. 把dist下打包的css/js等静态资源文件上传到CDN服务器
			3. 在html模板文件中，所有对静态资源引用的路径前，添加该CDN地址
		2. [[图片文件使用CDN.png]] 
	11. prefetch 与 preload。需要异步加载的文件比较大时
		1. prefetch (预获取)：浏览器空闲的时候进行资源的拉取 [[prefetch.png]] 
		2. preload (预加载)：提前加载后面会用到的关键资源 [[preload.png]] 
	12. 样式前缀。postcss-loader的autoprefixer
#### 相关
1. [构建 webpack5.x 知识体系 - 掘金](https://juejin.cn/post/7023242274876162084#heading-23) 
2. [Create React App无eject配置（react-app-rewired 和 customize-cra） - 掘金](https://juejin.cn/post/6844904016581754888?searchId=20230721234319DFB521E8ACF48D04A818#heading-8) 
## 项目设计与流程
1. 项目方面的考察
	1. 原因
		1. 框架的使用是基础
		2. **设计能力**决定了一个人能否独立负责项目，还是需要别人带。
		3. 面试必考（二面/三面），场景题。
2. 项目设计
	1. 重点
		1. 数据驱动视图
		2. 状态：数据结构设计（react 的 state，vue 的 data）
		3. 视图：组件结构与拆分
	2. 题目
		1. [[react组件设计]] 
		2. vue 设计购物车（组件结构，vuex state [[数据结构]] ）
3. 项目流程
	1. 特点
		1. 项目需要多角色参与、存在多阶段
		2. 项目的计划与执行
	2. 为何考察项目流程？
		1. 如果项目流程相似，接手会很快
		2. 确定不是个人项目 demo
		3. 确定能否真正解决*项目中遇到的问题*。
		4. 判断能否独立承担一个项目（作为项目负责人）
	3. 题目
		1. PM 想在开发过程中增加需求，怎么办？
		2. 项目即将延期，该怎么办？【项目延期是常见的事】
			1. 延期的话就先延期，分析延期原因，下次尽量避免
				1. 没有及时发现、上报风险（依赖方延期，遇到困难的问题）
		3. 你将如何保证项目质量/开发质量【并不是代码问题，是项目问题】
	4. 相关
		1. 项目角色
			1. PM 产品经理：提需求
				1. 通过简图与文字表示功能
			2. UE 视觉设计师：产出 PRD
			3. FE 前端
				1. 与 CRD 的交互：因为移动端的开发是通过一个客户端去展示页面，而不是浏览器
			4. RD 后端
			5. CRD 移动端开发
			6. QA 测试人员
		2. 项目流程![[Pasted image 20230729002912.png]]
			1. 需求分析
				1. 产品一般提出的是比较理想化的，而开发是需要落地的需要考虑现实、人力/时间成本、性能问题
				2. 开发需要做到
					1. 了解需求背景：为什么要这个需求？
					2. 质疑需求本身是否合理？不要等上线了发现需求不合理再下线，做白功。
					3. 需求是否考虑全面/闭环？
						1. 只提出一个点赞的需求？难道不需要按点赞数量进行排序？
						2. 分享完就结束了？如果新用户看到后能有一半人回到/下载我们的 APP 是否更合理？
					4. 开发难度
						1. 比如在 html 中添加复杂的动画是比较难的。一定要现场评估，等会议结束就相当于答应了，就必须完成了。
					5. 是否需要其他支持
						1. 微信公众号中图片的点击放大，是需要服务端支持的。需要告诉 PM，说需要一个 CRD 的支持。如果做到一半再说，可能 CRD 已经排期都满了。最后也是自己的问题
					6. 不要急于给排期
						1. 不要在会议上给排期，要看整个部门的安排
			2. 技术方案设计
				1. 问题：设计什么样的接口、 什么样的客户端能力、数据的输入与输出、数据的格式？
				2. 原则
					1. 求简。不过度设计。不要说“这个技术好、比较新、看着新奇，来用一下”。框架之类的都是为了提升开发效率
						1. 比如前端路由模式，如果没有特殊需求就用 hash，因为不用服务端支持。服务端不一定有空
					2. 产出文档。设计、分析，使用文本、图片、代码描述，将需求分析清楚。不要轻易低估事情的
					3. 找准设计重点。组件设计、数据设计、接口、。
					4. 组内评审。依赖于文档。看看设计的性能隐患，安全问题
					5. 与 RD、CRD 沟通。所有开发达成一致
					6. 发出会议结论。邮件，聊天结论之类的。避免别人找茬。
			3. 开发
				1. 如何反馈排期。
					1. 大小：预留 buffer，1/4左右。1个月完成说多5天，4天说5天
					2. 并行：需要考虑排期工作
					3. 依赖：产品、UE、RD/CRD，综合他们的排期（确定日期）或工作量（消耗时长）。
				2. 符合项目开发规范
					1. 注释、模块命名、git 规范
				3. 写出开发文档
					1. 如果做的是公共的 UI 或 API，说明如何使用
				4. [[单元测试]] 
					1. 一定要写单元测试，不要相信自己的代码
				5. [[mock]] API
					1. 可通过 webpack 中使用 proxy 代理，也可使用工具如 [[mock.js]] 
				6. [[Code Review]]  
			4. 联调【功能刚开发完】
				1. 与 RD/CRD 技术联调
				2. 让 UE 介入检测确定视觉效果
				3. 让 PM 介入确定产品功能
				4. PM 加需求怎么办？
					1. 如果有相关流程规定，走*需求变更流程*即可。
					2. 如果没有，发起项目组与 Leader 的评审，重新排期
			5. 测试
				1. 发提测邮件，抄送项目组
					1. 发送者：可能是 PM 整体发送，也可能是开发分别发送
				2. 测试问题要专门记录【不能在聊天中描述，不方便管理（查看，修改，删除）】
				3. 有问题必须及时沟通。QA 与 FE 信息不对称。开发觉得自己写的好，QA 觉得肯定有问题
					1. 环境问题：永远不要说“我电脑这里看的没有问题”，QA 说有问题，100%是写的程序有问题
						1. 当面讨论，让 QA 提供复现条件
			6. 上线
				1. 上线后及时通过 QA 回归测试、同步给 PM 和项目组。
				2. 如果有问题及时回滚。先止损，再排查问题。不要在项目有问题的状态下自己在排查。
		3. 项目沟通
			1. 多人协作，沟通是最重要的事情。建议每日一次。项目延期原因：开发能力不足（开发能力/准确评估能力）、突发紧急任务、依赖角色延期
			2. 内容
				1. 及时识别*风险*并汇报。如果不提别人的问题导致自己延期，问题在自己
		4. 各阶段常见问题
## [[数据结构]]  
1. 为何要考察
	1. 辨别优秀工程师（鉴别成本、成功率）
	2. 前端范围越来越广
2. 重点
	1. 算法复杂度：时间，空间
	2. 算法思维：贪心、二分、动态规划
	3. 常见数据结构
3. 原则
	1. 一个问题的解决方案有很多，要找出**最优解** 
	2. 关注解决问题的思路与方法
4. 问题
	1. 将一个数组旋转 k 步
	2. 用 JS 实现快速排序，并说明时间复杂度
	3. 判断一个字符串是否括号匹配
	4. 反转单向链表（头尾互换）
## [[算法]] 
1. 标准：使用 [[Jest]] 库编写单元测试，查看算法的复杂度
## 手写


[^2]: 三栏布局。在任意分辨率下，两侧宽度固定，中间宽度自适应。一般用于PC。
[^3]: 能否在this.setState之后，获取到state的值？
[^4]: 基本配置只能做demo，要能做线上项目。
[^5]: 代码保存后浏览器自动刷新、内存中声明的变量也都不存在了！项目较大时速度较慢
[^6]: 优点：体积更小；合理分包后不重复加载；速度更快、内存占用更少
[^7]: 小图片使用base64，bundle使用contenthash，mode使用production，scope hoisting，prefetch与preload, ，清除无用CSS，忽略，提取公共代码，压缩，懒加载，CDN，样式添加浏览器兼容的前缀
[^8]: 大象*出屎*，被*狗*看*见*，吃下之后*生*出万里长*城*，*写入*史册。
[^9]: 在操作系统的进程中，每个进程都有自己独立的内存空间【进程之间的内存是隔离的】。用户访问时是不能选择访问哪个进程的，如果访问的进程中刚好没有存储当前 cookie 对应的信息。而且 session 之所以放在内存中，而很少放在硬盘中，是访问速度的要求。所以要么进程间实时同步，要么使用第三方缓存。
[^10]: www 与image都是**二级域名** ， www只是一个约定 ，不添加它也可访问 baidu 主域名
[^11]: 什么是长轮询？就是客户端想等待服务端的消息，或客户端相模拟一种效果：服务端一有消息就马上返回给客户端。