# 标准
基层工程师：基础知识
高级工程师：基础知识+项目经验
架构师：解决方案能力
# 内容
## 面试
特点
	1. 经过组织者精心设计[^1] 
	2. 以交谈和观察为主要手段
		1. 表现得积极、向上、踏实、乐观
	3. 评价知识、能力、经验的综合素质。【老师教知识，能力只能看自己】
### 环节与流程
如何拿到面试机会【优先级】
	1. 员工内推
	2. 猎头推荐
	3. HR搜集（主动搜索，接收邮件）
中型以上，较为正规的的面试流程
	1. 技术一面
		1. 基础知识的深度和广度
		2. 框架基本使用
	2. 技术二面
		1. 框架高级特性、框架原理、计算机原理
		2. 项目经验，项目设计能力、问题的解决方案、工作环境
	3. 愿景三面
		1. 能为公司带来什么
		2. 如果有不足如何提升
	4. HR面【有一票否决权】
		1. 表现得阳光，积极，正面
		2. 踏实，谦卑
### JD分析
解读用人单位的招聘信息
	1. 职位描述
		1. 工作内容
		2. 技术栈
	2. 岗位要求
		1. 经验要求
不要过于在意JD【有时候看到JD会想要退却？】
	1. JD不是技术发布的
	2. 不要完全相信
解读
	1. 技术栈
	2. 平台：多终端？【web，移动端，微信】
	3. 性能优化
	4. 工作内容：有较好的抗压能力！
### 写简历
1. 内容【不用写个人爱好、自我评价之类的。顺序不要乱】
	1. 个人信息
		1. 姓名，性别，电话，邮件，籍贯【年龄可不写】
	2. 教育经历
		1. 写上最高学历即可
		2. 学校，专业，入学、毕业时间
		3. *不要写高中*，很不专业
	3. 专业技能
		1. 核心竞争力【不是你会别人不会的，而是你能满足用人单位要求】
		2. 3，5条即可
		3. 不要写太基础、细微的内容【会用vscode, git, echarts, lodash什么的】，会显得你档次低。
	4. 工作经历
		1. 公司，职位，入职/离职时间即可
		2. 存在空窗期，如实写即可。个人原因，自由职业等
	5. 项目经历【不要像工具经验一样逻辑，而是突出能力】
		1. 2-4个具有*说服力*的项目
			1. 重复的项目，不重要的不用写
		2. 项目描述，技术栈，个人角色【开发，管理】
		3. *可以写别人的项目，但你要能自圆其说*，真的理解了。
		4. 或者把其他项目的想法写在某个项目上。
	6. 博客和开源作品
		1. 需要有真内容
2. 要点
	1. 简洁，突出重点
	2. 界面不要花哨，
	3. 慎用“熟练”，“精通”
	4. 表现出优势
### 准备工作与注意事项
面试前的准备工作
	1. 看JD，是否需要临时准备
	2. 打印纸质简历，带纸笔
	3. 最好带自己电脑，现场可能写代码
	4. 不要迟到或早到
	5. 为何离职
		1. 不要吐槽前东家，【想找更好的发展】
	6. 能加班吗
		1. 能。除非你找到了不用加班的公司。
	7. 不要挑战面试官，即使他有问题。要愉快地度过这场面试
	8. 遇到不会的问题，要表现出积极的态度
		1. 去思考1、2分钟
		2. 问面试官“能不能给个引导”
		3. 我回去再研究研究。
	9. 平时怎么学习
		1. 视频，官方文档
	10. 你有什么缺点？
		1. 自己的小程序、性能优化、组件封装不熟练，最近正在学习小程序。
	11. **你有什么想问的吗？**
		1. 职责
			1. 我的日常*工作内容*是什么？如果我入职了，可能会负责哪块，主要做什么？
			2. 这是个*继续开发*的项目，还是*新*项目？
		2. 技术
		3. 业务
			1. 业务内容
		4. 团队
			1. *团队规模*有多大，移动端有多少人、Android端有多少人、测试怎么测
			2. 每天*预期工作时间*是多少小时？
		5. 规划
		6. 待遇
			1. 值班或者遇到问题加班时候有*加班费*吗？
			2. 调薪一般是多久一次？
			3. 除了薪水外其他福利待遇有哪些，比如餐补
[面试过程中应该避免的几种情况（最后附送前端面试题）\_慕课手记](https://www.imooc.com/article/300475)  
## 技术
### HTML
1. 如何理解语义化
	1. 由标签名可推测出内容的分类。增加**可读性**，利于开发维护【人读】和SEO【机读】。
2. 默认情况，哪些是块级，哪些是内联
	1. display: block/table
		1. div, h1, table, ul, ol, p
	2. inline/inline-block
		1. span, img, input, button, a
3. H 5新增元素
	1. header,  nav, aside,section, article, footer, figure
4. 表单元素有哪些
	1. value：input, select,  textarea
	2. checked：radio, checkbox
	3. form
### [[CSS]]【少量HTML，较多CSS】
1. [[布局]] 
	1. [[盒模型]]宽度如何计算
	2. margin纵向重叠
		1. 如果**元素内容为空**，也没有设置高度。
	3. margin的四个方向负值会怎样
		1. top/left负值：元素向方向移动
		2. right/bottom：自身不动，右/下侧的元素向左/上移动对应负值
	4. [[BFC]]的理解与应用
	5. float[[布局]]，clearfix
		1. 如何实现*圣杯布局*[^2]和*双飞翼布局*（PC端常用的两个布局）
			1. 使用float布局
			2. 两侧使用margin负值，以便和中间内容*重叠*；
			3. 防止中间被两侧*覆盖*，圣杯布局用padding, 双飞翼用margin
			4. 具体
				1. 宽度左右px，中间100%
		2. 手写clearfix
	6. 居中布局？考虑浏览器兼容性？
	7. 多列等宽布局？多列等高布局？如何通过flex布局实现？
	8. flex画色子
		1. 画一个三个点的色子
2. [[定位]] 
	1. absolute，relative分别相对谁定位
	2. 居中对齐的实现方式
3. 图文样式
	1. lint-height的继承问题：[[CSS属性]] 
4. 移动端响应式
	1. rem是什么：[[属性值与单位]] 
	2. 如何实现[[响应式布局]] 
5. CSS3：flex, 动画
### [[JS]] 
1. [[数据类型]] 
	1. 值类型和引用类型的区别：[[变量]] 
	2. 类型判断instanceof
	3. [[操作符]]typeof判断的类型：8种
	4. 使用\=\==和\=\=的场景？只有需要判断\==null时 
	5. 手写[[深拷贝]] 
	6. 手写[[深比较]] 
	7. 列举强制类型转换与隐式类型转换的情况
		1. 隐式转换
	8. [[Array]]哪些方法影响原数组？
	9. [[Function]]声明与表达式的区别
	10. [[Object]] 
	11. 手写trim方法：[[string]] 
	12. 如何获取最大值
	13. 如何实现[[JS继承]] 
2. [[异步JS|异步]]，单线程
	1. [[event-loop]]、[[Promise]]。
	2. DOM事件与[[event-loop]]的关系
	3. DOM渲染与[[event-loop]]的关系
	4. 什么是宏任务、微任务？区别？
	5. 同步和异步的有什么区别？
		1. 是否会阻塞代码执行
	6. 前端使用异步的场景？
		1. 耗时任务
			1. [[网络请求]]，图片加载，大量计算
	7. 异步原理、进阶
3. class和[[JS继承]] 
4. [[原型对象]]，原型链
	1. 如何判断一个变量是不是数组？
		1. 类型判断instanceof，判断原型链上是否存在该原型对象
	2. [[class]]的原型 本质
		1. 类的本质是一个函数
5. [[作用域]]，[[闭包]] 
	1. [[this]]在不同场景下的取值
	2. 手写bind[[Function]] 
	3. 实际开发中闭包的应用场景
		1. 防抖，节流：[[工具函数]] 
		2. 隐藏数据，只提供部分API专用于修改该数据
		3. 在react应用的组件中，有些逻辑只需在项目初始化时加载一次，可使用闭包。因为如果在didMount中定义，页面刷新也会执行
6. 如何捕获JS程序中的异常？[[异常捕获]] 
7. 什么是[[JSON]] 
8. 如何获取[[URL]]查询参数
9. [[性能优化]]？一般从哪几个方面考虑？
10. 介绍一下[[requestAnimationFrame]] 
11. [[Map]]和[[Set]] 
12. [[WeakMap]]和[[WeakSet]] 
### [[数据结构]]  
### [[算法]] 
### [[计算机网络]] 
1. [[HTTP]] 
	1. 常见[[HTTP状态码]] 
	2. 常见[[HTTP Header]] 
	3. [[HTTP Method]] 
	4. 什么是[[RESTful API]]。说出本质即可
	5. 描述一下[[HTTP缓存]]机制
	6. [[协议]]和[[规范]] 
	7. [[HTTPS]] 
	8. 三握四挥：[[TCP]] 
### web api
1. [[DOM]] [[BOM]] 
	1. DOM是哪种数据结构
	2. DOM操作常用的API
	3. attribute与property的区别
	4. 一次性插入多个DOM节点，考虑性能
	5. 事件代理是什么。多个事件绑定同一个事件处理函数:[[DOM事件]]  
		1. 当有许多事件处理函数，且处理逻辑比较相似，可利用事件冒泡机制，将事件绑定在公共父节点上，只设置一个事件处理函数，通过event.target判断触发元素选择逻辑。
		2. 场景：瀑布流。
	6. 如何识别浏览器的类型
	7. 如何减少DOM操作
		1. 缓存DOM查询结果、多次操作一次插入
	8. 分析拆解URL各个部分
	9. [[document]] load和ready的区别？【ready就是DOMContentLoaded】
2. [[Function]] 
	1. call与apply区别
	2. [[闭包]]定义，特性：基于[[作用域]] 
3. [[AJAX]]：[[网络请求]] 
	1. 手写简易ajax/XHR，并发起请求
	2. [[同源策略]]。跨域的常用实现方式
	3. 解释[[JSONP]]的原理，为何它不是真正的ajax？
		1. 因为没有用到XHR
	4. [[AJAX]], [[axios]], fetch的区别
		1. ajax【甄姬关配，】
			1. 基于原生XHR开发，XHR本身的架构不清晰
			2. 针对MVC编程，不符合前端MVVM的浪潮
			3. 不符合关注分离（Separation of Concerns）的原则
			4. 配置和调用方式非常混乱，而且基于事件的异步模型不友好
		2. [[axios]] 
			1. P端蓝转消
		3. [[网络请求#Fetch API|fetch]]  
			1. 优点【PA一只手拖鱼，一只手扣百度】
				1. 基于标准的Promise
				2. 更底层，API丰富。
				3. 脱离了XHR，是ES规范里新的实现方式
				4. 语法简洁，语义化
			2. 缺点
				1. cookie。默认不带cookie，需要配置 `fetch(url,{credentials: 'include'})` 
				2. 请求失败。只对网络请求报错。
				3. 不能检测请求进度。XHR可以
4. [[JS事件]] 
	1. 编写一个通用的事件监听函数：[[DOM事件]] 
	2. 事件冒泡流程
		1. 基于DOM树形结构，从触发元素开始向上级元素冒泡。
		2. 应用场景：事件代理
	3. 无限下拉的图片列表，如何监听每个图片的点击
		1. 事件代理。用e.target获取触发元素，用matches判断是否是触发元素
	4. 如何阻止事件冒泡和默认行为。
5. [[客户端存储]] 
	1. 描述[[cookie]], localStorage, sessionStorage区别【容基操】
		1. 容量
		2. 机制：生命周期、是否发送
		3. 操作方式：通过API，直接赋值。
### 开发环境
1. [[版本控制|版本管理]]，[[git]] 
2. [[调试]] 
3. 抓包 [[抓包工具]] 
4. bug解决
5. 如何连接测试机服务器
6. [[ES Module]]、[[模块]]、[[模块化]] 、[[js模块化]] 
7. 你常使用的[[ES6新特性]]有哪些？
8. [[linux]]常用命令：本地无法复现，测试、线上可复现
9. 线上环境出问题如何解决
10. 如何登录线上机，线上机有一个文件如何编辑？
### [[运行环境]]：保证代码在浏览器中：稳定且高效
1. 网页加载过程。页面渲染。[[浏览器原理]] 
	1. 从输入[[URL]]到渲染出页面的整个过程
	2. onload事件和DOMContentLoaded事件的区别
		1. 是window对象上的，所有资源加载结束
		2. 是document对象上的， DOM渲染完即可。
	3. 为何把CSS放在HEAD材中
2. [[性能优化]] 
3. [[前端安全]] 
### [[设计模式]] 
[[OO设计模式]] 
### [[库、框架]]  
## [[vue]] 
1. 什么是[[组件化]] 
2. 如何理解 [[MVVM]] 
3. 监听data变化的核心API？
4. 如何深度监听data变化
5. vue如何监听数组变化
6. v-dom。
	1. 原理
	2. diff算法 
7. vue模板被编译成什么？
8. vue组件可用render代替template
9. 组件是如何渲染、更新的？
10. 如何异步渲染的？
11. 如何用JS实现hash路由
12. 如果用JS实现history路由
13. 列表渲染为何使用key
14. data为何是函数
15. 何时使用keep-alive、beforDestory
16. diff算法的时间复杂度
17. [[vue性能优化]] 
##  [[react]] 
1. 组件如何通讯
	1. props，context, [[redux]] , 自定义事件
	2. [[context]] 场景。在函数组件、class 组件中如何使用
	3. 复杂的公共信息 (业务的数据比较复杂)，使用redux
2. [[JSX]] 本质是什么 
3. 什么是[[纯函数]] 
4. 列表渲染为何使用key。[[react原理]] 
	1. 减小渲染次数，提高渲染性能【应该是减少计算量吧？】
5. portals 场景
	1. 需要将组件渲染到父组件之外：全局的提示，Modal 框。
		1. 把 fixed 定位的元素放到 body 上，有更好的浏览器*兼容性*。
	2. 父组件是个 [[BFC]] ， *z-index* 太小等布局问题
6. 异步加载组件
	1. 场景：懒加载，组件较大
	2. 方式
		1. import ()
		2. React. lazy
		3. React. Suspense
7. [[class组件#生命周期]]  
	1. 父子组件生命周期
8. [[性能优化]] ：永远是面试的重点。因为性能优化相对 [[vue]] 而言，对 [[react]] 更加重要
	1. 彻底拥抱不可变值： [[immutable.js]] 
	2. SCU 默认返回，使用的注意事项
		1. 一定要每次都用吗？只要不会导致卡顿，不必每次都用
		2. 必须配合不可变值使用。传入新值
	3. class 组件：PureComponent，在 SCU 中使用浅比较。
	4. React.memo
9. setState是同步还是异步？[^3]
	1. ![[Pasted image 20230706165259.png]]
	2. 异步：在setState后读取state，是原值
		1. 可通过this.setState({},fn)的第二个参数拿到最新
	3. react 17之前：在定时器、[[DOM事件]]中，是同步的。上面的图片打印是0,0,2,3
	4. react 17之后：定时器、DOM 事件中也是异步的
10. 何时会合并 setState
	1. 传递对象时合并。相当于assign，对象会覆盖相同的属性名
	2. 传递函数时不合并
11. 函数组件与 class 组件的区别
	1. 本质
		1. 一个是类。有 this **实例、生命周期** 
		2. 一个是纯函数。输入 props，输出 JSX ，没有实例、生命周期
	2. 代码组织
		1. 事件绑定
		2. state 的初始化、修改
		3. [[副作用]] 
			1. 每次刷新教会调用，默认情况下没有仅挂载时调用一次，更新时不会调用的 didMount
		4. ref 引用
			1. 暴露整个元素
			2. 暴露部分数据
	3. API 使用
		1. 避免重复副作用：一个是 CDU 中手动比较state或props，一个是监听 state
		2. context：一个绑定在组件实例上，一个使用 hook 或 consumer
	4. 逻辑复用
		1. 一个使用 HOC 或 renderProps，一个使用 hook
12. [[React与Vue的比较]] 
13. 什么是受控组件
	1. 需要通过创建state、创建修改state的函数来控制表单组件的值的方式来管理输入
14. 什么是非受控组件？使用场景？
	2. *文件*上传：input type=file
	3. *富文本*编辑器，需要传入 DOM 元素
	1. 必须手动操作 [[DOM]] 元素，setState 无法实现
15. 何时使用异步组件？
	1. 路由[[懒加载]]、组件较大
16. 如何抽离组件的公共逻辑？
	1. class组件
		1. 什么是 [[react组件#HOC|HOC]]  ？
			1. 模式简单，但增加组件层级
		2. renderProps
			1. 代码简洁。
				1. 定义时：定义逻辑、接收 UI 并传入逻辑
				2. 复用时： 函数接收逻辑，返回展示组件
		3. mixin已废弃
	2. [[函数组件]] ：自定义hook
17. [[redux]] 
	1. 描述 [[redux]] 单向数据流
	2. action 如何处理异步？
	3. 描述[[中间件]]原理
18. [[react-router]] 
	1. 如何配置懒加载？react. lazy和suspense结合，通过import引入
19.  [[react原理]] 
	1. DOM事件与react事件的区别？
20. 如何进行[[性能优化]]？
## [[webpack]] 
### 问题
1. 它是成熟的工具，重点是配置和使用，原理并不非常重要。
	1. 不了解配置，只会用cli工具创建项目。
2. 前端为何要进行[[构建]]？【代码：体积更小，高级语法，错误检查；研发流程：开发环境，构建流程，构建规范】
	1. 代码层面
		1. 体积更小，加载更快
		2. 编译高级语法、预处理器（ES6, TS, 模块化，LESS）
		3. 兼容性与错误检查
	2. 研发流程层面【高级程序员，不能只考虑代码层面，还会关注人、团队、流程】
		1. 统一高效的开发环境
		2. 统一的构建流程、产出标准。
		3. 集成公司构建规范（提测、上线等）
3. 大概的构建流程？[Webpack完整打包流程分析 - 掘金](https://juejin.cn/post/7163528496487071758?searchId=2023072113185556B656C79D5337A017FD#heading-7) 
	1. 初始化
		1. 创建 *compiler* 对象
		2. 读取与合并*配置*信息
		3. 初始化默认*插件*。
			1. 有 compiler 实例对象后，就可以注册配置文件中的一个个插件，在合适的时机来干预打包构建
	2. 编译，build
		1. 创建compilation
		2. 读取入口文件
		3. 从入口文件开始进行编译
		4. 调用 loader 对源代码进行转换
		5. 借助 babel 解析为 AST 收集依赖模块
		6. 递归对依赖模块进行编译操作
	3. 生成，seal
		1. 生成 chunks，对 chunks 进行一系列的优化操作，并生成要输出的代码
		2. 生成 assets 对象
		3. 结束后，Compilation 实例的所有工作到此也全部结束，意味着一次构建过程已经结束
	4. 写入，emit
		1. 被触发之后，webpack 会遍历 compilation.assets, 生成所有文件，然后触发任务点 done，结束构建流程
4. 为何[[Proxy]]不能polyfill？
	1. [[Proxy]] 的功能无法使用Object.defineProperty实现
5. module, chunk, bundle分别是什么？区别？ 
	1. module：每个源码文件。src中的每个文件，除html文件
	2. chunk：多模块合并的结果。如入口文件，动态/异步加载模块，分包。根据来源可分为3种chunk，
		1. 是**对module的分类**。
			1. 需要在依赖关系中*直接打包*在一起的module
			2. 需要被*异步加载*的module
			3. 需要被*多次引用*的module打包为一组chunk
	3. bundle：最终打包的输出文件。
		1. 是chunk的子概念，一个chunk可能产生多个bundle。
			1. js、map文件
6. loader与plugin区别？
	1. loader只负责编译时的*源码*转换【文件处理层面】
	2. plugin可在整个编译流程的不同*时机*添加处理【流程进行层面】
		1. 文件提取、
		2. 构建、压缩、
7. 常见loader与常见plugin
	1. loader
		1. 样式、图片、字体：less, css, style, scss, file, url, [[PostCSS]] 
		2. 语言层面：babel-loader, 
	2. plugin
		1. [[HTML]] 
			1. htmlWebpackPlugin：根据模版生成 HTML
		2. [[CSS]] 
			1. MiniCssExtractPlugin：提取
			2. CssMinimizerWebpackPlugin：压缩
		3. [[JS]] 
			1. TerserWebpackPlugin：压缩 JavaScript 文件
		4. 全局
			1. DefinePlugin
			2. CompressionWebpackPlugin：通过命令行 gz *压缩静态资源*包大小，提升前端加载性能与速度。该插件需要在服务端代理服务器（如 Nginx）支持 gzip 压缩配置
		5. [[开发流程]] 
			1. HotModuleReplacementPlugin
		6. 构建流程
			1. IgnorePlugin：构建过程中忽略（第三方模块的）指定目录
			2. SplitChunksPlugin：分包
			3. DllPlugin：将可共享且不经常改变的代码，抽取成一个共享的库，避免进行二次构建
		7. 构建结果
			1. WebpackBundleAnalyzer
8. 与babel区别？
	1. 一个是插件化的代码构建工具，
	2. 一个是编译器主要负责语法转换，polyfill
9. webpack如何实现懒加载？
	1. import()结合vue react异步组件
	2. 结合各自框架的router库，异步加载路由
10. 如何产出一个lib？
	1. 在output配置的library字段，设置当前lib的全局变量名
	2. 使用babel/runtime，重命名变量名（特殊化处理避免冲突）
11. 常见性能优化？
	1. 构建速度
	2. 产出代码
12. 了解过webpack5吗？
	1. 主要是**内部效率**的优化，使用方式没有太大变化。
13. 什么是tree-shaking
	1. 打包模块时，忽略导出却未使用的方法。
14. [[ES Module]] 与[[CommonJS]] 区别？
	1. 前者是**静态引入**，*编译*时引入【无条件，无异步地直接引入。不通过语句进行条件引入】
		1. 动态引入会在编译时报错。
	2. 后者是**动态**引入，*执行*时引入【代码执行时才知道引入的是什么。webpack打包并不执行代码，只是静态分析，无法确定模块引用关系】
	3. 只有前者可进行静态分析，实现[[Tree-Shaking]] 
15. 什么是 scope hoisting
	1. 改变打包结果。【代码体积越大，效果越好】
		1. 开启前。n个模块文件会打包出n个函数。创造许多函数作用域
		2. 开启后。n个模块文件的内容打包在一个函数中执行
	2. 优点
		1. 代码体积，创建函数作用域更少，提高代码可读性
16. 什么是[[babel]]，什么是babel-polyfill？babel/runtime与babel/polyfill的区别？
	1. babel-polyfill
		1. 在babel7.4之后被弃用。因为它只是[[core-js]]与[[regenerator]]的合并，建议直接使用二者
			1. 如果是开发三方库，必须使用
		2. 非常大，只使用了几个feature不必引入全部polyfill，如何按需引入？
			1. [[使用版本为3的core-js.png]] 
		3. 缺点
			1. [[污染全局环境.png]] 
				1. 如果只是做一个web系统，可以
				2. 如果想定义一个三方库，则可能出现覆盖。那怎么办？---名称不使用官方常用名
	2. babel/runtime：**变量全局环境污染问题**，将polyfill的api修改命名。如将Promise修改为_Promise。
		1. 使用默认配置即可。
17. module.noParse与IgnorePlugin区别？
	1. 前者
		1. 针对有用模块，打包，只是不使用loader解析。
	2. 后者
		1. 针对无用模块，不打包
### 配置   
1. loader
	1. 配置项？
		1. test: 匹配处理文件扩展名的的正则表达式；
		2. include: 对指定类型模块处理时，只处理该文件夹；
		3. exclude: 对指定类型模块处理时，只排队该文件夹；
		4. use: 指定处理文件时要使用的模块（loader?）名称；
		5. options: 为loader提供额外的配置选项。
	2. text，include与exclude区别？
		1. e优先级最高。如果i和e冲突，则执行e。
		2. **e和i只写一个即可**。
2. 基本配置
	1. 安装配置
	2. 拆分配置与merge。
		1. 减少配置文件的重复代码。通过`webpack-merge`包，可将webpack配置文件拆分为公共部分、dev环境配置文件、prod环境配置文件
		2. 开发环境直接引入url，生产环境通过loader转换图片为base64格式
		3. 开发环境特有：dev-server
	3. dev-server
	4. 解析
		1. [[ES6新特性]] [[webpack配置babel.png]] 使用babel需要配置.babelrc文件 [[Pasted image 20230717234614.png]] 
		2. 样式  [[样式文件的loader配置.png]] 
		3. 图片文件
			1. [[开发环境图片引入配置.png]] 
			2. [[生产环境图片引入配置.png]] 
				1. 根目录一般只放html文件
				2. 以base64形式产出一个图片，可减少一次网络请求。做成[[base64]]编码，写在代码中了。
		4. 其他文件
			1. [[使用file-loader打包图片与icon.png]] 
	6. 在webpack下如何跨域请求其他接口？
		1. 开发环境可使用配置中的proxy字段。如果本地服务端口是8080，服务端端口是3000，[[webpack开发服务器跨域.png]] 
3. 高级配置[^4] 
	1. 多入口
		1. 项目有多个html文件。虽然是SPA，但有时需要产生多个HTML。
		2. 添加入口文件。[[Pasted image 20230718144735.png]] 
		3. 每个入口都需要一个html-webpack-plugin实例 [[Pasted image 20230718144849.png]] 
			1. chunks字段的意义：指定当前html分别需要引入的chunk（JS文件）。如果不写，会引入所有入口JS文件。
		4. 根据入口名字，修改output的文件名[[Pasted image 20230718144647.png]] 
		5. 每次打包前清除dist中上次打包结果[[Pasted image 20230718150758.png]] 
	2. 抽离和压缩CSS
		1. 开发环境，只使用css-loader、style-loader没关系，但生产环境需要抽离和压缩：把样式代码专门放入CSS文件并压缩
		2. 抽离。使用loader和plugin [[CSS抽离插件的注册.png]]  [[CSS抽离插件的使用.png]] 
		3. 压缩 [[Pasted image 20230718153217.png]] 
	3. 抽离公共代码
		1. 被多次引用的三方库/模块，单独抽离，避免打包时被打包多次，在结果中出现很多重复代码。
			1. 抽离之后，成为独立的chunk文件，被单独引入。始终命中缓存
			2. 不会在每次修改业务代码后，再次打包并没有变化的三方库代码
			3. 打包后的bundle不再那么臃肿，包含所有没有必要重新打包的代码（因为没有修改）。
		2. 拆分逻辑【生成chunk】：optimization.splitChunks [[Pasted image 20230718155907.png]] 
		3. 引入拆分【引入chunk】：[[Pasted image 20230718160003.png]] 
	4. [[懒加载]]/异步加载模块
		1. 异步引入 [[Pasted image 20230718160546.png]] 
			1. 浏览器会在1.5s后请求一个chunk
		2. 默认支持，不需要额外配置。
	5. 处理react和vue
		1. 处理JSX：配置@babel/preset-react即可
		2. 处理vue：vue-loader，添加处理 [[vue-loader.png]] 
###   [[webpack#优化：13种]]  
1. [构建 webpack5.x 知识体系 - 掘金](https://juejin.cn/post/7023242274876162084#heading-23) 
2. 优化构建速度【1-5可用于生产，后续只可用于开发】【ig moba, happyUglify】
	1. 减小打包内容或解析过程
		1. 去除**无用**模块，ignorePlugin。比如moment支持多民族语言，默认引入所有语言的JS代码。如项目仅支持中文和英文，只引入两种语言即可。
			1. [[忽略文件夹.png]] 
			2. [[手动引入所需语言.png]]。
			3. 最终打包结果从263k变为55k
		2. 不解析。module.noParse：[[不需要解析的模块.png]] 让 Webpack 去解析这些**有用，但不需要构建**的模块，既耗时又没有意义。忽略的文件中不应含有import , require, define等导入机制。忽略大型的 library 可以提高构建性能
			1. *已经打包*，不需要再次打包的文件。react.min.js
			2. *没使用模块化*的文件。 jQuery、ChartJS 
				1. *没有依赖*其他模块的模块。lodash 
		3. 使用外部CDN。externals，打包时排除某个依赖，因为从CDN使用，不用打包[[使用CDN引入不希望打包的依赖.png]] 
			1. 对于开发库是最有用的。也有应用使用
		4. 排除不需要处理的文件。使用`babel-loader`处理JS文件时，排除node_modules。【为何？】
	2. 增加打包速度
		1. happyPack：**多进程打包**。特别是多核CPU，对处理多进程有优势【webpack5 已弃用】
			1. 如果只想在生产环境使用，放在prod文件即可。也可放在common配置文件中，在开发和生产环境打包时同时使用
			2. [[处理JS文件时修改Loader.png]] 领悟：可通过plugin调用Loader处理模块
			3. [[添加happyPack插件配置.png]] 
		2. thread-loader。配置在 thread-loader 之后的 loader 都会在一个单独的 worker 池（worker pool）中运行
		3. ParallelUglifyPlugin：**多进程压缩**JS。webpack内置uglify工具压缩JS，但是单线程的。PUG与HP原理相同
			1. 只需放在生产环境的构建配置，因为开发环境不需要压缩。
				1. 如果项目较小，就不需要，因为存在进程开销，开启多进程会降低速度。
				2. 项目较大，打包较慢时开启多进程可提高构建速度
	3. 缓存
		1. babel-loader 。[[缓存babel对js的编译结果.png]] 
			1. 结论：所有loader都可**缓存**处理结果
		2. cache-loader。缓存其他loader的处理结果
	4. 自动刷新[^5] 
		1. [[Pasted image 20230719193141.png]] 开启dev-server会自动启用，不需要配置
	5. [[HMR]] 
	6. DllPlugin：动态链接库插件【 webpack5.x 中已经不建议使用这种方式进行模块缓存，因为其已经内置了更好体验的 cache 方法】
		1. 背景：前端框架如vue, react，体积大、构建慢。它们较稳定，很少发生改变，不必每次都打包。先事将三方库打包为dll文件，之后打包引用它
			1. 同一版本只构建一次即可。
		2. webpack内置，分为两部分
			1. DllPlugin - *产出*dll文件（打包出）
			2. DllReferencePlugin - *使用*dll文件
		3. 使用
			1. 新增[[webpack.dll.js]]配置文件，使用该配置文件在dist中打包出dll.js与manifest.json文件，
			2. [[引入dll文件.png]] 
			3. [[设置dll引用关系.png]] 
				1. 忽略该文件夹，因为react已打包（为稳定的dll）
3. 优化产出代码[^6] 【to be muscle i lao 公】
	1. 小图片base64编码
	2. 清除无用CSS。
	3. bundle名使用hash
	4. mode使用production。
		1. 自动开启代码*压缩*。线上加载更快、安全
			1. 不需要uglify【webpack 4之后】
			2. 如果压缩确实慢，可开启多进程
		2. 自动*删除*调试代码（如开发环境的warning） 
		3. 自动启用[[Tree-Shaking]] 
			1. 必须使用[[ES Module]] 才能生效。为何（[[ES Module]] 与[[CommonJS]] 的区别）？
	5. scope hoisting
		1. [[Pasted image 20230720152916.png]] 
			1. 对于第三方模块，优先引用jsnext:main指向的文件名。其中提供了[[ES Module]]语法的文件
			2. 如果该第三方模块没有提供ES6模块化语法的版本，则不能实现
	6. IgnorePlugin。webpack5 已弃用
	7. 提取公共代码
	8. [[懒加载]] 
	9. 使用CDN
		1. 步骤
			1. 公司拥有内建或购买的CDN服务
			2. 把dist下打包的css/js等静态资源文件上传到CDN服务器
			3. 在html模板文件中，所有对静态资源引用的路径前，添加该CDN地址
		2. [[图片文件使用CDN.png]] 



[^2]: 三栏布局。在任意分辨率下，两侧宽度固定，中间宽度自适应。一般用于PC。
[^3]: 能否在this.setState之后，获取到state的值？
[^4]: 基本配置只能做demo，要能做线上项目。
[^5]: 代码保存后浏览器自动刷新、内存中声明的变量也都不存在了！项目较大时速度较慢
[^6]: 优点：体积更小；合理分包后不重复加载；速度更快、内存占用更少