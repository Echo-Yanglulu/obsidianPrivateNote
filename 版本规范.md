# 版本规范
> 我们的npm包应该发什么版本？
> 我们的依赖应该应该写什么版本？

说起npm包的版本，首先是一个概念==Semantic Versioning==[^1]
方案举例：
	2.3.1-beta.1
正式版本-preRelease版本
正式版本
	1. 主版本：破坏性改动。架构重构或使用，或兼容上有巨大差异。如webpack 4.x与5.x
	2. 次版本：新feature出现，不会出现兼容问题
	3. 补丁：只是bug修改或与功能无关的修改
pre-release版本[^2] ^uwud5g

为何要遵循Semantic versioning这个规范？
	1. 让版本语义与npm社区统一，让我们的npm包可以被用户正确地使用。
		1. 用户不想引入breaking change，就可通过^限制
	2. 享受社区生态带来的便利，利用社区现有方案，灵活地管理依赖的版本。
## 大小比较
![[Pasted image 20220717170014.png]]
## 版本范围
点（限制升级），闭区间，限制次版本的升级（允许[[#^uwud5g| ]]升级），允许第二个非零版本的升级（限制主版本的升级）。
![[Pasted image 20220717170053.png]]
^0.0.3：这个第二个非0的限制是不起作用的，因为没有第二个非零版本。
# changelog
>对于变更应该如何管理、维护、阅读？


# 自动化的管理版本与changelog方案
>一个自动化的发包流程应该是怎样的？

发布npm包时，非常适合规范版本号与更新changelog的时间

[^1]: 语义化版本：版本号的每一位都有一定语义。不仅是npm包，也是其他请多语言的包管理方案使用的一种规范
[^2]: 预发行版本：不是必须存在，只存在于联调与测试状态。正式包的版本号不应包含这部分。没有标准，但一般使用alpha, beta, rc(release candidate)