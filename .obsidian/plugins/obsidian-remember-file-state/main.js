/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD

If you want to view the source, please visit one of the following:
- https://hg.bolt80.com/obsidian-remember-file-state
- https://hg.sr.ht/~ludovicchabant/obsidian-remember-file-state
- https://github.com/ludovicchabant/obsidian-remember-file-state
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => RememberFileStatePlugin
});
module.exports = __toCommonJS(main_exports);
var fs = __toESM(require("fs"));
var os = __toESM(require("os"));
var path = __toESM(require("path"));
var import_obsidian2 = require("obsidian");
var import_state = require("@codemirror/state");

// node_modules/monkey-around/mjs/index.js
function around(obj, factories) {
  const removers = Object.keys(factories).map((key) => around1(obj, key, factories[key]));
  return removers.length === 1 ? removers[0] : function() {
    removers.forEach((r) => r());
  };
}
function around1(obj, method, createWrapper) {
  const original = obj[method], hadOwn = obj.hasOwnProperty(method);
  let current = createWrapper(original);
  if (original)
    Object.setPrototypeOf(current, original);
  Object.setPrototypeOf(wrapper, current);
  obj[method] = wrapper;
  return remove;
  function wrapper(...args) {
    if (current === original && obj[method] === wrapper)
      remove();
    return current.apply(this, args);
  }
  function remove() {
    if (obj[method] === wrapper) {
      if (hadOwn)
        obj[method] = original;
      else
        delete obj[method];
    }
    if (current === original)
      return;
    current = original;
    Object.setPrototypeOf(wrapper, original || Function);
  }
}

// src/settings.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  // Matches the number of files Obsidian remembers the undo/redo 
  // history for by default (at least as of 0.13.17).
  rememberMaxFiles: 20,
  persistStates: true
};
var RememberFileStatePluginSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Remember files").setDesc("How many files to remember at most").addText((text) => {
      var _a;
      return text.setValue((_a = this.plugin.settings.rememberMaxFiles) == null ? void 0 : _a.toString()).onChange(async (value) => {
        const intValue = parseInt(value);
        if (!isNaN(intValue)) {
          this.plugin.settings.rememberMaxFiles = intValue;
          await this.plugin.saveSettings();
        }
      });
    });
    new import_obsidian.Setting(containerEl).setName("Save states").setDesc("Whether to save the state of all open files to disk").addToggle((toggle) => toggle.setValue(this.plugin.settings.persistStates).onChange(async (value) => {
      this.plugin.settings.persistStates = value;
      await this.plugin.saveSettings();
    }));
  }
};

// src/main.ts
var DEFAULT_DATA = {
  rememberedFiles: {}
};
var STATE_DB_PATH = ".obsidian/plugins/obsidian-remember-file-state/states.json";
var WarningModal = class extends import_obsidian2.Modal {
  constructor(app2, title, message) {
    super(app2);
    this.title = "";
    this.message = "";
    this.title = title;
    this.message = message;
  }
  onOpen() {
    this.contentEl.createEl("h2", { text: this.title });
    this.contentEl.createEl("p", { text: this.message });
  }
};
var RememberFileStatePlugin = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    // Don't restore state on the next file being opened.
    this._suppressNextFileOpen = false;
    // Next unique ID to identify views without keeping references to them.
    this._nextUniqueViewId = 0;
    // Remember last open file in each view.
    this._lastOpenFiles = {};
    // Functions to unregister any monkey-patched view hooks on plugin unload.
    this._viewUninstallers = {};
    // Functions to unregister any global callbacks on plugin unload.
    this._globalUninstallers = [];
    this.onLayoutReady = function() {
      this.app.workspace.getLeavesOfType("markdown").forEach(
        (leaf) => {
          var view = leaf.view;
          this.registerOnUnloadFile(view);
          const viewId = this.getUniqueViewId(view);
          if (viewId != void 0) {
            this._lastOpenFiles[viewId] = view.file.path;
          }
          const existingFile = this.data.rememberedFiles[view.file.path];
          if (existingFile) {
            const savedStateData = existingFile.stateData;
            console.debug("RememberFileState: restoring saved state for:", view.file.path, savedStateData);
            this.restoreState(savedStateData, view);
          }
        }
      );
    };
    this.registerOnUnloadFile = function(view) {
      var filePath = view.file.path;
      var viewId = this.getUniqueViewId(view, true);
      if (viewId in this._viewUninstallers) {
        return;
      }
      console.debug(`RememberFileState: registering callback on view ${viewId}`, filePath);
      const _this = this;
      var uninstall = around(view, {
        onUnloadFile: function(next) {
          return async function(unloaded) {
            _this.rememberFileState(this, unloaded);
            return await next.call(this, unloaded);
          };
        }
      });
      this._viewUninstallers[viewId] = uninstall;
      view.register(() => {
        var plugin = app.plugins.getPlugin("obsidian-remember-file-state");
        if (plugin) {
          console.debug(`RememberFileState: unregistering view ${viewId} callback`, filePath);
          delete plugin._viewUninstallers[viewId];
          delete plugin._lastOpenFiles[viewId];
          uninstall();
        } else {
          console.debug(
            "RememberFileState: plugin was unloaded, ignoring unregister"
          );
        }
      });
    };
    this.unregisterAllViews = function() {
      var numViews = 0;
      this.app.workspace.getLeavesOfType("markdown").forEach(
        (leaf) => {
          const filePath = leaf.view.file.path;
          const viewId = this.getUniqueViewId(leaf.view);
          if (viewId != void 0) {
            var uninstaller = this._viewUninstallers[viewId];
            if (uninstaller) {
              console.debug(`RememberFileState: uninstalling hooks for view ${viewId}`, filePath);
              uninstaller(leaf.view);
              ++numViews;
            } else {
              console.debug("RememberFileState: found markdown view without an uninstaller!", filePath);
            }
            this.clearUniqueViewId(leaf.view);
          } else {
            console.debug("RememberFileState: found markdown view without an ID!", filePath);
          }
        }
      );
      console.debug(`RememberFileState: unregistered ${numViews} view callbacks`);
      this._viewUninstallers = {};
    };
    this.onFileOpen = async (openedFile) => {
      if (!openedFile) {
        return;
      }
      var shouldSuppressThis = this._suppressNextFileOpen;
      this._suppressNextFileOpen = false;
      if (shouldSuppressThis) {
        console.debug("RememberFileState: not restoring file state because of explicit suppression");
        return;
      }
      var activeView = this.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
      if (!activeView) {
        console.debug("RememberFileState: not restoring file state, it's not a markdown view");
        return;
      }
      this.registerOnUnloadFile(activeView);
      var isRealFileOpen = true;
      const viewId = this.getUniqueViewId(activeView);
      if (viewId != void 0) {
        const lastOpenFileInView = this._lastOpenFiles[viewId];
        isRealFileOpen = lastOpenFileInView != openedFile.path;
        this._lastOpenFiles[viewId] = openedFile.path;
      }
      if (!isRealFileOpen) {
        console.debug("RememberFileState: not restoring file state, that file was already open in this pane.");
        return;
      }
      try {
        const existingFile = this.data.rememberedFiles[openedFile.path];
        if (existingFile) {
          const savedStateData = existingFile.stateData;
          console.debug("RememberFileState: restoring saved state for:", openedFile.path, savedStateData);
          this.restoreState(savedStateData, activeView);
        } else {
          const otherPaneState = this.findFileStateFromOtherPane(openedFile, activeView);
          if (otherPaneState) {
            console.debug("RememberFileState: restoring other pane state for:", openedFile.path, otherPaneState);
            this.restoreState(otherPaneState, activeView);
          }
        }
      } catch (err) {
        console.error("RememberFileState: couldn't restore file state: ", err);
      }
    };
    this.rememberFileState = async (view, file) => {
      const stateData = this.getState(view);
      if (file === void 0) {
        file = view.file;
      }
      var existingFile = this.data.rememberedFiles[file.path];
      if (existingFile) {
        existingFile.lastSavedTime = Date.now();
        existingFile.stateData = stateData;
      } else {
        let newFileState = {
          path: file.path,
          lastSavedTime: Date.now(),
          stateData
        };
        this.data.rememberedFiles[file.path] = newFileState;
        this.forgetExcessFiles();
      }
      console.debug("RememberFileState: remembered state for:", file.path, stateData);
    };
    this.getState = function(view) {
      const scrollInfo = { top: view.currentMode.getScroll(), left: 0 };
      const cm6editor = view.editor;
      const stateSelection = cm6editor.cm.state.selection;
      const stateSelectionJSON = stateSelection !== void 0 ? stateSelection.toJSON() : void 0;
      const stateData = { "scrollInfo": scrollInfo, "selection": stateSelectionJSON };
      return stateData;
    };
    this.restoreState = function(stateData, view) {
      view.currentMode.applyScroll(stateData.scrollInfo.top);
      if (stateData.selection !== void 0) {
        const cm6editor = view.editor;
        var transaction = cm6editor.cm.state.update({
          selection: import_state.EditorSelection.fromJSON(stateData.selection)
        });
        cm6editor.cm.dispatch(transaction);
      }
    };
    this.findFileStateFromOtherPane = function(file, activeView) {
      var otherView = null;
      this.app.workspace.getLeavesOfType("markdown").every(
        (leaf) => {
          var curView = leaf.view;
          if (curView != activeView && curView.file.path == file.path && this.getUniqueViewId(curView) >= 0) {
            otherView = curView;
            return false;
          }
          return true;
        },
        this
        // thisArg
      );
      return otherView ? this.getState(otherView) : null;
    };
    this.forgetExcessFiles = function() {
      const keepMax = this.settings.rememberMaxFiles;
      if (keepMax <= 0) {
        return;
      }
      var filesData = Object.values(this.data.rememberedFiles);
      filesData.sort((a, b) => {
        if (a.lastSavedTime > b.lastSavedTime)
          return -1;
        if (a.lastSavedTime < b.lastSavedTime)
          return 1;
        return 0;
      });
      for (var i = keepMax; i < filesData.length; ++i) {
        var fileData = filesData[i];
        delete this.data.rememberedFiles[fileData.path];
      }
    };
    this.getUniqueViewId = function(view, autocreateId = false) {
      if (view.__uniqueId == void 0) {
        if (!autocreateId) {
          return -1;
        }
        view.__uniqueId = this._nextUniqueViewId++;
        return view.__uniqueId;
      }
      return view.__uniqueId;
    };
    this.clearUniqueViewId = function(view) {
      delete view["__uniqueId"];
    };
    this.onFileRename = async (file, oldPath) => {
      const existingFile = this.data.rememberedFiles[oldPath];
      if (existingFile) {
        existingFile.path = file.path;
        delete this.data.rememberedFiles[oldPath];
        this.data.rememberedFiles[file.path] = existingFile;
      }
    };
    this.onFileDelete = async (file) => {
      delete this.data.rememberedFiles[file.path];
    };
    this.onAppQuit = function(tasks) {
      this.unregisterAllViews();
      this.rememberAllOpenedFileStates();
      this.writeStateDatabase(STATE_DB_PATH);
      console.log("RememberFileState: done with app-quit cleanup.");
    };
    this.rememberAllOpenedFileStates = function() {
      console.log("RememberFileState: remembering all opened file states...");
      this.app.workspace.getLeavesOfType("markdown").forEach(
        (leaf) => {
          const view = leaf.view;
          this.rememberFileState(view);
        }
      );
    };
    this.writeStateDatabase = function(path2) {
      const fs2 = this.app.vault.adapter;
      const jsonDb = JSON.stringify(this.data);
      console.log("RememberFileState: writing state database...");
      fs2.write(path2, jsonDb).then(() => {
        console.log("RememberFileState: wrote state database.");
      });
    };
    this.readStateDatabase = async function(path2) {
      const fs2 = this.app.vault.adapter;
      if (await fs2.exists(path2)) {
        const jsonDb = await fs2.read(path2);
        try {
          this.data = JSON.parse(jsonDb);
          const numLoaded = Object.keys(this.data.rememberedFiles).length;
          console.debug(`RememberFileState: read ${numLoaded} record from state database.`);
        } catch (err) {
          console.error("RememberFileState: error loading state database:", err);
          console.error(jsonDb);
        }
      }
    };
    this.setupLogFile = function(outLogPath) {
      console.log("RememberFileState: setting up log file: ", outLogPath);
      const makeWrapper = function(origFunc) {
        return function() {
          origFunc.apply(console, arguments);
          var text = "";
          for (var i = 0; i < arguments.length; i++) {
            if (i > 0)
              text += " ";
            text += arguments[i].toString();
          }
          text += "\n";
          fs.appendFileSync(outLogPath, text);
        };
      };
      console.log = makeWrapper(console.log);
      console.debug = makeWrapper(console.debug);
      console.info = makeWrapper(console.info);
      console.warn = makeWrapper(console.warn);
      console.error = makeWrapper(console.error);
      const banner = "\n\nDebug log start\n===============\n";
      fs.appendFileSync(outLogPath, banner);
    };
  }
  async onload() {
    const enableLogfile = false;
    if (enableLogfile) {
      const outLogPath = path.join(os.tmpdir(), "obsidian-remember-file-state.log");
      this.setupLogFile(outLogPath);
    }
    console.log("RememberFileState: loading plugin");
    await this.loadSettings();
    this.data = Object.assign({}, DEFAULT_DATA);
    await this.readStateDatabase(STATE_DB_PATH);
    this.registerEvent(this.app.workspace.on("file-open", this.onFileOpen, this));
    this.registerEvent(this.app.workspace.on("quit", this.onAppQuit, this));
    this.registerEvent(this.app.vault.on("rename", this.onFileRename, this));
    this.registerEvent(this.app.vault.on("delete", this.onFileDelete, this));
    this.app.workspace.onLayoutReady(() => {
      this.onLayoutReady();
    });
    const _this = this;
    var uninstall = around(this.app.workspace, {
      openLinkText: function(next) {
        return async function(linktext, sourcePath, newLeaf, openViewState) {
          _this._suppressNextFileOpen = true;
          return await next.call(
            this,
            linktext,
            sourcePath,
            newLeaf,
            openViewState
          );
        };
      }
    });
    this._globalUninstallers.push(uninstall);
    this.addSettingTab(new RememberFileStatePluginSettingTab(this.app, this));
    if (this.app.vault.getConfig("legacyEditor") !== false) {
      new WarningModal(
        this.app,
        "Legacy Editor Not Supported",
        "The 'Remember File State' plugin works only with the new editor. Please turn off 'Legacy Editor' in the options."
      ).open();
    }
  }
  onunload() {
    console.log("RememberFileState: unloading plugin");
    this.unregisterAllViews();
    this._lastOpenFiles = {};
    this._globalUninstallers.forEach((cb) => cb());
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
