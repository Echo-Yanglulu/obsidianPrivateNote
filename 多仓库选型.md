# 仓库选型方案
1. 多仓库
2. 单仓库

# 定义
两种代码仓库的管理风格：
用多个仓库管理多个项目
用一个仓库
# 特点
## 多仓库
![[Pasted image 20220724141323.png]]
优点
	1. ==灵活性==：让各项目团队根据需要，定制自己的workflow
不足
	1. 难以对所有项目进行==统一操作==（切分支，构建，部署）
	2. 难以追踪==依赖关系==（a→b→c）[^1]
## 单仓库
![[Pasted image 20220724141547.png]]
案例：
	1. google做到了整个公司只有一个代码仓库
优点
	1. 统一地操作各个项目
	2. 可通过工具追踪项目之间的依赖关系（底层依赖更新时可递归的更新上层依赖）
不足
	1. 仓库会变得非常大
	2. 失去部分灵活性（workflow必须统一）
	3. 对**管理工具**有强依赖（换工具可能无法识别这种结构）
# 管理工具
## 单仓库
### lerna
1. 为JS生态的单仓库提供一站式的解决方案
	1. 版本管理，依赖管理，工作流，开发提效
2. 许多项目在用：babel，create-react-app, jest, react-router, umi, nestjs
3. 目录结构
	1. lerna.json
		1. $schema：使用一个URL为这个JSON文件添加类型提示
		2. packages: 多个项目的根路径
		3. version：设置为“independent“表示每个项目的==版本独立==[^2]。否则为sematic versioning
4. 创建依赖关系
	1. 普通模式
		1. 内部： lerna add pac-1 packages/pac-2： 2依赖于1
		2. 外部：lerna add lodash packages/pac-1 
	2. hoist模式[^3]
		1. 删除每个项目的依赖包 lerna clean
		2. 重新安装依赖lerna bootstrap --hoist
		3. 把多个项目包发布到npm仓库
			1. git push以后，lerna publish。发布时会提示更新版本，版本独立的需要单独选择修改
![[Pasted image 20220724142413.png]]
常用命令
![[Pasted image 20220724145442.png]]
配置
![[Pasted image 20220724150254.png]]
其中
	1. npm与yarn的选择
		1. 都行。yarn比npm天然支持workspaces模式[^4]
			1. 统一lock版本
			2. 使用yarn install安装依赖
注意点：
	1. 不可嵌套
	2. 主仓库必须私有
学习之处：
	1. 解耦上层实现与底层实现
### NX
![[Pasted image 20220724150816.png]]
没有特殊需求，使用lerna
## 多仓库
git submodule
![[Pasted image 20220724142046.png]]

[^1]: 可能希望a升级之后c也升级
[^2]: 根据依赖关系，一个版本的变化会导致另一个的版本变化。版本独立：自己的内容被改变时才修改版本号
[^3]: lerna的一个亮点：避免多个项目依赖同一个包，在每个项目的node_modules产生大量重复代码
[^4]: npm v7也会支持这个模式